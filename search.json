[
  {
    "objectID": "hybrid_automata.html",
    "href": "hybrid_automata.html",
    "title": "Hybrid automata",
    "section": "",
    "text": "We start with an autonomous (=no external/control inputs) hybrid automaton. It is a tuple of sets and (set) mappings \n\\boxed{\n\\mathcal{H} = \\{\\mathcal Q, \\mathcal Q_0, \\mathcal X, \\mathcal X_0, f, \\mathcal I, \\mathcal E, \\mathcal G, \\mathcal R\\},}\n where",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#hybrid-automaton-with-external-events-and-control-inputs",
    "href": "hybrid_automata.html#hybrid-automaton-with-external-events-and-control-inputs",
    "title": "Hybrid automata",
    "section": "Hybrid automaton with external events and control inputs",
    "text": "Hybrid automaton with external events and control inputs\nWe now extend the hybrid automaton with two new components:\n\na set \\mathcal{A} of (external) actions (also events or symbols),\na set \\mathcal{U} external continuous-valued inputs (control inputs or disturbances).\n\n\\boxed{\n  \\mathcal{H} = \\{\\mathcal Q, \\mathcal Q_0, \\mathcal X, \\mathcal X_0, \\mathcal I, \\mathcal A, \\mathcal U, f, \\mathcal E, \\mathcal G, \\mathcal R\\} ,}\n where",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#mathcal-a-a_1a_2ldots-a_s-is-a-set-of-actions",
    "href": "hybrid_automata.html#mathcal-a-a_1a_2ldots-a_s-is-a-set-of-actions",
    "title": "Hybrid automata",
    "section": "\\mathcal A = \\{a_1,a_2,\\ldots, a_s\\} is a set of actions",
    "text": "\\mathcal A = \\{a_1,a_2,\\ldots, a_s\\} is a set of actions\n\nThe role identical as in a (finite) state automaton: an external event triggers an (enabled) transition from the current discrete state (mode, location) to another.\nUnlike in pure discrete-event systems, here they are within a model that does recognize passing of time – each action must be “time-stamped”.\n\n\nIn simulations such timed event can be represented by an edge in the signal. In this regards, it perhaps does not even need to be considered as a seperate entity. But it very often is.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#mathcal-uinmathbb-rm-is-a-set-of-continuous-valued-inputs",
    "href": "hybrid_automata.html#mathcal-uinmathbb-rm-is-a-set-of-continuous-valued-inputs",
    "title": "Hybrid automata",
    "section": "\\mathcal U\\in\\mathbb R^m is a set of continuous-valued inputs",
    "text": "\\mathcal U\\in\\mathbb R^m is a set of continuous-valued inputs\n\nReal-valued functions of time.\nControl inputs, disturbances, references, noises.\n\n\nIn applications it will certainly be useful to distinghuish these roles, but here we keep just a single type of such an external variable, we do not have to distinguish.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#some-modifications-needed",
    "href": "hybrid_automata.html#some-modifications-needed",
    "title": "Hybrid automata",
    "section": "Some modifications needed",
    "text": "Some modifications needed\nupon introduction of these two types of external inputs:\n\nf: \\mathcal Q \\times \\mathcal X \\times \\mathcal U \\rightarrow \\mathbb R^n is a vector field that now depends not only on the location but also on the external (control) input, that is, at a given location we consider the state equation \\dot x = f_q(x,u).\n\\mathcal E\\subseteq \\mathcal Q \\times (\\mathcal A) \\times \\mathcal Q is a set of transitions now possibly parameterized by the actions (as in classical automata).\n\\mathcal I : \\mathcal Q \\rightarrow 2^{\\mathcal{X}\\times \\mathcal U} is a location invariant now augmented with a subset of the control input set.\n\\mathcal G: \\mathcal E \\rightarrow 2^{\\mathcal{X}\\times U} is a guard set now augmented with a subset of the control input set.\n\\mathcal R: \\mathcal E \\times \\mathcal X\\times \\mathcal U\\rightarrow 2^{\\mathcal X} is a (state) reset map that is now additionally parameterized by the control input.\n\n\n\nThe guard set for the given location gives just necessary (also enabling) conditions for the transition (x\\in \\mathcal{G}(q)).\nIf enabled, the transition can happen if one of the two things is satisfied:\n\nthe continous state leaves the invariant set of the given location,\n\nan external event occurs.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-button-controlled-led",
    "href": "hybrid_automata.html#example-button-controlled-led",
    "title": "Hybrid automata",
    "section": "Example: button-controlled LED",
    "text": "Example: button-controlled LED\n. . .\n\n. . .\n\n\\mathcal{Q} = \\{\\mathrm{off}, \\mathrm{dim}, \\mathrm{bright}\\},\\quad \\mathcal{Q}_0 = \\{\\mathrm{off}\\}\n\n. . .\n\n\\mathcal{X} = \\mathbb{R}, \\quad \\mathcal{X}_0 = \\{0\\}\n\n. . .\n\n\\mathcal{I(\\mathrm{off})} = \\mathcal{I(\\mathrm{bright})} = \\mathcal{I(\\mathrm{dim})} = \\{x\\in\\mathbb R \\mid x \\geq 0\\}\n\n. . .\n\nf(x) = 1\n\n. . .\n\n\\mathcal{A} = \\{\\mathrm{press}\\}\n\n. . .\n\n\\begin{aligned}\n\\mathcal{E} &= \\{(\\mathrm{off},\\mathrm{press},\\mathrm{dim}),(\\mathrm{dim},\\mathrm{press},\\mathrm{off}),\\\\\n&\\qquad (\\mathrm{dim},\\mathrm{press},\\mathrm{bright}),(\\mathrm{bright},\\mathrm{press},\\mathrm{off})\\}\n\\end{aligned}\n\n. . .\n\n\\begin{aligned}\n\\mathcal{G}((\\mathrm{off},\\mathrm{press},\\mathrm{dim})) &= \\mathcal X \\\\\n\\mathcal{G}((\\mathrm{dim},\\mathrm{press},\\mathrm{off})) &= \\{x \\in \\mathcal X \\mid x&gt;2\\}\\\\\n\\mathcal{G}((\\mathrm{dim},\\mathrm{press},\\mathrm{bright})) &= \\{x \\in \\mathcal X \\mid x\\leq 2\\}\\\\\n\\mathcal{G}((\\mathrm{bright},\\mathrm{press},\\mathrm{off})) &= \\mathcal X.\n\\end{aligned}\n\n. . .\n\nr((\\mathrm{off},\\mathrm{press},\\mathrm{dim}),x) = 0,\n\n\nthat is, x^+ = r((\\mathrm{off},\\mathrm{press},\\mathrm{dim}),x) = 0.\nFor all other transitions r((\\cdot, \\cdot, \\cdot),x)=x,\n\nthat is, x^+ = x.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-water-tank",
    "href": "hybrid_automata.html#example-water-tank",
    "title": "Hybrid automata",
    "section": "Example: Water tank",
    "text": "Example: Water tank\n\n\n\n\\dot V =\n\\begin{cases}\nQ_\\mathrm{in} - Q_\\mathrm{out,middle} - Q_\\mathrm{out,bottom}, & h&gt;h_\\mathrm{m}\\\\\nQ_\\mathrm{in} - Q_\\mathrm{out,bottom}, & h\\leq h_\\mathrm{m}\n\\end{cases}\n\n. . .",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-bouncing-ball",
    "href": "hybrid_automata.html#example-bouncing-ball",
    "title": "Hybrid automata",
    "section": "Example: Bouncing ball",
    "text": "Example: Bouncing ball\n\n\n\n\n\n\\dot{\\bm x} = \\begin{bmatrix} x_2\\\\ -g\\end{bmatrix}, \\quad \\begin{bmatrix}10,0\\end{bmatrix}",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-bouncing-ball-ha",
    "href": "hybrid_automata.html#example-bouncing-ball-ha",
    "title": "Hybrid automata",
    "section": "Example: bouncing ball – HA",
    "text": "Example: bouncing ball – HA\n. . .\n\n. . .\n\n\\mathcal{Q} = \\{q\\}, \\; \\mathcal{Q}_0 = \\{q\\}\n\n. . .\n\n\\mathcal{X} = \\mathbb R^2, \\; \\mathcal{X}_0 = \\left\\{\\begin{bmatrix}10\\\\0\\end{bmatrix}\\right\\}\n\n. . .\n\n\\mathcal{I} = \\{\\mathbb R^2 \\mid x_1 &gt; 0 \\lor (x_1 = 0 \\land x_2 &gt; 0)\\}\n\n. . .\n\nf(\\bm x) = \\begin{bmatrix} x_2\\\\ -g\\end{bmatrix}\n\n. . .\n\n\\mathcal{E} = \\{(q,q)\\}\n\n. . .\n\n\\mathcal{G} = \\{\\bm x\\in\\mathbb R^2 \\mid x_1=0 \\land x_2 &lt; 0\\}\n\n. . .\n\nr((q,q),\\bm x) = \\begin{bmatrix}x_1\\\\ -\\gamma x_2 \\end{bmatrix},\n where \\gamma is the coefficient of restitution (e.g., \\gamma = 0.9).",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#comment-on-the-invariant-set-for-the-bouncing-ball",
    "href": "hybrid_automata.html#comment-on-the-invariant-set-for-the-bouncing-ball",
    "title": "Hybrid automata",
    "section": "Comment on the invariant set for the bouncing ball",
    "text": "Comment on the invariant set for the bouncing ball\n\nSome authors characterize the invariant set as x_1\\geq 0.\nBut this means that as the ball touches the ground, nothig forces it to leave the location and do the transition.\nInstead, the ball must penetrate the ground, however tiny distance, in order to trigger the transition.\nThe present definition avoids this. On the other hand, when solving the model numerically, the use of inequalities, in particular nonstrict ones, is inevitable.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-stick-slip-friction-karnopp",
    "href": "hybrid_automata.html#example-stick-slip-friction-karnopp",
    "title": "Hybrid automata",
    "section": "Example: Stick-slip friction (Karnopp)",
    "text": "Example: Stick-slip friction (Karnopp)\n\nMass m, external force F_\\mathrm{a}, friction force F_\\mathrm{f} \nm\\dot v = F_\\mathrm{a} - F_\\mathrm{f}(v).\n\nAssuming Coulomb friction \nF_\\mathrm{f}(v) = F_\\mathrm{c}\\operatorname*{sgn}(v).\n\nWhat if v=0 and F_\\mathrm{a}&lt;F_\\mathrm{c}?",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#karnopp-model",
    "href": "hybrid_automata.html#karnopp-model",
    "title": "Hybrid automata",
    "section": "Karnopp model",
    "text": "Karnopp model\n. . .\n\nm\\dot v = 0, \\qquad v=0, \\; |F_\\mathrm{a}| &lt; F_\\mathrm{c}\n\n. . .\n\nF_\\mathrm{f} = \\begin{cases}\\operatorname*{sat}(F_\\mathrm{a},F_\\mathrm{c}), & v=0\\\\F_\\mathrm{c}\\operatorname*{sgn}(v), & \\mathrm{else}\\end{cases}\n\n. . .",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-rimless-wheel",
    "href": "hybrid_automata.html#example-rimless-wheel",
    "title": "Hybrid automata",
    "section": "Example: Rimless wheel",
    "text": "Example: Rimless wheel",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-rimless-wheel-ha",
    "href": "hybrid_automata.html#example-rimless-wheel-ha",
    "title": "Hybrid automata",
    "section": "Example: Rimless wheel – HA",
    "text": "Example: Rimless wheel – HA\n. . .",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-rimless-wheel-alternative-ha-with-a-single-location",
    "href": "hybrid_automata.html#example-rimless-wheel-alternative-ha-with-a-single-location",
    "title": "Hybrid automata",
    "section": "Example: Rimless wheel – alternative HA with a single location",
    "text": "Example: Rimless wheel – alternative HA with a single location\n\nDo not represent the discrete-state variable graphically as a location (a node in the graph) but rather as another state variable s \\in [0, 1, \\ldots, 5] within a single location.\n\n. . .",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-dc-dc-boost-converter",
    "href": "hybrid_automata.html#example-dc-dc-boost-converter",
    "title": "Hybrid automata",
    "section": "Example: DC-DC boost converter",
    "text": "Example: DC-DC boost converter\n\n\nNot just the switch but also the (ideal) diode is introducing mode transitions.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-dc-dc-boost-converter-the-switch-closed",
    "href": "hybrid_automata.html#example-dc-dc-boost-converter-the-switch-closed",
    "title": "Hybrid automata",
    "section": "Example: DC-DC boost converter – the switch closed",
    "text": "Example: DC-DC boost converter – the switch closed\n\n. . .\n\n\\begin{bmatrix}\n\\frac{\\mathrm{d}i_\\mathrm{L}}{\\mathrm{d}t}\\\\\n\\frac{\\mathrm{d}v_\\mathrm{C}}{\\mathrm{d}t}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\frac{R_\\mathrm{L}}{L}i_\\mathrm{L} & 0\\\\\n0 & -\\frac{1}{C(R+R_\\mathrm{C})}\n\\end{bmatrix}\n\\begin{bmatrix}\ni_\\mathrm{L}\\\\\nv_\\mathrm{C}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n\\frac{1}{L}\\\\\n0\n\\end{bmatrix}\nv_0",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-dc-dc-boost-converter-continuous-conduction-mode-ccm",
    "href": "hybrid_automata.html#example-dc-dc-boost-converter-continuous-conduction-mode-ccm",
    "title": "Hybrid automata",
    "section": "Example: DC-DC boost converter – continuous conduction mode (CCM)",
    "text": "Example: DC-DC boost converter – continuous conduction mode (CCM)\n\n. . .\n\n\\begin{bmatrix}\n\\frac{\\mathrm{d}i_\\mathrm{L}}{\\mathrm{d}t}\\\\\n\\frac{\\mathrm{d}v_\\mathrm{C}}{\\mathrm{d}t}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\frac{R_\\mathrm{L}+ \\frac{RR_\\mathrm{C}}{R+R_\\mathrm{C}}}{L} & -\\frac{R}{L(R+R_\\mathrm{C})}\\\\\n\\frac{R}{C(R+R_\\mathrm{C})} & -\\frac{1}{C(R+R_\\mathrm{C})}\n\\end{bmatrix}\n\\begin{bmatrix}\ni_\\mathrm{L}\\\\\nv_\\mathrm{C}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n\\frac{1}{L}\\\\\n0\n\\end{bmatrix}\nv_0",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-dc-dc-boost-converter-discontinuous-cond.-mode-dcm",
    "href": "hybrid_automata.html#example-dc-dc-boost-converter-discontinuous-cond.-mode-dcm",
    "title": "Hybrid automata",
    "section": "Example: DC-DC boost converter – discontinuous cond. mode (DCM)",
    "text": "Example: DC-DC boost converter – discontinuous cond. mode (DCM)\n\n. . .\n\n\\begin{bmatrix}\n\\frac{\\mathrm{d}i_\\mathrm{L}}{\\mathrm{d}t}\\\\\n\\frac{\\mathrm{d}v_\\mathrm{C}}{\\mathrm{d}t}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 & 0\\\\\n0 & -\\frac{1}{C(R+R_\\mathrm{C})}\n\\end{bmatrix}\n\\begin{bmatrix}\ni_\\mathrm{L}\\\\\nv_\\mathrm{C}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n0\\\\\n0\n\\end{bmatrix}\nv_0\n\n\nPossibly the events of opening and closingg the switch can be driven by time: opening the switch is derived from the value of an input signal, closing the switch is periodic.",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_automata.html#example-dc-dc-boost-converter-ha",
    "href": "hybrid_automata.html#example-dc-dc-boost-converter-ha",
    "title": "Hybrid automata",
    "section": "Example: DC-DC boost converter – HA",
    "text": "Example: DC-DC boost converter – HA",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_equations_references.html",
    "href": "hybrid_equations_references.html",
    "title": "Literature",
    "section": "",
    "text": "The theoretical and computational framework of hybrid equations has been mostly developed by a relatively small circle of researchers (Sanfelice, Goebel, Teel, …). The primary monograph is [1]. It is also supported by a freely available Matlab toolbox, see the section on software.\n\nThe book [2] can be regarded as a predecessor and/or complement of the just mentioned [1]. Although the book is not available online, a short version appears as an article [3] in the popular IEEE Control Systems magazine (the one with color figures :-).\n\n\n\n\n\n Back to topReferences\n\n[1] R. G. Sanfelice, Hybrid Feedback Control. Princeton University Press, 2021. Accessed: Sep. 23, 2020. [Online]. Available: https://press.princeton.edu/books/hardcover/9780691180229/hybrid-feedback-control\n\n\n[2] R. Goebel, R. G. Sanfelice, and A. R. Teel, Hybrid Dynamical Systems: Modeling, Stability, and Robustness. Princeton University Press, 2012. Available: https://press.princeton.edu/books/hardcover/9780691153896/hybrid-dynamical-systems\n\n\n[3] R. Goebel, R. G. Sanfelice, and A. R. Teel, “Hybrid dynamical systems,” IEEE Control Systems Magazine, vol. 29, no. 2, pp. 28–93, Apr. 2009, doi: 10.1109/MCS.2008.931718.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Literature"
    ]
  },
  {
    "objectID": "intro_outline.html",
    "href": "intro_outline.html",
    "title": "Course outline",
    "section": "",
    "text": "The course is structured into 14 topics, each of them corresponding to one lecture. The topics are as follows:\n\nDiscrete-event systems\n\n(State) automata (state machines) (incl. timed variants)\nPetri nets (and timed Petri nets),\nMax-Plus algebra and Max-Plus Linear (MPL) systems\n\nHybrid systems\n\nHybrid automata\nHybrid equations\n\nSpecial classes of hybrid systems\n\nReset (control) systems, Switched/switching systems, Piecewise affine systems (PWA)\nComplementarity dynamical systems (and complementarity optimization constraints)\n\n\n\n\nSolutions of hybrid systems\n\n\nStability of hybrid systems\n\nCommon Lyapunov function\n\nQuadratic Lyapunov function via linear matrix inequality (LMI) and semidefinite programming (SDP)\nPolynomial Lyapunov function via sum-of-squares (SOS) programming\n\nPiecewise quadratic/polynomial Lyapunov function via S-procedure\n\n\n\nMixed-logical dynamical (MLD) description of hybrid systems\nModel predictive control (MPC) for MLD systems\n(Formal) verification of hybrid systems\n\n\n\n\n Back to top",
    "crumbs": [
      "0. Introduction",
      "Course outline"
    ]
  },
  {
    "objectID": "verification_references.html",
    "href": "verification_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "12. Formal verification",
      "Literature"
    ]
  },
  {
    "objectID": "mld_intro.html",
    "href": "mld_intro.html",
    "title": "Mixed logical dynamical",
    "section": "",
    "text": "Our motivation is to get rid of the IF-THEN conditions in the model."
  },
  {
    "objectID": "mld_intro.html#propositional-logic-and-connectives",
    "href": "mld_intro.html#propositional-logic-and-connectives",
    "title": "Mixed logical dynamical",
    "section": "Propositional logic and connectives",
    "text": "Propositional logic and connectives\n\nBoolean variable (or elementary proposition) \\(X\\) evaluates to true or false.\n\nFor convenience also 0 or 1, but …\n\nConnectives\n\nConjunction (logical and): \\(X_1 \\land X_2\\)\nDisjunction (logical or): \\(X_1 \\lor X_2\\)\nNegation: \\(\\neg X_2\\) (or \\(\\overline{X_2}\\) or \\(\\sim X_2\\))\nImplication: \\(X_1 \\implies X_2\\)\nEquivalence: \\(X_1 \\iff X_2\\)\nLogical XOR: \\(X_1 \\oplus X_2\\)"
  },
  {
    "objectID": "mld_intro.html#equivalences-of-logic-propositions",
    "href": "mld_intro.html#equivalences-of-logic-propositions",
    "title": "Mixed logical dynamical",
    "section": "Equivalences of logic propositions",
    "text": "Equivalences of logic propositions\n. . .\n\\[\nX_1 \\implies X_2 \\quad  \\text{is equivalent to} \\quad \\neg X_2 \\implies \\neg X_1\n\\]\n. . .\n\\[\nX_1 \\iff X_2 \\quad  \\text{eq.} \\quad (X_1 \\implies X_2) \\land (X_2 \\implies X_1)\n\\]\n. . .\n\\[\nX_1 \\land X_2 \\qquad  \\text{eq.} \\qquad \\neg (\\neg X_1 \\lor \\neg X_2)\n\\]\n. . .\n\\[\nX_1 \\implies X_2 \\qquad  \\text{eq.} \\qquad \\neg X_1 \\lor X_2\n\\]\n\nThe last one can be seen as follows: it cannot happen that \\(X1 \\land \\neg X2\\), that is, it holds that \\(\\neg(X1 \\land \\neg X2)\\). De Morgan gives \\(\\neg X1 \\lor X2\\)"
  },
  {
    "objectID": "mld_intro.html#binary-variables-related-to-the-boolean-ones",
    "href": "mld_intro.html#binary-variables-related-to-the-boolean-ones",
    "title": "Mixed logical dynamical",
    "section": "Binary variables related to the Boolean ones",
    "text": "Binary variables related to the Boolean ones\n\nAssociate with the Boolean variable \\(X\\) a binary variable \\(\\delta\\in\\{0,1\\}\\) such that \\[\n\\delta =\n\\begin{cases}\n0 & \\text{if} \\; \\neg X\\\\\n1 & \\text{if} \\; X\n\\end{cases}\n\\]"
  },
  {
    "objectID": "mld_intro.html#integer-inequalities-related-to-the-logical-formulas",
    "href": "mld_intro.html#integer-inequalities-related-to-the-logical-formulas",
    "title": "Mixed logical dynamical",
    "section": "Integer (in)equalities related to the logical formulas",
    "text": "Integer (in)equalities related to the logical formulas"
  },
  {
    "objectID": "mld_intro.html#and",
    "href": "mld_intro.html#and",
    "title": "Mixed logical dynamical",
    "section": "And",
    "text": "And\n\\[X_1 \\land X_2\\]\n. . .\n\\[[\\delta_1=1] \\land [\\delta_2=1]\\]\n. . .\n\\[\\delta_1=1, \\; \\delta_2=1\\]\n\nAnother (discarded) possibility:\n\n. . .\n\\[\\delta_1 \\delta_2 = 1\\]"
  },
  {
    "objectID": "mld_intro.html#or",
    "href": "mld_intro.html#or",
    "title": "Mixed logical dynamical",
    "section": "Or",
    "text": "Or\n\\[X_1 \\lor X_2\\]\n. . .\n\\[[\\delta_1=1] \\lor [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 + \\delta_2\\geq 1\\]"
  },
  {
    "objectID": "mld_intro.html#negation",
    "href": "mld_intro.html#negation",
    "title": "Mixed logical dynamical",
    "section": "Negation",
    "text": "Negation\n\\[\\neg X_1\\]\n. . .\n\\[\\neg [\\delta_1=1]\\]\n. . .\n\\[\\delta_1 = 0\\]"
  },
  {
    "objectID": "mld_intro.html#xor",
    "href": "mld_intro.html#xor",
    "title": "Mixed logical dynamical",
    "section": "Xor",
    "text": "Xor\n\\[X_1 \\oplus X_2\\]\n. . .\n\\[[\\delta_1=1] \\oplus [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 + \\delta_2 = 1\\]"
  },
  {
    "objectID": "mld_intro.html#implication",
    "href": "mld_intro.html#implication",
    "title": "Mixed logical dynamical",
    "section": "Implication",
    "text": "Implication\n\\[X_1 \\implies X_2\\]\n. . .\n\\[[\\delta_1=1] \\implies [\\delta_2=1]\\]\n\nequivalently, using \\(\\neg X_1 \\lor X_2\\), \\[\\neg [\\delta_1=1] \\lor [\\delta_2=1],\\]\nwhich translates to \\[(1-\\delta_1) + \\delta_2\\geq 1,\\]\nwhich simplifies to \\[\\delta_1 - \\delta_2 \\leq 0\\]"
  },
  {
    "objectID": "mld_intro.html#equivalence",
    "href": "mld_intro.html#equivalence",
    "title": "Mixed logical dynamical",
    "section": "Equivalence",
    "text": "Equivalence\n\\[X_1 \\iff X_2\\]\n. . .\n\\[[\\delta_1=1] \\iff [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 - \\delta_2 = 0\\]"
  },
  {
    "objectID": "mld_intro.html#assignment",
    "href": "mld_intro.html#assignment",
    "title": "Mixed logical dynamical",
    "section": "Assignment",
    "text": "Assignment\n\\[X_3 \\iff (X_1 \\land X_2)\\]\n. . .\n\\[[\\delta_3=1] \\iff ([\\delta_1=1] \\land [\\delta_2=1])\\]\n\nExpressing the equivalence using implications \\[X_3 \\implies X_1,\\; X_3\\implies X_2, \\; (X_1 \\land X_2) \\implies X_3\\]\nThe the last one is equivalent to \\[\\neg (X_1 \\land X_2) \\lor X_3\\]\nwhich can be simplified to \\[\\neg X_1 \\lor \\neg X_2 \\lor X_3\\]\nwhich translates to \\[\\neg [\\delta_1=1] \\lor \\neg [\\delta_2 = 1] \\lor [\\delta_3 = 1]\\]\nwhich finally leads to the inequality \\[(1-\\delta_1) + (1-\\delta_2) + \\delta_3 \\geq 1\\]\nand after simplification \\[\\delta_1 + \\delta_2 - \\delta_3 \\leq 1.\\]\nAnd don’t forget to consider the first to inequalities too \\[\n-\\delta_1 + \\delta_3 \\leq 0, \\quad -\\delta_2 + \\delta_3 \\leq 0.\n\\]"
  },
  {
    "objectID": "mld_intro.html#general-transformation-of-boolean-expressions-to-integer-inequalities",
    "href": "mld_intro.html#general-transformation-of-boolean-expressions-to-integer-inequalities",
    "title": "Mixed logical dynamical",
    "section": "General transformation of Boolean expressions to integer inequalities",
    "text": "General transformation of Boolean expressions to integer inequalities\n\nFrom Conjunctive Normal Form (CNF) \\[\n\\bigwedge_{j=1}^m \\left[\\left(\\lor_{i\\in \\mathcal{P}_j} X_i\\right) \\lor \\left(\\lor_{i\\in \\mathcal{N}_j} \\neg X_i\\right)\\right]\n\\]\nto 0-1 integer inequalities defining a polyhedron \\[\n\\begin{aligned}\n\\sum_{i\\in \\mathcal{P}_1} \\delta_i + \\sum_{i\\in \\mathcal{N}_1} (1-\\delta_i) &\\geq 1,\\\\\n&\\vdots\\\\\n\\sum_{i\\in \\mathcal{P}_m} \\delta_i + \\sum_{i\\in \\mathcal{N}_m} (1-\\delta_i) &\\geq 1.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#finite-state-machine-fsm-using-binary-variables",
    "href": "mld_intro.html#finite-state-machine-fsm-using-binary-variables",
    "title": "Mixed logical dynamical",
    "section": "Finite state machine (FSM) using binary variables",
    "text": "Finite state machine (FSM) using binary variables\n\nEncode the discrete state variables in binary \\[\nx_b \\in \\{0,1\\}^{n_b}\n\\]\nSimilarly the discrete inputs \\[\nu_b \\in \\{0,1\\}^{m_b}\n\\]\nThe logical state equation then \\[\nx_b(k+1) = f_b(x_b(k),u_b(k),\\delta_e(k))\n\\]"
  },
  {
    "objectID": "mld_intro.html#example",
    "href": "mld_intro.html#example",
    "title": "Mixed logical dynamical",
    "section": "Example",
    "text": "Example\n. . .\n\n\nState update/transition equation \\[\n\\begin{aligned}\n& x_d(k+1) = \\\\\n&\\begin{cases}\n\\text{Red} & \\text{if}\\; ([x_d = \\text{green}] \\land \\neg [\\delta_3=1]) \\lor ([x_d = \\text{red}] \\land \\neg [\\delta_3=1])\\\\\n\\text{Green} & \\text{if} \\; \\ldots\\\\\n\\text{Blue} & \\text{if} \\; \\ldots\n\\end{cases}\n\\end{aligned}\n\\]\nBinary encoding of the discrete states \\[\n\\text{Red}: x_b = \\begin{bmatrix}0\\\\0 \\end{bmatrix}, \\; \\text{Green}: x_b = \\begin{bmatrix}0\\\\1 \\end{bmatrix}, \\; \\text{Blue}: x_b = \\begin{bmatrix}1\\\\0 \\end{bmatrix}\n\\]\nReformulating the state update equations for binary variables \\[\n\\begin{aligned}\nx_{b1} &= (\\neg [x_{b1} = 1] \\land \\neg [x_{b2} = 1]  \\land \\neg [\\delta_1=1]) \\\\\n&\\quad (\\neg [x_{b1} = 1] \\land \\neg [x_{b2} = 1]  \\land [\\delta_1=1]) \\land [u_{b2}=1]\\\\\n&\\quad (\\neg [x_{b1} = 1] \\land [x_{b2} = 1]  \\land \\neg [u_{b1}=1] \\land [\\delta_3=1])\\\\\n&\\quad \\lor ([x_{b1} = 1]\\land \\neg [\\delta_2=1])\\\\\nx_{b2} &= \\ldots\n\\end{aligned}\n\\]\nSimplify, convert to CNF."
  },
  {
    "objectID": "mld_intro.html#mixing-logical-and-continuous",
    "href": "mld_intro.html#mixing-logical-and-continuous",
    "title": "Mixed logical dynamical",
    "section": "Mixing logical and continuous",
    "text": "Mixing logical and continuous\n\nsee Indicator variables."
  },
  {
    "objectID": "mld_intro.html#logical-implies-continuous",
    "href": "mld_intro.html#logical-implies-continuous",
    "title": "Mixed logical dynamical",
    "section": "Logical implies continuous",
    "text": "Logical implies continuous\n\\[X \\implies [f(x)\\leq 0]\\]\n. . .\n\\[[\\delta = 1] \\implies [f(x)\\leq 0]\\]\n\nintroduce \\(M\\) \\[\nf(x) \\leq (1-\\delta) M\n\\]\nthat is large enough so that when \\(\\delta=0\\), there is no practical restriction on \\(f\\).\n\nBig-M technique."
  },
  {
    "objectID": "mld_intro.html#continuous-implies-logical",
    "href": "mld_intro.html#continuous-implies-logical",
    "title": "Mixed logical dynamical",
    "section": "Continuous implies logical",
    "text": "Continuous implies logical\n\\[[f(x)\\leq 0] \\implies X\\]\n. . .\n\\[[f(x)\\leq 0] \\implies [\\delta = 1]\\]\n\nEquivalently \\[\\neg [\\delta = 1] \\implies \\neg [f(x)\\leq 0],\\]\nthat is, \\[[\\delta = 0] \\implies [f(x) &gt; 0]\\]\nIntroduce \\(m\\) such that \\(f(x)&gt;0\\) is enforced when \\(\\delta=0\\) \\[\nf(x) &gt; m\\delta\n\\]\nbut small enough that there is no restriction on \\(f\\) when \\(\\delta=1\\).\nFor numerical reasons, modify to nonstrict inequality \\[\nf(x) \\geq \\epsilon + (m-\\epsilon)\\delta,\n\\] where \\(\\epsilon\\approx 0\\) (for example, machine epsilon)."
  },
  {
    "objectID": "mld_intro.html#equivalence-between-logical-and-continuous",
    "href": "mld_intro.html#equivalence-between-logical-and-continuous",
    "title": "Mixed logical dynamical",
    "section": "Equivalence between logical and continuous",
    "text": "Equivalence between logical and continuous\n\nCombining the previous two implications.\n\n. . .\n\\[\n\\begin{aligned}\nf(x) &\\leq (1-\\delta) M,\\\\\nf(x) &\\geq \\epsilon + (m-\\epsilon)\\delta.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#if-then-else-rule-as-an-inequality",
    "href": "mld_intro.html#if-then-else-rule-as-an-inequality",
    "title": "Mixed logical dynamical",
    "section": "IF-THEN-ELSE rule as an inequality",
    "text": "IF-THEN-ELSE rule as an inequality\n\nIf \\(X\\)\n\nthen \\(z = a^\\top x + b^\\top u + f\\),\nelse \\(z = 0\\).\n\nIt can be expressed as a product \\[\nz = \\delta\\,(a^\\top x + b^\\top u + f)\n\\]\n\n. . .\n\\[\n\\begin{aligned}\nz &\\leq M\\delta,\\\\\n- z &\\leq -m\\delta,\\\\\nz &\\leq a^\\top x + b^\\top u + f - m(1-\\delta),\\\\\n-z &\\leq -(a^\\top x + b^\\top u + f) + M(1-\\delta).\n\\end{aligned}\n\\]\n\nThe reasoning is that if \\(\\delta=0\\), then \\(z\\) is restricted, while \\(a^\\top x + b^\\top u + f\\) is not. And the other way around."
  },
  {
    "objectID": "mld_intro.html#another-if-then-else-rule",
    "href": "mld_intro.html#another-if-then-else-rule",
    "title": "Mixed logical dynamical",
    "section": "Another IF-THEN-ELSE rule",
    "text": "Another IF-THEN-ELSE rule\n\nIf \\(X\\)\n\nthen \\(z = a_1^\\top x + b_1^\\top u + f_1\\),\nelse \\(z = a_2^\\top x + b_2^\\top u + f_2\\).\n\nIt can be expressed as \\[\n\\begin{aligned}\nz &= \\delta\\,(a_1^\\top x + b_1^\\top u + f_1) \\\\\n&\\quad + (1-\\delta)(a_2^\\top x + b_2^\\top u + f_2)\n\\end{aligned}\n\\]\n\n. . .\n\\[\n\\begin{aligned}\n(m_2-M_1)\\delta  + z &\\leq a_2^\\top x + b_2^\\top u + f_2,\\\\\n(m_1-M_2)\\delta  - z &\\leq -a_2^\\top x - b_2^\\top u - f_2,\\\\\n(m_1-M_2)(1-\\delta)  + z &\\leq a_1^\\top x + b_1^\\top u + f_1,\\\\\n(m_2-M_1)(1-\\delta)  - z &\\leq -a_1^\\top x - b_1^\\top u - f_1.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#generation-of-events-by-mixing-logical-and-continuous-variables-in-inequalities",
    "href": "mld_intro.html#generation-of-events-by-mixing-logical-and-continuous-variables-in-inequalities",
    "title": "Mixed logical dynamical",
    "section": "Generation of events by mixing logical and continuous variables in inequalities",
    "text": "Generation of events by mixing logical and continuous variables in inequalities\n\\[\n\\begin{aligned}\nh_i(x_c(k), u_c(k)) &\\leq M_i (1-\\delta_{e,i})\\\\\nh_i(x_c(k), u_c(k)) &\\geq \\epsilon + (m_i-\\epsilon) \\delta_{e,i}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#switched-affine-system",
    "href": "mld_intro.html#switched-affine-system",
    "title": "Mixed logical dynamical",
    "section": "Switched affine system",
    "text": "Switched affine system\n\nWe want to get rid of the IF-THEN and formulate the switching mechanism into the format of inequalities too.\n\n. . .\n\\[\nx_c(k+1) = \\sum_{i=1}^s z_i(k),  \n\\]\n\nwhere \\[\nz_1(k) =\n\\begin{cases}\nA_1 x_c(k) + B_1 u_c(k) + f_1 & \\text{if}\\;i(k)=1\\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\n. . .\n\\[\\quad \\vdots\\]\n. . .\n\\[\nz_s(k) =\n\\begin{cases}\nA_s x_c(k) + B_s u_c(k) + f_s & \\text{if}\\;i(k)=s\\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\nFor each \\(i\\in \\{1, 2, \\ldots, s\\}\\)\n\n. . .\n\\[\n\\begin{aligned}\nz_i &\\leq M_i\\delta_i,\\\\\n- z_i &\\leq -m_i\\delta_i,\\\\\nz_i &\\leq a_i^\\top x + b_i^\\top u + f_i - m_i(1-\\delta_i),\\\\\n-z_i &\\leq -(a_i^\\top x + b_i^\\top u + f_i) + M_i(1-\\delta_i).\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#mixed-logical-dynamical-mld-system",
    "href": "mld_intro.html#mixed-logical-dynamical-mld-system",
    "title": "Mixed logical dynamical",
    "section": "Mixed logical dynamical (MLD) system",
    "text": "Mixed logical dynamical (MLD) system\n\\[\n\\begin{aligned}\nx(k+1) &= Ax(k) + B_u u(k) + B_\\delta\\delta + B_zz(k) + B_0\\\\\ny(k) &= Cx(k) + D_u u(k) + D_\\delta \\delta + D_z z + D_0\\\\\nE_\\delta \\delta &+ E_z z(k) \\leq E_u u(k) + E_x x(k) + E_0  \n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#simple-example",
    "href": "mld_intro.html#simple-example",
    "title": "Mixed logical dynamical",
    "section": "Simple example",
    "text": "Simple example"
  },
  {
    "objectID": "mld_intro.html#hysdel-language",
    "href": "mld_intro.html#hysdel-language",
    "title": "Mixed logical dynamical",
    "section": "HYSDEL language",
    "text": "HYSDEL language"
  },
  {
    "objectID": "mld_intro.html#piecewise-affine-systems",
    "href": "mld_intro.html#piecewise-affine-systems",
    "title": "Mixed logical dynamical",
    "section": "Piecewise affine systems",
    "text": "Piecewise affine systems\n. . .\n\\[\n\\begin{aligned}\nx(k+1) &= A_{i(k)}x(k) + B_{i(k)} u(k) + f_{i(k)}\\\\\ny(k) &= C_{i(k)}x(k) + D_{i(k)} u(k) + g_{i(k)}\\\\\n& \\; H_{i(k)} x(k) + J_{i(k)} u(k) \\leq K_{i(k)}\n\\end{aligned}\n\\]\n\nDHA, MLD, PWA are equivalent."
  },
  {
    "objectID": "petri_nets_timed.html",
    "href": "petri_nets_timed.html",
    "title": "Timed Petri nets",
    "section": "",
    "text": "Recall that when introducing enabled transitions, we emphasized that these can but do not have to fire immediately after having been enabled \\boxed{\\mathrm{ENABLING} \\neq \\text{FIRING}.}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "petri_nets_timed.html#delays-associated-with-transitions",
    "href": "petri_nets_timed.html#delays-associated-with-transitions",
    "title": "Timed Petri nets",
    "section": "Delays associated with transitions",
    "text": "Delays associated with transitions\nWell then, the enabled transitions do not have to fire immediately, but they can possibly fire with some delay after enabling. This is for the first time that we are introducing the concept of time into the Petri nets, isn’t it?\nFor the j-th transition, the delay of the k-th firing is v_{j,k}, v_j = \\{v_{j,1}, v_{j,2}, \\ldots \\}.\nBut not all transitions have to be timed. Denote the timed transitions \\mathcal{T}_\\mathrm{D}\\subseteq \\mathcal{T}. We define the clock structure for a PN as \\mathcal{V} = \\{v_j\\mid t_j\\in\\mathcal{T}_\\mathrm{D}\\}.\nThe definition of a timed Petri net (TPN) is then obtained by augmenting the definition of a Petri net with the clock structure\n\\boxed{TPN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w, x, \\mathcal{V}\\}}.\n\nExample 1 (Timed Petri net) Model of processing multiple tasks: task 1 and task 2 are processed sequentially, and task 3 is processed in parallel with them; task 4 can only be processed after both tasks 2 and 3 have been finished. Finishing individual tasks corresponds to the individual transitions. The transition 4 is untimed, it only expresses the logical requirement.\n\n\n\nExample of a timed Petri net\n\n\n\n\n\n\n\n\n\nRectangles instead of bars\n\n\n\nSometimes instead of a bar, the untimed transitions are modelled using similarly thing rectangles as the timed transitions, but filled.\n\n\n\nPlaces can also be delayed\nWith delays associated with just one type of a node in a Petri net, the situation is rather nonsymmetric. In some literature, delays can also associated with places (and yet in some other literature delays are only associated with delays). Such delays associated with places are called holding time for a place It is the minimum duration the token must rest in the place. But the token can stay longer if the output transition is waiting for other places.\n\n\n\n\n\n\nDelays associated with transitions and places\n\n\n\nThere is a major difference in delays associated with places compared to the delays associated with transitions. While the former tell the minimum duration the token has to dwell in the place, the latter tell the exact delay with which the transition fires after having been enabled.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "petri_nets_timed.html#timed-petri-net-dynamics",
    "href": "petri_nets_timed.html#timed-petri-net-dynamics",
    "title": "Timed Petri nets",
    "section": "Timed Petri net dynamics",
    "text": "Timed Petri net dynamics\nWith the introduction of time into the Petri nets, we can now study the dynamics of the system. For general Petri nets, alhough perfectly doable, it may quicly become too complex, and therefore here we only consider event graphs.\nSome notation:\n\n\\{\\tau_{j,1}, \\tau_{j,2}, \\ldots\\} are firing times of the j-th transition.\n\\{\\pi_{i,1},\\pi_{i,2},\\ldots\\} are times when the i-th place receives a token.\nx_i = x(p_i) is the number of tokens at the i-th place,\nx_{i,k} = \\left.x(p_i)\\right|_k, that is, after the k-th firing.\n\nAnd some assumptions:\n\nAssume first that x_{i,0} = 0: \\pi_{i,k} = \\tau_{j,k},\\quad p_i\\in \\mathcal{O}(t_j).\nBut generally x_{i,0} \\neq 0: \\pi_{i,k+x_{i,0}} = \\tau_{j,k},\\quad p_i\\in \\mathcal{O}(t_j),\nequivalently \\boxed{\\pi_{i,k} = \\tau_{j,k-x_{i,0}},\\quad p_i\\in \\mathcal{O}(t_j).}\nFor an untimed transition with a single input place \n\\tau_{j,k} = \\pi_{i,k}.\n\nFor a timed transition with a single input place \n\\tau_{j,k} = \\pi_{i,k} + v_{j,k}.\n\nFor a timed transition with multiple input places \\boxed{\n\\tau_{j,k} = \\max_{p_i\\in\\mathcal{I}(t_j)}\\{\\pi_{i,k}\\} + v_{j,k}.}\n\n\n\nExample 2 (Timed Petri net dynamics)  \n\n\n\nExample of a Petri net for which the dynamics is analyzed\n\n\n\n\\begin{aligned}\n\\tau_{1,k} &= \\max\\{\\pi_{1,k},\\pi_{3,k}\\}\\\\\n\\tau_{2,k} &= \\pi_{2,k}+v_{2,k}\n\\end{aligned}\n\n\n\\begin{aligned}\n\\pi_{1,k} &= \\tau_{1,k-1}, \\qquad k=2,\\ldots, \\qquad \\pi_{1,0} = 0\\\\\n\\pi_{2,k} &= \\tau_{1,k-1}, \\qquad k=2,\\ldots, \\qquad \\pi_{2,0} = 0\\\\\n\\pi_{3,k} &= \\tau_{2,k}, \\qquad k=1,\\ldots\n\\end{aligned}\n\n\n\\begin{aligned}\n\\tau_{1,k} &= \\max\\{\\tau_{1,k-1},\\tau_{1,k-1}+v_{2,k}\\}\\\\\n&= \\tau_{1,k-1}+v_{2,k}, \\quad \\tau_{1,k} = 0\\\\\n\\tau_{2,k} &= \\tau_{1,k-1}+v_{2,k}\n\\end{aligned}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "petri_nets_timed.html#queueing-system-using-tpn",
    "href": "petri_nets_timed.html#queueing-system-using-tpn",
    "title": "Timed Petri nets",
    "section": "Queueing system using TPN",
    "text": "Queueing system using TPN\nWe can also model a queueing system using a TPN. The Petri net is shown in Figure 1.\n\n\n\n\n\n\nFigure 1: Timed Petri net modelling a queueing system\n\n\n\n\nTransitions: \\mathcal{T} = \\{a,s,c\\}\nTimed/delayed transitions: \\mathcal{T}_\\mathrm{D} = \\{a,c\\}\nFiring delays: \\bm v = \\begin{bmatrix}v_a \\\\ v_c\\end{bmatrix}\n\nFor convenience we relabel the firing times of the transitions (instead of t_k we will use a_k, s_k, and c_k): \n\\begin{aligned}\na_k &= a_{k-1} + v_{a,k},\\quad k=1,2,\\ldots,\\quad a_0 = 0\\\\\ns_k &= \\max\\{\\pi_{Q,k},\\pi_{I,k}\\}\\\\\nc_k &= \\pi_{B,k} + v_{c,k}\\\\\n\\pi_{Q,k} &= a_{k},\\quad k=1,2,\\ldots\\\\\n\\pi_{I,k} &= c_{k-1},\\quad k= 2, \\ldots, \\quad \\pi_{I,0}=1\\\\\n\\pi_{B,k} &= s_{k},\\quad k=1,2,\\ldots\\\\\n\\end{aligned}\n\n\n\\begin{aligned}\na_k &= a_{k-1} + v_{a,k},\\quad k=1,2,\\ldots,\\quad a_0 = 0\\\\\ns_k &= \\max\\{a_{k},c_{k-1}\\}\\\\\nc_k &= s_{k} + v_{c,k}\\\\\n&= \\max\\{a_{k},c_{k-1}\\} + v_{c,k},\\quad k=1,\\ldots, \\quad c_0=0\n\\end{aligned}\n\nThe time of completing the k-th task is given by the time at which the previous task was completed and the time needed to complete the k-th task itself, unless there is a gap in the queue after finishing the previous task, in which case the server must wait for the next task to arrive.\n\nExample 4 (Timed Petri net for synchronization of train lines)  \n\n\n\nExample with three train lines\n\n\nSynchronization of departures at a given station so that passenges can change trains.\n\n\n\nTimed Petri net for the example of synchronization of three train lines\n\n\n\nExample 3 (Manufacturing) tbd\n\n\nExtensions\n\nStochastic Petri nets (SPN): the delays are random variables.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "petri_nets_timed.html#extensions",
    "href": "petri_nets_timed.html#extensions",
    "title": "Timed Petri nets",
    "section": "Extensions",
    "text": "Extensions\n\nStochastic Petri nets (SPN): the delays are random variables.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "mpc_mld_explicit.html",
    "href": "mpc_mld_explicit.html",
    "title": "Explicit MPC for hybrid systems",
    "section": "",
    "text": "Model predictive control (MPC) is not computationally cheap (compared to, say, PID or LQG control) as it requires solving optimization problem – typically a quadratic program (QP) - online. The optimization solver needs to be a part of the controller.\nThere is an alternative, though, at least in same cases. It is called explicit MPC. The computationally heavy optimization is only perfomed only during the design process and the MPC controller is then implemented just as an affine state feedback\n\\bm u_k(\\bm x(k)) = \\mathbf F_k^i \\bm x(k) + \\mathbf g_k^i,\\; \\text{if}\\; \\bm x(k) \\in \\mathcal R_k^i,\nwith the coefficients picked from some kind of a lookup table in real time Although retreiving the coefficients of the feedback controller is not computationally trivial, still it is cheaper than full optimization.",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Explicit MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_explicit.html#multiparametric-programming",
    "href": "mpc_mld_explicit.html#multiparametric-programming",
    "title": "Explicit MPC for hybrid systems",
    "section": "Multiparametric programming",
    "text": "Multiparametric programming\nThe key technique for explicit MPC is multi-parametric programming. In order to explain it, consider the following problem\n\nJ^\\ast(x) = \\inf_z J(z;x).\n\nThe z variable is an optimization variable, while x is a parameter. For a given parameter x, the cost function J is minimized. We study how the optimal cost J^\\ast depends on the parameter, hence the name parametric programming. If x is a vector, the name of the problem changes to multiparametric programming.\n\nExample: scalar variable, single parameter\nConsider the following cost function J(z;x) in z parameterized by x. The optimization variable z is constrained and this constraint is also parameterized by x. \n\\begin{aligned}\nJ(z;x) &= \\frac{1}{2} z^2 + 2zx + 2x^2 \\\\\n\\text{subject to} &\\quad  z \\leq 1 + x.\n\\end{aligned}\n\nIn this simple case we can aim at analytical solution. We proceed in the standard way – we introduce a Lagrange multiplicator \\lambda and form the augmented cost function \nL(z,\\lambda; x) = \\frac{1}{2} z^2 + 2zx + 2x^2 + \\lambda (z-1-x).\n\nThe necessary conditions of optimality for the inequality-constrained problem come in the form of KKT conditions \n\\begin{aligned}\nz + 2x + \\lambda &= 0,\\\\\nz - 1 - x &\\leq  0,\\\\\n\\lambda & \\geq 0,\\\\\n\\lambda (z - 1 - x) &= 0.\n\\end{aligned}\n\nThe last condition – the complementarity condition – gives rise to two scenarios: one corresponding to \\lambda = 0, and the other corresponding to z - 1 - x = 0. We consider them separately below.\nAfter substituting \\lambda = 0 into the KKT conditions, we get \n\\begin{aligned}\nz + 2x &= 0,\\\\\nz - 1 - x & \\leq  0.\n\\end{aligned}\n\nFrom the first equation we get how z depends on x, and from the second we obtain a bound on x. Finally, we can also substitute the expression for z into the cost function J to get the optimal cost J^\\ast as a function of x. All these are summarized here \n\\begin{aligned}\nz &= -2x,\\\\\nx & \\geq -\\frac{1}{3},\\\\\nJ^\\ast(x) &= 0.\n\\end{aligned}\n\nNow, the other scenario. Upon substitutin z - 1 - x = 0 into the KKT conditions we get\n\n\\begin{aligned}\nz + 2x + \\lambda &= 0,\\\\\nz - 1 - x &=  0,\\\\\n\\lambda & \\geq 0.\n\\end{aligned}\n\nFrom the second equation we get the expression for z in terms of x, substituting into the first equation and invoking the condition on nonnegativity of \\lambda we get the bound on x (not suprisingly it complements the one obtained in the previous scenario). Finally, substituting for z in the cost function J we get a formula for the cost J^\\ast as a function of x.\n\n\\begin{aligned}\nz &= 1 + x,\\\\\n\\lambda &= -z - 2x \\geq 0 \\quad \\implies \\quad x \\leq -\\frac{1}{3},\\\\\nJ^\\ast(x) &= \\frac{9}{2}x^2 + 3x + \\frac{1}{2}.\n\\end{aligned}\n\nThe two scenarios can now be combined into a single piecewise affine function z(x) \nz(x) = \\begin{cases}\n1+x & \\text{if } x \\leq -\\frac{1}{3},\\\\\n-2x & \\text{if } x &gt; -\\frac{1}{3}.\n\\end{cases}\n\n\nx = range(-1, 1, length=100)\nz(x) = x &lt;= -1/3 ? 1 + x : -2x\nJstar(x) = x &lt;= -1/3 ? 9/2*x^2 + 3x + 1/2 : 0\n\nusing Plots\nplot(x, z.(x), label=\"z(x)\")\nvline!([-1/3],line=:dash)\nxlabel!(\"x\")\nylabel!(\"z(x)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand a piecewise quadratic cost function J^\\ast(x) \nJ^\\ast(x) = \\begin{cases}\n\\frac{9}{2}x^2 + 3x + \\frac{1}{2} & \\text{if } x \\leq -\\frac{1}{3},\\\\\n0 & \\text{if } x &gt; -\\frac{1}{3}.\n\\end{cases}\n\n\nplot(x, Jstar.(x), label=\"J*(x)\")\nvline!([-1/3],line=:dash)\nxlabel!(\"x\")\nylabel!(\"J*(x)\")",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Explicit MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mld_why.html",
    "href": "mld_why.html",
    "title": "Why another framework?",
    "section": "",
    "text": "We are going to introduce yet another framework for modeling hybrid systems – mixed logical dynamical (MLD) description. A question must inevitably pop up: “why yet another framework?”\nThe answer is, that we would like to have a model of a hybrid system that is suitable for model predictive control (MPC). Recall that the role of the model in MPC is that the model is used to define some constraints (equations and inequalities) in the numerical optimization problem. The frameworks that we considered so far did not offer it.\nIn particular, with the state variable and control input vectors composed of continuous and discrete variables \n\\bm x = \\begin{bmatrix}\\bm x_c\\\\\\bm x_d\\end{bmatrix}, \\quad \\bm u = \\begin{bmatrix}\\bm u_c\\\\\\bm u_d\\end{bmatrix},\n where \\bm x_c\\in\\mathbb R^{n_c},\\;\\bm x_d\\in\\mathbb N^{n_d},\\; \\bm u_c\\in\\mathbb R^{m_c} and \\bm u_d\\in\\mathbb N^{m_d}, we would like to formulate the model in the form of state equations, say \n\\begin{aligned}\n\\begin{bmatrix}\\bm x_c(k+1) \\\\ \\bm x_d(k+1)\\end{bmatrix}\n&=\n\\begin{bmatrix} \\mathbf f_c(\\bm x(k), \\bm u(k)) \\\\ \\mathbf f_d(\\bm x(k), \\bm u(k)) \\end{bmatrix}\n\\end{aligned}\n\nIs it possible?\nUnfortunately no. At least not exactly in this form. But something close to it is achievable instead.\nBut first we need to set the terminology and notation used to define a discrete(-time) hybrid automaton.\n\n\n\n Back to top",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Why another framework?"
    ]
  },
  {
    "objectID": "classes_references.html",
    "href": "classes_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Literature"
    ]
  },
  {
    "objectID": "stability_concepts.html",
    "href": "stability_concepts.html",
    "title": "Stability of hybrid systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Stability of hybrid systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html",
    "href": "max_plus_systems.html",
    "title": "Max-plus linear (MPL) systems",
    "section": "",
    "text": "We start with an example of a discrete-event systems modelled using (max,+) algebra.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#model-of-an-event-graph-as-a-max-plus-linear-mpl-state-space-system",
    "href": "max_plus_systems.html#model-of-an-event-graph-as-a-max-plus-linear-mpl-state-space-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Model of an event graph as a Max-plus linear (MPL) state-space system",
    "text": "Model of an event graph as a Max-plus linear (MPL) state-space system\nGeneralizing what we have seen in the previous example, we can write the MPL state-space system (actually a model) as \\[\\boxed{\n  \\begin{aligned}\n  x(k) &= A\\otimes x(k-1) \\oplus B\\otimes u(k),\\\\\n  y(k) &= C\\otimes x(k),\n  \\end{aligned}}\n\\tag{1}\\]\nwhere \\(A\\), \\(B\\), and \\(C\\) are matrices of appropriate dimensions. or, equivalently (after relabelling) \\[\n  \\begin{aligned}\n  x(k+1) &= A\\otimes x(k) \\oplus B\\otimes u(k),\\\\\n  y(k) &= C\\otimes x(k),\n  \\end{aligned}\n\\]\nwhich mimics the conventional state-space system \\[\n  \\begin{aligned}\n  x(k+1) &= A x(k) + Bu(k),\\\\\n  y(k) &= Cx(k).\n  \\end{aligned}\n\\]\nWe already know this from the example, but we need to emphasize it here again: the role of the variables \\(u(k), x(k), y(k)\\) is that they are event times. Namely the times of\n\narrivals of inputs,\nbeginning of processing\nfinishing of processing,\n\nrespectively.\nThe independent variable \\(k\\) is now a counter of the events.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#state-response-of-an-mpl-system",
    "href": "max_plus_systems.html#state-response-of-an-mpl-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "State response of an MPL system",
    "text": "State response of an MPL system\nIn order to simulate an MPL system, we can now find use of the definitions of the basic operations in (max,+) algebra that we studied previously. Note that \\[\n\\begin{aligned}\nx_1 &= A\\otimes x_0 \\oplus B\\otimes u_1\\\\\nx_2 &= A\\otimes x_1 \\oplus B\\otimes u_2\\\\\n    &= A\\otimes (A\\otimes x_0 \\oplus B\\otimes u_1) \\oplus B\\otimes u_2\\\\\n    &= A^{\\otimes^2}\\otimes x_0 \\oplus A\\otimes B\\otimes u_1 \\oplus B\\otimes u_2\\\\\n    &\\vdots    \n\\end{aligned}\n\\] which can be generalized to \\[\\boxed{\nx_k = A^{\\otimes^k}\\otimes x_0 \\oplus \\bigoplus_{i=1}^k A^{\\otimes^{k-i}} \\otimes B\\otimes u_i.}\n\\tag{2}\\]\n\n\n\n\n\n\nResponse of an LTI state-space system\n\n\n\nThe response of a linear time-invariant (LTI) system described by a (vector) state equation \\(x(k+1) = Ax(k) + Bu(k)\\) is \\[\nx_{k} = A^k x_0 + \\sum_{i=0}^{k-1} A^{k-1-i}Bu_i.\n\\]\n\n\n\n\n\n\n\n\nLower and upper bounds for the summation shifted by 1\n\n\n\nNote how the lower and upper bounds for the summation are shifted by 1 compared to the traditional convolution.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#max-linearity",
    "href": "max_plus_systems.html#max-linearity",
    "title": "Max-plus linear (MPL) systems",
    "section": "(max,+) linearity",
    "text": "(max,+) linearity\nWe should emphasize that the linearity exhibited by the state equation Equation 1 and the convolution Equation 2 must only be understood in the (max,+) sense.\nIndeed, if we consider two input sequences \\(u_1= \\{u_{1,1},u_{1,2},\\ldots\\}\\) and \\(u_2= \\{u_{2,1},u_{2,2},\\ldots\\}\\), a (max,+)-linear combination \\(\\alpha \\otimes u_1 \\oplus \\beta \\otimes u_2\\) of the two inputs yields the same (max,+)-linear combination of the outputs \\(y_1\\) and \\(y_2\\).",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#input-output-response-of-an-mpl-system",
    "href": "max_plus_systems.html#input-output-response-of-an-mpl-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Input-output response of an MPL system",
    "text": "Input-output response of an MPL system\nWe can also eliminate the state variables from the model and aim at finding the relation between the input and output sequences \\[\nU = \\begin{bmatrix}u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_p\\end{bmatrix}, \\qquad Y = \\begin{bmatrix}y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_p\\end{bmatrix}\n\\] in the form of \\[\\boxed\n{Y = G\\otimes x_0 \\oplus H\\otimes U,}\n\\] where \\[\nH =\n\\begin{bmatrix}\nC\\otimes B & \\varepsilon & \\varepsilon & \\ldots & \\varepsilon\\\\\nC\\otimes A\\otimes B & C\\otimes B & \\varepsilon & \\ldots & \\varepsilon\\\\\nC\\otimes A^{\\otimes^2}\\otimes B & C\\otimes A\\otimes B & C\\otimes B & \\ldots & \\varepsilon\\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\nC\\otimes A^{\\otimes^{p-1}}\\otimes B & C\\otimes A^{\\otimes^{p-2}}\\otimes B & C\\otimes A^{\\otimes^{p-3}}\\otimes B & \\ldots & C\\otimes B\n\\end{bmatrix}\n\\] and \\[\nG =\n\\begin{bmatrix}\nC \\\\ C\\otimes A \\\\ C\\otimes A^{\\otimes^2} \\\\ \\vdots \\\\ C\\otimes A^{\\otimes^{p-1}}\n\\end{bmatrix}.\n\\]\n\nExample 2 (Production system) We consider again the production system in Example 1. On the time horizon of 4, and assuming zero initial state, the input-output model is paramaterized by \\[\nY = \\begin{bmatrix}y_1 & y_2 & y_3 & y_4\\end{bmatrix}^\\top, \\quad U = \\begin{bmatrix}u_1 & u_2 & u_3 & u_4\\end{bmatrix}^\\top,\n\\]\n\\[\nx_0 = \\begin{bmatrix}\\varepsilon & \\varepsilon & \\varepsilon\\end{bmatrix}^\\top,\n\\]\n\\[\nH =\n\\begin{bmatrix}\n21 & \\varepsilon & \\varepsilon & \\varepsilon\\\\\n32 & 21 & \\varepsilon & \\varepsilon\\\\\n43 & 32 & 21 & \\varepsilon\\\\\n55 & 43 & 32 & 21\n\\end{bmatrix}.\n\\]",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#analysis-of-an-irreducible-mpl-system",
    "href": "max_plus_systems.html#analysis-of-an-irreducible-mpl-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Analysis of an irreducible MPL system",
    "text": "Analysis of an irreducible MPL system\nWe now consider an autonomous MPL system \\[\nx_{k+c} = A^{\\otimes^{k+c}}\\otimes x_0,\n\\] for which we assume irreducibility of the matrix \\(A\\).\nWe have learnt previously, that for large enough \\(k\\) and \\(c\\), \\[\nx_{k+c} = \\lambda^{\\otimes^c}\\otimes A^{\\otimes^{k}}\\otimes x_0 = \\lambda^{\\otimes^c}\\otimes x_k.\n\\]\nThis can be interpreted in the standard algabra as \\[\nx_{k+c} = c\\lambda + x_k,\n\\] from which it follows that \\[\nx_{k+c}-x_k = c\\lambda.\n\\]\nThis is an insightful result. When the system under consideration is a production system, then once it reaches a cyclic behaviour, the average cycle is \\(\\lambda\\). The average production rate is then \\(1/\\lambda\\).",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#model-predictive-control-mpc-for-mpl-systems",
    "href": "max_plus_systems.html#model-predictive-control-mpc-for-mpl-systems",
    "title": "Max-plus linear (MPL) systems",
    "section": "Model Predictive Control (MPC) for MPL systems",
    "text": "Model Predictive Control (MPC) for MPL systems\nNow we are finally ready to consider control problems form MPL systems. We will consider the MPC approach.\n\nCosf function for MPC\nWe consider the const function composed of two parts \\[\nJ = J_\\mathrm{output} + \\lambda J_\\mathrm{input}.\n\\]\nAt “time” \\(k\\), with the prediction horizon \\(N_\\mathrm{p}\\), and with the number of outputs \\(n_\\mathrm{y}\\): \\[\nJ_\\mathrm{output} = \\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\max \\{y_{i,k+j} - r_{i,k+j},0\\}\n\\]\nThis cost function penalizes tardiness (late delivery).\n\n\n\n\n\n\nCaution\n\n\n\nIs the lower value for j correct?\n\n\nAlternative choice of the cost function is \\[\nJ_\\mathrm{output} = \\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\left|y_{i,k+j} - r_{i,k+j} \\right |,\n\\] which penalizes difference between the due and actual dates, or \\[\nJ_\\mathrm{output} = \\sum_{j=1}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\left |\\Delta^2 y_{i,k+j}\\right |,\n\\] which balances the output rates.\nThe input cost can be set to \\[\nJ_\\mathrm{input} = -\\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{l=1}^{n_\\mathrm{u}} u_{l,k+j},\n\\] which penalizes early feeding (favours just-in-time feeding). Note the minus sign.\n\n\nControl horizon vs. prediction horizon\nAssume constant feeding rate after the control horizon \\(N_\\mathrm{c}\\) \\[\n\\Delta u_{k+j} = \\Delta u_{k+N_\\mathrm{c}-1},\\qquad j=N_\\mathrm{c},\\ldots, N_\\mathrm{p}-1\n\\] where \\(\\Delta u_k = u_k - u_{k-1}\\).\nAlternatively, \\[\n\\Delta^2 u_{k+j} = 0,\\qquad j=N_\\mathrm{c},\\ldots, N_\\mathrm{p}-1\n\\] where \\(\\Delta^2 u_k = \\Delta u_k - \\Delta u_{k-1} = u_k - 2u_{k-1} + u_{k-2}\\).\n\n\nInequality constraints for MPC\nThere are several possibilities for the constraints in the MPC for MPL systems. For example, we can constrain the minimum and maximum separation of input and output events \\[\na_{k+j} \\leq \\Delta u_{k+j} \\leq b_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{c}-1,\n\\] \\[\nc_{k+j} \\leq \\Delta y_{k+j} \\leq d_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{p}-1.\n\\]\nWe can also impose constraint on the maximum due dates for the output events \\[\ny_{k+j} \\leq r_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{p}-1.\n\\]\nWe can also enforce the condition that the input and output events are consecutive \\[\n\\Delta u_{k+j} \\geq 0, \\qquad j=0,1,\\ldots,N_\\mathrm{c}-1.\n\\]\n\n\nMPC for MPL system leads to a nonlinear optimization problem\nOur motivation for formulating the problems within the (max,+) algebra was to fake the reality a bit and pretend that the problem is linear. This allowed us to invoke many concepts that we are familiar with from linear systems theory. However, at the end of the day, when it comes to actually solving the problem, we must reveal the nonlinear nature of the problem.\nWhen we consider the MPC for MPL systems, we are faced with a nonlinear optimization problem. We can use some general nonlinear solvers (fmincon, ipopt, …).\nAlternatively, there is a dedicated framework for solving these problem. It is called Extended Linear Complementarity Problem (ELCP) and was developed by [1]. We will introduce the complementarity problem(s) later in a chapter dedicated to complementarity.\nYet another approach is through Mixed Integer (Linear) Programming (MILP).",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "intro_references.html",
    "href": "intro_references.html",
    "title": "Literature",
    "section": "",
    "text": "The discipline of hybrid system is huge and spans several areas of science and engineering. As a result, finding a single comprehensive reference is difficult if not impossible. The more so that our selection of topics is inevitably biased. Admittedly, our selections of both topics and references will mostly be biased towards control engineering, and yet even within that discipline we have our own preferences. Therefore, we will always provide a list of references when studying particular topics.",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "intro_references.html#introductoryoverview-texts-freely-available-online",
    "href": "intro_references.html#introductoryoverview-texts-freely-available-online",
    "title": "Literature",
    "section": "Introductory/overview texts freely available online",
    "text": "Introductory/overview texts freely available online\nAmong the texts that provide motivation for studying hybrid systems as well as some introduction into theoretical and computational frameworks, we recommend Heemels et al. (2009), which is also available on the author’s webpage. Yet another overview, which is also available online, is Johansson (2004). And yet another is De Schutter et al. (2009), which is available on the author’s web page. The quartet of recommended online resources is concluded by Lygeros (2004).",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "intro_references.html#books-not-freely-available-online-at-least-not-that-we-know-of",
    "href": "intro_references.html#books-not-freely-available-online-at-least-not-that-we-know-of",
    "title": "Literature",
    "section": "Books not freely available online (at least not that we know of)",
    "text": "Books not freely available online (at least not that we know of)\nAmong the high-quality printed books, for which we are not aware of legally available online versions, the slim book van der Schaft and Schumacher (2000) can be regarded as the classic.\n\nThe handbook Lunze and Lamnabhi-Lagarrigue (2009) contains a wealth of contributions from several authors (in fact two of the online resources linked above are chapters from this book).\n\nThe latest textbook on the topic of hybrid systems is Lin and Antsaklis (2022). The book was probably the prime candidate for the book for this course, however we wanted a slightly different emphasis on each topic.\n\nAnother relatively recent book is Sanfelice (2021). Although it is very well written and is certainly recommendable, it follows a particular framework that is not the most common one in the literature on hybrid systems – the framework of hybrid equations. But we are certainly going to introduce their approach in our course. The more so that it is supported by a freely available Matlab toolbox.\n\nThe book Goebel, Sanfelice, and Teel (2012) can be regarded as a predecessor and/or complement of the just mentioned Sanfelice (2021). Although the book is not available online, a short version appears as an article Goebel, Sanfelice, and Teel (2009) in the popular IEEE Control Systems magazine (the one with color figures :-).\n\nLast but not least, MPC methodology is specialized to hybrid systems in Borrelli, Bemporad, and Morari (2017). The book is freely available on the authors’ webpage.\n\nThis list of books on hybrid systems is by no means exhaustive. We will provide more references in the respective chapters.",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "complementarity_systems.html",
    "href": "complementarity_systems.html",
    "title": "Complementarity systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity systems"
    ]
  },
  {
    "objectID": "classes_reset.html",
    "href": "classes_reset.html",
    "title": "Reset systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Reset systems"
    ]
  },
  {
    "objectID": "hybrid_equations_software.html",
    "href": "hybrid_equations_software.html",
    "title": "Software",
    "section": "",
    "text": "There is a well-developed and actively maintained Matlab toolbox\n\nSanfelice, Ricardo, and Pablo Nanez. ‘Hybrid Equations (HyEQ) Toolbox for Matlab’. Version 3.0, 15 October 2022. https://github.com/pnanez/HyEQ_Toolbox. Documentation at https://hyeq.github.io.\n\nThe toolbox can also be installed directly from Matlab through their Add-Ons Explorer. As the stable version is already two years old and they also offer a beta version 3.1.0.04, which was last updated on April 28, 2024, the beta version seems the way to go for our purposes. The authors will certainly appreciate any feedback.\nOther programming languages seem to be missing a similar toolbox/package. How about developing one in Julia?\n\n\n\n Back to top",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Software"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "What is a hybrid system?",
    "section": "",
    "text": "The adjective “hybrid” is used in a common language to express that the subject under consideration has a bit of this and a bit of that… When talking about hybridness of systems, we modify this vague “definition” into a more descriptive one: a hybrid system has a bit of this and an atom of that… By this bon mot we mean that hybrid systems contain some physical subsystems and components combined with if-then-else and/or timing rules that are mostly (but not always) implemented in software. This definition is certainly not the most precise one, but it is a good starting point.\nEven better a definition is that hybrid systems are composed of subsystems whose evolution is driven by time (discrete or continuous) and some other subsystems that evolve as dictated by (discrete) events. The former are modelled by ordinary differential equations (ODE) or differential-algebraic equations (DAE) in continuous time cases and by difference equations in the discrete time cases. The are latter are modelled by state automata or Petri nets, and they implement some propositonal (aka sentential or statement), predicate and/or temporal logics. Let’s stick to this definition of hybrid systems. As we will progress with modelling frameworks, the definition will become a bit more operational.\n\n\n\n\n\n\nHybrid systems vs sampled-data systems\n\n\n\nIt may be a bit confusing that we are introducing a new framework for the situation that we can already handle – a physical plant evolving in continuous time (and modelled by an ODE) controlled in discrete-time by a digital controller/computer. Indeed, this situation does qualify as a hybrid system. In introductory course we have learnt to design such controllers (by discretizing the system and then designing a controller for a discrete-time model, relying on ) and there was no need to introduce whatever new framework. However, this standard scenario assumes that the sampling period is constant. Only then can the standard techniques based on z-transform be applied. As soon as the sampling period is not constant, we need some more general framework – the framework of hybrid systems.\n\n\n\n\n\n\n\n\nHybrid systems vs cyberphysical systems\n\n\n\nRecently systems containing both the computer/software/algorithmic parts and physical parts are also studied under the fancy name cyberphysical systems. The two concepts can hardly be distinguished, to be honest. I also confess I am unhappy with the narrowing of the concept of cybernetics to just computers. Cybernetics, as introduced by Norbert Wiener, already encompasses physical and biological systems among others. Anyway, that is how it is and the take-away leeson is that these days a great deal of material relevant for our course on hybrid systems can also be found in resources adopting the name cyberphysical systems.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#definition-of-a-hybrid-system",
    "href": "intro.html#definition-of-a-hybrid-system",
    "title": "What is a hybrid system?",
    "section": "",
    "text": "The adjective “hybrid” is used in a common language to express that the subject under consideration has a bit of this and a bit of that… When talking about hybridness of systems, we modify this vague “definition” into a more descriptive one: a hybrid system has a bit of this and an atom of that… By this bon mot we mean that hybrid systems contain some physical subsystems and components combined with if-then-else and/or timing rules that are mostly (but not always) implemented in software. This definition is certainly not the most precise one, but it is a good starting point.\nEven better a definition is that hybrid systems are composed of subsystems whose evolution is driven by time (discrete or continuous) and some other subsystems that evolve as dictated by (discrete) events. The former are modelled by ordinary differential equations (ODE) or differential-algebraic equations (DAE) in continuous time cases and by difference equations in the discrete time cases. The are latter are modelled by state automata or Petri nets, and they implement some propositonal (aka sentential or statement), predicate and/or temporal logics. Let’s stick to this definition of hybrid systems. As we will progress with modelling frameworks, the definition will become a bit more operational.\n\n\n\n\n\n\nHybrid systems vs sampled-data systems\n\n\n\nIt may be a bit confusing that we are introducing a new framework for the situation that we can already handle – a physical plant evolving in continuous time (and modelled by an ODE) controlled in discrete-time by a digital controller/computer. Indeed, this situation does qualify as a hybrid system. In introductory course we have learnt to design such controllers (by discretizing the system and then designing a controller for a discrete-time model, relying on ) and there was no need to introduce whatever new framework. However, this standard scenario assumes that the sampling period is constant. Only then can the standard techniques based on z-transform be applied. As soon as the sampling period is not constant, we need some more general framework – the framework of hybrid systems.\n\n\n\n\n\n\n\n\nHybrid systems vs cyberphysical systems\n\n\n\nRecently systems containing both the computer/software/algorithmic parts and physical parts are also studied under the fancy name cyberphysical systems. The two concepts can hardly be distinguished, to be honest. I also confess I am unhappy with the narrowing of the concept of cybernetics to just computers. Cybernetics, as introduced by Norbert Wiener, already encompasses physical and biological systems among others. Anyway, that is how it is and the take-away leeson is that these days a great deal of material relevant for our course on hybrid systems can also be found in resources adopting the name cyberphysical systems.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#example-of-a-hybrid-system",
    "href": "intro.html#example-of-a-hybrid-system",
    "title": "What is a hybrid system?",
    "section": "Example of a hybrid system",
    "text": "Example of a hybrid system",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#hybrid-system-is-an-open-and-unbounded-concept",
    "href": "intro.html#hybrid-system-is-an-open-and-unbounded-concept",
    "title": "What is a hybrid system?",
    "section": "Hybrid system is an open and unbounded concept",
    "text": "Hybrid system is an open and unbounded concept\nPartly because hybrid systems are investigated by many\n\nComputer science\nModeling & simulation\nControl systems\n\n\nHybrid systems in computer science\n\nThey start with discrete-event systems, typically modelled by finite state automata and/or timed automata, and add some (typically simple) continuous-time dynamics.\nMainly motivated by analysis (verification, model checking, …): safety, liveness, fairness, …\n\n\n\nHybrid systems in modeling and simulation\n\nEven when modeling purely physical systems, it can be beneficial to approximate some fast dynamics with discontinuous transitions – jumps (diodes and other semiconductor switches, computer networks, mechanical impacts, …).\nStrictly speaking, we should speak about hybrid models, because modeling a given system as hybrid is already a modeller’s decision. But the terminology is already settled…\n\n\n\nHybrid systems in control systems\n\nTypically focused on continuous-time dynamical systems to be controlled but introducing some logic through a controller (switching control, relay control, PLC, …)\nBesides synthesis (aka control design), properties such as stability, controllability, robustness.\nThere is yet another motivation for explicitly dealing with hybridness in control systems: some systems can only be stabilized by switching and switching can be formulated within the hybrid system framework.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "solution_concepts.html",
    "href": "solution_concepts.html",
    "title": "Solution concepts",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "7. Solution",
      "Solution concepts"
    ]
  },
  {
    "objectID": "hybrid_automata_references.html",
    "href": "hybrid_automata_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Literature"
    ]
  },
  {
    "objectID": "des_references.html",
    "href": "des_references.html",
    "title": "Literature",
    "section": "",
    "text": "Literature for discrete-event systems is vast, but within the control systems community the classical (and award-winning) reference is Cassandras and Lafortune (2021). Note that an electronic version of the previous edition (perfectly acceptable for us) is accessible through the NTK library (possibly upon CTU login). This book is rather thick too and covering its content can easily need a full semestr. However, in our course we will only need the very basics of the theory of (finite state) automata and such basics are presented in Chapters 1 and 2. The extension to timed automata is then presented in Chapter 5.2.\n\nThe basics are also presented in the tutorial paper by the same author(s) Lafortune (2019).\nA very short (but sufficient for us) intro to discrete-event systems that adheres to Cassandras’s style is given in the first chapter of the recent hybrid systems textbook Lin and Antsaklis (2022).\nAlternatively, there are some other recent textbooks that contain decent introductions to the theory of (finite state) automata. These are often surfing on the wave of popularity of the recently fashionable buzzword of cyberphysical or embedded systems, but in essence these deal with the same hybrid systems as we do in our course. The fact is, however, that the modeling formalism can be a bit different from the one in Cassandras (certainly when it comes to notation but also some concepts). One such textbook is Alur (2015), for which an electronic version accessible through the NTK library (upon CTU login). Another one is Mitra (2007). In particular, Chapter 2 serves as an intro to the automata theory. Last but not least, Lee and Seshia (2017), for which an electronic version is freely downloadable.\n\n\n\n\n Back to topReferences\n\nAlur, Rajeev. 2015. Principles of Cyber-Physical Systems. Cambridge, MA, USA: MIT Press. https://mitpress.mit.edu/9780262029117/principles-of-cyber-physical-systems/.\n\n\nCassandras, Christos G., and Stéphane Lafortune. 2021. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer. https://doi.org/10.1007/978-3-030-72274-6.\n\n\nLafortune, Stéphane. 2019. “Discrete Event Systems: Modeling, Observation, and Control.” Annual Review of Control, Robotics, and Autonomous Systems 2 (1): 141–59. https://doi.org/10.1146/annurev-control-053018-023659.\n\n\nLee, Edward Ashford, and Sanjit Arunkumar Seshia. 2017. Introduction to Embedded Systems: A Cyber-Physical Systems Approach. 2nd ed. Cambridge, MA, USA: MIT Press. https://ptolemy.berkeley.edu/books/leeseshia//.\n\n\nLin, Hai, and Panos J. Antsaklis. 2022. Hybrid Dynamical Systems: Fundamentals and Methods. Advanced Textbooks in Control and Signal Processing. Cham: Springer. https://doi.org/10.1007/978-3-030-78731-8.\n\n\nMitra, Sayan. 2007. “A Verification Framework for Hybrid Systems.” PhD thesis, Massachusetts Institute of Technology. https://dspace.mit.edu/handle/1721.1/42238.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Literature"
    ]
  },
  {
    "objectID": "hybrid_equations.html",
    "href": "hybrid_equations.html",
    "title": "Hybrid equations",
    "section": "",
    "text": "Here we introduce a major alternative framework to hybrid automata for modelling hybrid systems. It is called hybrid equations, sometimes also hybrid state equations to emphasize that what we are after is some kind of analogy with state equations \\dot{x}(t) = f(x(t), u(t)) and x_{k+1} = g(x_k, u_k) that we are familiar with from (continuous-valued) dynamical systems.\nSometimes it also called event-flow equations or jump-flow equations.\nThese are the key ideas:\nThe major advantage of this modeling framework is that we do not have to distinguish. This is in contrast with hybrid automata, where we have to start by classifying the state variables as either continuous or discrete before moving on. kIn the current framework we treat all the variables identically – they mostly flow and occasionally (perhaps never, which is OK) jump.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#hybrid-state-equations",
    "href": "hybrid_equations.html#hybrid-state-equations",
    "title": "Hybrid equations",
    "section": "Hybrid (state) equations",
    "text": "Hybrid (state) equations\nIt is high time to introduce hybrid (state) equations. Here they come \n\\begin{aligned}\n\\dot{x} &= f(x), \\quad x \\in \\mathcal{C},\\\\\nx^+ &= g(x), \\quad x \\in \\mathcal{D}.\n\\end{aligned}\n where\n\nf is the flow map,\n\\mathcal{C} is the flow set,\ng is the jump map,\n\\mathcal{D} is the jump set.\n\nThis model of a hybrid system is thus parameterized by the quadruple \\{f, \\mathcal C, g, \\mathcal D\\}.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#hybrid-state-inclusions",
    "href": "hybrid_equations.html#hybrid-state-inclusions",
    "title": "Hybrid equations",
    "section": "Hybrid (state) inclusions",
    "text": "Hybrid (state) inclusions\nWe now extend the presented framework of hybrid equations a bit. Namely, the functions on the right hand sides in both the differential and the difference equations are no longer assigning just a single value (as well-behaved functions do), but they assign sets! \n\\begin{aligned}\n\\dot{x} &\\in \\mathcal F(x), \\quad x \\in \\mathcal{C},\\\\\nx^+ &\\in \\mathcal G(x), \\quad x \\in \\mathcal{D}.\n\\end{aligned}\n where\n\n\\mathcal{F} is the set-valued flow map,\n\\mathcal{C} is the flow set,\n\\mathcal{G} is the set-valued jump map,\n\\mathcal{D} is the jump set.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#output-equations",
    "href": "hybrid_equations.html#output-equations",
    "title": "Hybrid equations",
    "section": "Output equations",
    "text": "Output equations\nTypically a full model is only formed upon defining some output variables (oftentimes just a subset of possibly scaled state variables or their linear combinations). These output variables then obey some output equation \ny(x) = h(x),\n\nor \ny(x) = h(x,u).\n\n\nExample 1 (Bouncing ball) This is the “hello world example” for hybrid systems with state jumps (pun intended). The state variables are the height and the vertical speed of the ball. \n\\bm x \\in \\mathbb{R}^2, \\qquad \\bm x = \\begin{bmatrix}x_1 \\\\ x_2\\end{bmatrix}.\n\nThe quadruple defining the hybrid equations is \n\\mathcal{C} = \\{\\bm x \\in \\mathbb{R}^2 \\mid x_1&gt;0 \\lor (x_1 = 0, x_2\\geq 0)\\},\n \nf(\\bm x) = \\begin{bmatrix}x_2 \\\\ -g\\end{bmatrix}, \\qquad g = 9.81,\n \n\\mathcal{D} = \\{\\bm x \\in \\mathbb{R}^2 \\mid x_1 = 0, x_2 &lt; 0\\},\n \ng(\\bm x) = \\begin{bmatrix}x_1 \\\\ -\\alpha x_2\\end{bmatrix}, \\qquad \\alpha = 0.8.\n\nThe two sets and two maps are illustrated below.\n\n\n\nMaps and sets for the bouncing ball example\n\n\n\n\nExample 2 (Bouncing ball on a controlled piston) We now extend the simple bouncing ball example by adding a vertically moving piston. The piston is controlled by a force.\n\n\n\nExample of a ball bouncing on a vertically moving piston\n\n\nIn our analysis we neglect the sizes (for simplicity).\nThe collision happens when x_\\mathrm{b} = x_\\mathrm{p}, and v_\\mathrm{b} &lt; v_\\mathrm{p}.\nThe conservation of momentum after a collision reads \nm_\\mathrm{b}v_\\mathrm{b}^+ + m_\\mathrm{p}v_\\mathrm{p}^+ = m_\\mathrm{b}v_\\mathrm{b} + m_\\mathrm{p}v_\\mathrm{p}.\n\\tag{1}\nThe collision is modelled using a restitution coefficient \nv_\\mathrm{p}^+ - v_\\mathrm{b}^+ = -\\gamma (v_\\mathrm{p} - v_\\mathrm{b}).\n\\tag{2}\nFrom the momentum conservation Equation 1 \nv_\\mathrm{p}^+ = \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b} + v_\\mathrm{p} - \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b}^+\n\nwe substitute to Equation 2 to get \n\\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b} + v_\\mathrm{p} - \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b}^+ - v_\\mathrm{b}^+ = -\\gamma (v_\\mathrm{p} - v_\\mathrm{b}),\n from which we express v_\\mathbb{b}^+ \n\\begin{aligned}\nv_\\mathrm{b}^+ &= \\frac{1}{1+\\frac{m_\\mathrm{b}}{m_\\mathrm{p}}}\\left(\\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b} + v_\\mathrm{p} + \\gamma (v_\\mathrm{p} - v_\\mathrm{b})\\right)\\\\\n&= \\frac{m_\\mathrm{p}}{m_\\mathrm{p}+m_\\mathrm{b}}\\left(\\frac{m_\\mathrm{b}-\\gamma m_\\mathrm{p}}{m_\\mathrm{p}}v_\\mathrm{b} + (1+\\gamma)v_\\mathrm{p}\\right)\\\\\n&= \\frac{m_\\mathrm{b}-\\gamma m_\\mathrm{p}}{m_\\mathrm{b}+m_\\mathrm{p}}v_\\mathrm{b} + \\frac{(1+\\gamma)m_\\mathrm{p}}{m_\\mathrm{p}+m_\\mathrm{b}}v_\\mathrm{p}\n\\end{aligned}.\n\nSubstitute to the expression for v_\\mathbb{p}^+ to get \n\\begin{aligned}\nv_\\mathrm{p}^+ &= \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}v_\\mathrm{b} + v_\\mathrm{p} - \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}\\left(\\frac{m_\\mathrm{b}-\\gamma m_\\mathrm{p}}{m_\\mathrm{b}+m_\\mathrm{p}}v_\\mathrm{b} + \\frac{(1+\\gamma)m_\\mathrm{p}}{m_\\mathrm{p}+m_\\mathrm{b}}v_\\mathrm{p}\\right)\\\\\n&= \\frac{m_\\mathrm{b}}{m_\\mathrm{p}}\\left(1-\\frac{m_\\mathrm{b}-\\gamma m_\\mathrm{p}}{m_\\mathrm{b}+m_\\mathrm{p}}\\right) v_\\mathrm{b} \\\\\n&\\qquad\\qquad + \\left(1-\\frac{m_\\mathrm{b}}{m_\\mathrm{p}}\\frac{(1+\\gamma)m_\\mathrm{p}}{m_\\mathrm{p}+m_\\mathrm{b}}\\right) v_\\mathrm{p}\\\\\n&= \\frac{m_\\mathrm{b}}{m_\\mathrm{b}+m_\\mathrm{p}}(1+\\gamma) v_\\mathrm{b} + \\frac{m_\\mathrm{p}-\\gamma m_\\mathrm{b}}{m_\\mathrm{p}+m_\\mathrm{b}} v_\\mathrm{p}.\n\\end{aligned}\n\nFinally we can simplify the expressions a bit by introducing m=\\frac{m_\\mathrm{b}}{m_\\mathrm{b}+m_\\mathrm{p}}. The jump equation is then \n\\begin{bmatrix}\nv_\\mathrm{b}^+\\\\\nv_\\mathrm{p}^+\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm - \\gamma (1-m) & (1+\\gamma)(1-m)\\\\\nm(1+\\gamma) & 1-m-\\gamma m\n\\end{bmatrix}\n\\begin{bmatrix}\nv_\\mathrm{b}\\\\\nv_\\mathrm{p}\n\\end{bmatrix}.\n\n\n\nExample 3 (Synchronization of fireflies) This is a famous example in synchronization. We consider n fireflies, x_i is the i-th firefly’s clock, normalized to [0,1]. The clock resets (to zero) when it reaches 1. Each firefly can see the flashing of all other fireflies. As soon as it observes a flash, it increases its clock by \\varepsilon \\%.\nHere is how we model the problem using the four-tuple \\{f, \\mathcal C, g, \\mathcal D\\}: \n\\mathcal{C} = [0,1)^n = \\{\\bm x \\in \\mathbb R^n\\mid x_i \\in [0,1),\\; i=1,\\ldots,n \\},\n \n\\bm f = [f_1, f_2, \\ldots, f_n]^\\top,\\quad f_i = 1, \\quad i=1,\\ldots,n,\n \n\\mathcal{D} = \\{\\bm x \\in [0,1]^n \\mid \\max_i x_i = 1 \\},\n\n\n\\begin{aligned}\n\\bm g &= [g_1, \\ldots, g_n]^\\top,\\\\\n& \\qquad g_i(x_i) =\n\\begin{cases}\n(1 + \\varepsilon)x_i, & \\text{if } (1+\\varepsilon)x_i &lt; 1, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n\\end{aligned}\n\n\n\nExample 4 (Thyristor control) Consider the circuit below.\n\n\n\nExample of a thyristor control\n\n\nWe consider a harmonic input voltage, that is, \n\\begin{aligned}\n\\dot v_0 &= \\omega v_1\\\\\n\\dot v_1 &= -\\omega v_0.\n\\end{aligned}\n\nThe thyristor can be on (discrete state q=1) or off (q=0). The firing time \\tau is given by the firing angle \\alpha \\in (0,\\pi).\nThe state vector is \n\\bm x =\n\\begin{bmatrix}\nv_0\\\\ v_1 \\\\ i_\\mathrm{L} \\\\ v_\\mathrm{C} \\\\ q \\\\ \\tau\n\\end{bmatrix}.\n\nThe flow map is \n\\bm f(\\bm x)\n=\n\\begin{bmatrix}\n\\omega v_1\\\\\n-\\omega v_0\\\\\nq \\frac{v_\\mathrm{C}-Ri_\\mathrm{L}}{L}\\\\\n-\\frac{1}{CR}v_\\mathrm{C} + \\frac{1}{CR}v_\\mathrm{0} - \\frac{1}{C}i_\\mathrm{L}\\\\\n0\\\\\n1\n\\end{bmatrix}.\n\nThe flow set is \n\\begin{aligned}\n\\mathcal{C} &= \\{\\bm x \\mid q=0,\\, \\tau&lt;\\frac{\\alpha}{\\omega},\\, i_\\mathrm{L}=0\\}\\\\ &\\qquad \\cup \\{\\bm x \\mid q=1,\\, i_\\mathrm{L}&gt;0\\}\n\\end{aligned}.\n\nThe jump set is \n\\begin{aligned}\n\\mathcal{D} &= \\{\\bm x \\mid q=0,\\, \\tau\\geq \\frac{\\alpha}{\\omega},\\, i_\\mathrm{L}=0,\\, v_\\mathrm{C}&gt;0\\}\\\\ &\\qquad \\cup \\{\\bm x \\mid q=1,\\, i_\\mathrm{L}=0,\\, v_\\mathrm{C}&lt;0\\}\n\\end{aligned}.\n\nThe jump map is \n\\bm g(\\bm x) =\n\\begin{bmatrix}\nu_0\\\\ u_1 \\\\ i_\\mathrm{L} \\\\ v_\\mathrm{C} \\\\ {\\color{red} 1-q} \\\\ {\\color{red} 0}\n\\end{bmatrix}.\n\nThe last condition in the jump set comes from the requirement that not only must the current through the inductor be zero, but also it must be decreasing. And from the state equation it follows that the voltage on the capacitor must be negative.\n\n\nExample 5 (Sampled-data feedback control) Another example of a dynamical system that fits nicely into the hybrid equations framework is sampled-data feedback control system. Within the feedback loop in Figure 1, we recognize a continuous-time plant and a discrete-time controller.\n\n\n\n\n\n\nFigure 1: Sampled data feedback control\n\n\n\nThe plant is modelled by \\dot x_\\mathrm{p} = f_\\mathrm{p}(x_\\mathrm{p},u), \\; y = h(x_\\mathrm{p}). The controller samples the output T-periodically and computes its own output as a nonlinear function u = \\kappa(r-y).\nThe closed-loop model is then \n\\dot x_\\mathrm{p} = f_\\mathrm{p}(x_\\mathrm{p},\\kappa(r-h(x_\\mathrm{p}))), \\; y = h(x_\\mathrm{p}).\n\nThe closed-loop state vector is \n\\bm x =\n\\begin{bmatrix}\nx_\\mathrm{p}\\\\ u \\\\ \\tau\n\\end{bmatrix}\n\\in\n\\mathbb R^n \\times \\mathbb R^m \\times \\mathbb R.\n\nThe flow set is \n\\begin{aligned}\n\\mathcal{C} &= \\{\\bm x \\mid \\tau \\in [0,T)\\}\n\\end{aligned}\n\nThe flow map is \n\\bm f(\\bm x)\n=\n\\begin{bmatrix}\nf_\\mathrm{p}(x_\\mathrm{p},u)\\\\\n0\\\\\n1\n\\end{bmatrix}\n\nThe jump set is \n\\begin{aligned}\n\\mathcal{D} &= \\{\\bm x \\mid \\tau = T\\}\n\\end{aligned}\n or rather \n\\begin{aligned}\n\\mathcal{D} &= \\{\\bm x \\mid \\tau \\geq T\\}\n\\end{aligned}\n\nThe jump map is \n\\bm g(\\bm x) =\n\\begin{bmatrix}\nx_\\mathrm{p}\\\\\n\\kappa(r-y)\\\\\n0\n\\end{bmatrix}\n\nYou may wonder why we bother with modelling this system as a hybrid system at all. When it comes to analysis of the closed-loop system, implementation of the model in Simulink allows for seemless mixing of continuous-time and dicrete-time blocks. And when it comes to control design, we can either discretize the plant and design a discrete-time controller, or design a continuous-time controller and then discretize it. No need for new theoris. True, but still, it is nice to have a rigorous framework for analysis of such systems. The more so that the sampling time T may not be constant – it can either vary randomly or perhaps the samling can be event-triggered. All these scenarios are easily handled within the hybrid equations framework.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#hybridness-after-closing-the-loop",
    "href": "hybrid_equations.html#hybridness-after-closing-the-loop",
    "title": "Hybrid equations",
    "section": "Hybridness after closing the loop",
    "text": "Hybridness after closing the loop\nWe have defined hybrid systems, but what exactly is hybrid when we close a feedback loop? There are three possibilities:\n\nHybrid plant + continuous controller.\nHybrid plant + hybrid controller.\nContinuous plant + hybrid controller.\n\nThe first case is encountered when we use a standard controller such as a PID controller to control a system whose dynamics can be characterized/modelled as hybrid. The second scenario considers a controller that mimicks the behavior of a hybrid system. The third case is perhaps the least intuitive: although the plant to be controller is continuous(-valued), it may still make sense to design and implement a hybrid controller, see the next paragraph.",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#impossibility-to-stabilize-without-a-hybrid-controller",
    "href": "hybrid_equations.html#impossibility-to-stabilize-without-a-hybrid-controller",
    "title": "Hybrid equations",
    "section": "Impossibility to stabilize without a hybrid controller",
    "text": "Impossibility to stabilize without a hybrid controller\n\nExample 6 (Unicycle stabilization) We consider a unicycle model of a vehicle in a plane, characterized by the position and orientation, with controlled forward speed and yaw (turning) angular rate.\n\n\n\nUnicycle vehicle\n\n\nThe vehicle is modelled by \n\\begin{aligned}\n\\dot x &= v \\cos \\theta,\\\\\n\\dot y &= v \\sin \\theta,\\\\\n\\dot \\theta &= \\omega,\n\\end{aligned}\n\n\n\\bm x = \\begin{bmatrix}\nx\\\\ y\\\\ \\theta\n\\end{bmatrix},\n\\quad\n\\bm u = \\begin{bmatrix}\nv\\\\ \\omega\n\\end{bmatrix}.\n\nIt is known that this system cannot be stabilized by a continuous feedback controller. The general result that applies here was published in [1]. The condition of stabilizability by a time-invariant continuous state feedback is that the image of every neighborhood of the origin under (\\bm x,\\bm u) \\mapsto \\bm f(\\bm x, \\bm u) contains some neighborhood of the origin. This is not the case here. The map from the state-control space to the velocity space is\n\n\\begin{bmatrix}\nx\\\\ y\\\\ \\theta\\\\ v\\\\ \\omega\n\\end{bmatrix}\n\\mapsto\n\\begin{bmatrix}\nv \\cos \\theta\\\\\nv \\sin \\theta \\\\\n\\omega\n\\end{bmatrix}.\n\nNow consider a neighborhood of the origin such that |\\theta|&lt;\\frac{\\pi}{2}. It is impossible to get \\bm f(\\bm x, \\bm u) = \\begin{bmatrix}\n0\\\\ f_2 \\\\ 0\\end{bmatrix}, \\; f_2\\neq 0. Hence, stabilization by a continuous feedback \\bm u = \\kappa (\\bm x) is impossible.\nBut it is possible to stabilize the vehicle using a discontinuous feedback. And discontinuous feedback controllr can be viewed as switching control, which in turn can be seen as instance of a hybrid controller.\n\n\nExample 7 (Global stabilization on a circle) We now demonstration of a general phenomenon of stabilization on a manifold. We will see that even if stabilization by a continous feedback is possible, it might not guarantee global stability.\nThe dynamics of a particle sliding around a unit circle \\mathbb S_1 is modelled by\n\n\\dot{\\bm x} = u\\begin{bmatrix}0 & -1\\\\ 1 & 0\\end{bmatrix}\\bm x,\n where \\bm x \\in \\mathbb S^1,\\quad u\\in \\mathbb R.\nThe point to be stabilized is \\bm x^* = \\begin{bmatrix}1\\\\ 0\\end{bmatrix}.\n\n\n\nStabilization on a circle\n\n\nWhat is required from a globally stabilizing controller?\n\nSolutions stay in \\mathbb S^1,\nSolutions converge to \\bm x^*,\nIf a solution starts near \\bm x^*, it stays near.\n\nOne candidate is \\kappa(\\bm x) = -x_2.\nDefine the (Lyapunov) function V(\\bm x) = 1-x_1.\nIts time derivative along the solution trajectory \n\\begin{aligned}\n\\dot V &= \\left(\\nabla_{\\bm{x}}V\\right)^\\top \\dot{\\bm x}\\\\\n&= \\begin{bmatrix}-1 & 0\\end{bmatrix}\\left(-x_2\\begin{bmatrix}0 & -1\\\\ 1 & 0\\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}\\right)\\\\\n&= -x_2^2\\\\\n&= -(1-x_1^2).\n\\end{aligned}\n\nIt follows that \n\\dot V &lt; 0 \\quad \\forall \\bm x \\in \\mathbb S^1 \\setminus \\{-1,1\\}.\n\nWith u=-x_2 the point \\bm x^* is stable but not globally atractive.\nCan we do better? Yes, we can. But we need to incorporate some switching into the controller. Loosely speaking anywhere except for the state (-1,0), we can apply the previously design controller, and at the troublesome state (-1,0), or actually in some region around it, we need to switch to another controller that would drive the system away from the problematic region.\nBut we will take this example as an opportunity to go one step further and instead of just a switching controller we design a hybrid controller. The difference is that within a hybrid controller we can incorporate some hysteresis, which is a robustifying feature. In order to to that, we need to introduce a new state variable q\\in\\{0,1\\}. Determination of the flow and jump sets is sketched in Figure 2.\n\n\n\n\n\n\nFigure 2: Definition of the sets defining a hybrid controller\n\n\n\nThe two feedback controllers are given by \n\\begin{aligned}\n\\kappa(\\bm x,0) &= \\kappa_0(\\bm x) = -x_2,\\\\\n\\kappa(\\bm x,1) &= \\kappa_1(\\bm x) = -x_1.\n\\end{aligned}\n\nThe flow map is (DIY) \nf(\\bm x, q) = \\ldots\n\nThe flow set is \n\\mathcal{C} = (\\mathcal C_0 \\times \\{0\\}) \\cup (\\mathcal C_1 \\times \\{1\\}).\n\nThe jump set is \n\\mathcal{D} = (\\mathcal D_0 \\times \\{0\\}) \\cup (\\mathcal D_1 \\times \\{1\\}).\n\nThe jump map is \ng(\\bm x, q) = 1-q \\quad \\forall [\\bm x, q]^\\top \\in \\mathcal D.\n\nSimulation using Julia is provided below.\n\n\nShow the code\nusing OrdinaryDiffEq\n\n# Defining the sets and functions for the hybrid equations\n\nc₀, c₁ = -2/3, -1/3\n\nC(x,q) = (x[1] &gt;= c₀ && q == 0) || (x[1] &lt;= c₁ && q == 1) # Actually not really needed, just a complement of D.\nD(x,q) = (x[1] &lt; c₀ && q == 0) || (x[1] &gt; c₁ && q == 1) \n\ng(x,q) = 1-q\n\nκ(x,q) = q==0 ? -x[2] : -x[1] \n\nfunction f!(dx,x,q,t)               # Already in the format for the ODE solver.\n    A = [0.0 -1.0; 1.0 0.0] \n    dx .= A*x*κ(x,q)\nend\n\n# Defining the initial conditions for the simulation\n\ncᵢ = (c₀+c₁)/2\nx₀ = [cᵢ,sqrt(1-cᵢ^2)]\nq₀ = 1\n\n# Setting up the simulation problem\n\ntspan = (0.0,10.0)\nprob = ODEProblem(f!,x₀,tspan,q₀)\n\nfunction condition(x,t,integrator)\n    q = integrator.p \n    return D(x,q)\nend\n\nfunction affect!(integrator)\n    q = integrator.p\n    x = integrator.u \n    integrator.p = g(x,q)\nend\n\ncb = DiscreteCallback(condition,affect!)\n\n# Solving the simulation problem\n\nsol = solve(prob,Tsit5(),callback=cb,dtmax=0.1) # ContinuousCallback more suitable here\n\n# Plotting the results of the simulation\n\nusing Plots\ngr(tickfontsize=12,legend_font_pointsize=12,guidefontsize=12)\n\nplot(sol,label=[\"x₁\" \"x₂\"],xaxis=\"t\",yaxis=\"x\",lw=2)\nhline!([c₀], label=\"c₀\")\nhline!([c₁], label=\"c₁\")\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Simulation of stabilization on a circle using a hybrid controller\n\n\n\n\nThe solution can also be visualized in the state space.\n\n\nShow the code\nplot(sol,vars=(1,2),label=\"\",xaxis=\"x₁\",yaxis=\"x₂\",lw=2,aspect_ratio=1)\nvline!([c₀], label=\"c₀\")\nvline!([c₁], label=\"c₁\")\nscatter!([x₀[1]],[x₀[2]],label=\"x init\")\nscatter!([1],[0],label=\"x ref\")\n\n\n┌ Warning: To maintain consistency with solution indexing, keyword argument vars will be removed in a future version. Please use keyword argument idxs instead.\n│   caller = ip:0x0\n└ @ Core :-1\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Simulation of stabilization on a circle using a hybrid controller",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#supervisory-control",
    "href": "hybrid_equations.html#supervisory-control",
    "title": "Hybrid equations",
    "section": "Supervisory control",
    "text": "Supervisory control\nYet another problem that can benefit from being formulated as a hybrid system is supervisory control.\n\n\n\nSupervisory control",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "hybrid_equations.html#combining-local-and-global-controllers-subset-supervisory-control",
    "href": "hybrid_equations.html#combining-local-and-global-controllers-subset-supervisory-control",
    "title": "Hybrid equations",
    "section": "Combining local and global controllers (\\subset supervisory control)",
    "text": "Combining local and global controllers (\\subset supervisory control)\nAs a subset of supervisory control we can view a controller that switches between a global and a local controller.\n\n\n\nCombining global and local controllers\n\n\nLocal controllers have good transient response but only work well in a small region around the equilibrium state. Global controllers have poor transient response but work well in a larger region around the equilibrium state.\nA useful example is that of swinging up and stabilization of a pendulum: the local controller can be designer for a linear model obtained by linearization about the upright orientation of the pendulum. But such controller can only be expected to perform well in some small region around the upright orientation. The global controller is designed to bring the pendulum into that small region.\nThe flow and jump sets for the local and global controllers are in Figure 5. Can you tell, which is which? Remember that by introducing the discrete variable q, some hysteresis is in the game here.\n\n\n\n\n\n\nFigure 5: Flow and jump sets for a local and a global controller",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "demo_error.html",
    "href": "demo_error.html",
    "title": "Demo",
    "section": "",
    "text": "Lorem ipsum: \\(x^2 + y^2 = 1\\). For this and that ….\n\n\n\n Back to top"
  },
  {
    "objectID": "complementarity_simulations.html",
    "href": "complementarity_simulations.html",
    "title": "Simulations using complementarity",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Simulations using complementarity"
    ]
  },
  {
    "objectID": "max_plus_software.html",
    "href": "max_plus_software.html",
    "title": "Software",
    "section": "",
    "text": "MaxPlus.jl package for Julia by Quentin Quadrat.\nMax-Plus Algebra Toolbox for Matlab by Jarosław Stańczyk.\n\n\n\n\n Back to top",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Software"
    ]
  },
  {
    "objectID": "petri_nets.html",
    "href": "petri_nets.html",
    "title": "Petri nets",
    "section": "",
    "text": "In this chapter we introduce another formalism for modelling discrete event systems (DES) – Petri nets. Petri nets offer an alternative perspective on discrete even systems compared to automata. And it is good to have alternatives, isn’t it? For some purposes, one framework can be more appropriate than the other.\nFor example, a finite Petri net can model even an infinite state automaton.\nFurthermore, the ideas behind Petri nets even made it into international standards. Either directly or through the derived GRAFCET language, which in turn served as the basis for the Sequential Function Chart (SFC) language for PLC programming. See the references.\nLast but not least, an elegant algebraic framework based on the so-called (max,+) algebra has been developed for a subset of Petri nets (so-called event graphs) and it would be a shame not to mention it in our course (in the next chapter).",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#definition-of-a-petri-net",
    "href": "petri_nets.html#definition-of-a-petri-net",
    "title": "Petri nets",
    "section": "Definition of a Petri net",
    "text": "Definition of a Petri net\nSimiliarly as in the case of automata, a Petri net (PN) can be defined as a tuple of sets and functions: \\boxed{PN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w\\},} where\n\n\\mathcal{P} = \\{p_1, \\dots, p_n\\} is a finite set of places,\n\\mathcal{T} = \\{t_1, \\dots, t_m\\} is a finite set of transitions,\n\\mathcal{A} \\subseteq (\\mathcal{P} \\times \\mathcal{T}) \\cup (\\mathcal{T} \\times \\mathcal{P}) is a finite set of arcs, and these arcs are directed and since there are two types of nodes, there are also two types of arcs:\n\n(p_i, t_j) \\in \\mathcal{A} is from place p_i to transition t_j,\n(t_j, p_i) \\in \\mathcal{A} is from transition t_j to place p_i,\n\nw : \\mathcal{A} \\to \\mathbb{N} is a weight function.\n\nSimilarly as in the case of automata, Petri nets can be visualized using graphs. But this time, we need to invoke the concept of a weighted bipartite graph. That is, a graph with two types of nodes:\n\nplaces = circles,\ntransitions = bars.\n\nThe nodes of different kinds are connected by arcs (arrowed curves). A integer weights are associated with arcs. Alternatively, for a smaller weight (2, 3, 4), the weithg can be graphically encoded by drawing multiple arcs.\n\nExample 1 (Simple Petri net) We consider just two places, that is, \\mathcal{P} = \\{p_1, p_2\\}, and one transition, that is, \\mathcal{T} = \\{t\\}. The set of arcs is \\mathcal{A} = \\{\\underbrace{(p_1, t)}_{a_1}, \\underbrace{(t, p_2)}_{a_2}\\}, and the associated weights are w(a_1) = w((p_1, t)) = 2 and w(a_2) = w((t, p_2)) = 1. The Petri net is depicted in Figure 1.\n\n\n\n\n\n\nFigure 1: Example of a simple Petri net\n\n\n\n\n\nAdditional definitions\n\n\\mathcal{I}(t_j) … a set of input places of the transition t_j,\n\\mathcal{O}(t_j) … a set of output places of the transition t_j.\n\n\nExample 2 (More complex Petri net)  \n\n\\mathcal{P} = \\{p_1, p_2, p_3, p_4\\},\n\\mathcal{T} = \\{t_1, t_2, t_3, t_4, t_5\\},\n\\mathcal{A} = \\{(p_1, t_1), (t_1, p_1), (p_1, t_2),\\ldots\\},\nw((p_1, t_1)) = 2, \\; w((t_1, p_1)) = 1, \\; \\ldots\n\n\n\n\n\n\n\nFigure 2: Example of a more complex Petri net\n\n\n\n\n\n\nMarking and marked Petri nets\nAn important concept that we must introduce now is that of marking. It is a function that assigns an integer to each place   x: \\mathcal{P} \\rightarrow \\mathbb{N}.\nThe vector composed of the values of the marking function for all places \\bm x = \\begin{bmatrix}x(p_1)\\\\ x(p_2)\\\\ \\vdots \\\\ x(p_n) \\end{bmatrix} can be viewed as the state vector (although the Petri nets community perhaps would not use this terminology and stick to just marking).\nMarked Petri net is then a Petri net augmented with the marking\nMPN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w,x\\}.\n\nVisualization of marked Petri net using tokens\nMarked Petri net can also be visualized by placing tokens (dots) into the places. The number of tokens in a place corresponds to the value of the marking function for that place.\n\nExample 3 (Marked Petri net) Consider the Petri net from Example 1. The marking function is x(p_1) = 2 and x(p_2) = 1, which assembled into a vector gives \\bm x = \\begin{bmatrix}1\\\\ 0 \\end{bmatrix}. The marked Petri net is depicted in Figure 3.\n\n\n\n\n\n\nFigure 3: Example of a marked Petri net\n\n\n\nFor another marking, namely \\bm x = \\begin{bmatrix}2\\\\ 1 \\end{bmatrix}, the marked Petri net is depicted in Figure 4.\n\n\n\n\n\n\nFigure 4: Example of a marked Petri net with different marking\n\n\n\n\n\n\n\nEnabling and firing of a transition\nFinally, here comes the enabling (pun intended) component of the definition of a Petri net – enabled transition. A transition t_j does not just happen – we say fire – whenever it wants, it can only happen (fire) if it is enabled, and the marking is used to determined if it is enabled. Namely, the transition is enabled if the value of the marking function for each input place is greater than or equal to the weight of the arc from that place to the transition. That is, the transition t_j is enabled if \nx(p_i) \\geq w(p_i,t_j)\\quad \\forall p_i \\in \\mathcal{I}(t_j).\n\n\n\n\n\n\n\nCan but does not have to\n\n\n\nThe enabled transition can fire, but it doesn’t have to. We will exploit this in timed PN.\n\n\n\nExample 4 (Enabled transition) See the PN in Example 3: in the first marked PN the transition cannot fire, in the second it can.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#state-transition-function",
    "href": "petri_nets.html#state-transition-function",
    "title": "Petri nets",
    "section": "State transition function",
    "text": "State transition function\nWe now have a Petri net as a conceptual model with a graphical representation. But in order to use it for some quantitative analysis, it is useful to turn it into some computational form. Preferrably a familiar one. This is done by defining a state transition function. For a Petri net with n places, the state transition function is \nf: \\mathbb N^n \\times \\mathcal{T} \\rightarrow \\mathbb N^n,\n which reads that the state transition fuction assignes a new marking (state) to the Petri net after a transition is fired at some given marking (state).\nThe function is only defined for a transition t_j iff the transition is enabled.\nIf the transition t_j is enabled and fired, the state evolves as \n\\bm x^+ = f(\\bm x, t_j),\n where the individual components of \\bm x evolve according to \\boxed{\n    x^+(p_i) = x(p_i) - w(p_i,t_j) + w(t_j,p_i), \\; i = 1,\\ldots,n.}\n\nThis has a visual interpretation – a fired transition moves tokens from the input to the output places.\n\nExample 5 (Moving tokens around) Consider the PN with the initial marking (state) \\bm x_0 = \\begin{bmatrix}2\\\\ 0\\\\ 0\\\\ 1 \\end{bmatrix} (at discrete time 0), and the transition t_1 enabled\n\n\n\nExample PN in the initial state at time 0, the transition t_1 enabled, but not yet fired\n\n\n\n\n\n\n\n\nConflict in notation. Again. Sorry.\n\n\n\nWe admit the notation here is confusing, because we use the lower index 0 in \\bm x_0 to denote the discrete time, while the lower index 1 in t_1 to denote the transition and the lower indices 1 and 2 in p_1 and p_2 just number the transitions and places, respectively. We could have chosen something like \\bm x(0) or \\bm x[0], but we dare to hope that the context will make it clear.\n\n\nNow we assume that t_1 is fired\n\n\n\n\n\n\nFigure 5: Transition t_1 in the example PN fired at time 1\n\n\n\nThe state vector changes to \\bm x_1 = [1, 1, 1, 1]^\\top, the discrete time is 1 now.\nAs a result of this transition, note that t_1, t_2, t_3 are now enabled.\n\n\n\n\n\n\nNumber of tokens need not be preserved\n\n\n\nIn the example we can see for the first time, that the number of tokens need not be preserved.\n\n\nNow fire the t_2 transition\n\n\n\nTransition t_2 in the example PN fired at time 2\n\n\nThe state vector changes to \\bm x_2 = [1, 1, 0, 2]^\\top, the discrete time is 2 now.\nGood, we can see the idea. But now we go back to time 1 (as in Figure 5) to explore the alternative evolution. With the state vector \\bm x_1 = [1, 1, 1, 1]^\\top and the transitions t_1, t_2, t_3 enabled, we fire t_3 this time.\n\n\n\nTransition t_3 in the example PN fired at time 1\n\n\nThe state changes to \\bm x_2 = [0, 1, 0, 0]^\\top, the discrete time is 2. Apparently the PN evolved into at a different state. The lesson learnt with this example is that the order of firing of enabled transitions matters.\n\n\n\n\n\n\n\nThe order in which the enabled transitions are fired does matter\n\n\n\nThe dependence of the state evolution upon the order of firing the transitions is not surprising. Wwe have already encountered it in automata when the active event set for a given state contains more then a single element.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#reachability",
    "href": "petri_nets.html#reachability",
    "title": "Petri nets",
    "section": "Reachability",
    "text": "Reachability\nWe have started talking about states and state transitions in Petri nets, which are all concepts that we are familiar with from dynamical systems. Another such concept is reachability. We explain it through an example.\n\nExample 6 (Not all states are reachable)  \n\n\n\nExample of an unreachability in a Petri net\n\n\nThe Petri net is initial in the state [2,1]^\\top. The only reachable state is [0,2]^\\top.\nBy the way, note that the weight of the arc from the place p_1 to the transition t is 2, so both tokens are removed from the place p_1 when the transition t fires. But then the arc to the place p_2 has weight 1, so only one token is added to the place p_2. The other token is “lost”.\n\n\nReachability tree and graph\nHere we introduce two tools for analysis of reachability of a Petri net.\n\nExample 7 Consider the following example of a Petri net.\n\n\n\nExample of a Petri net for reachability analysis\n\n\nIn Figure 6 we draw a reachability tree for this Petri net.\n\n\n\n\n\n\nFigure 6: Reachability tree for an example Petri net\n\n\n\nIn Figure 7 we draw a reachability graph for this Petri net.\n\n\n\n\n\n\nFigure 7: Reachability graph for an example Petri net",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#number-of-tokens-need-not-be-preserved-1",
    "href": "petri_nets.html#number-of-tokens-need-not-be-preserved-1",
    "title": "Petri nets",
    "section": "Number of tokens need not be preserved",
    "text": "Number of tokens need not be preserved\nWe have already commented on this before, but we emphasize it here. Indeed, it can be that \n\\sum_{p_i\\in\\mathcal{O}(t_j)}w(t_j,p_i) &lt; \\sum_{p_i\\in\\mathcal{I}(t_j)} w(p_i,t_j)\n\nor\n\n\\sum_{p_i\\in\\mathcal{O}(t_j)}w(t_j,p_i) &gt; \\sum_{p_i\\in\\mathcal{I}(t_j)} w(p_i,t_j)\n\nWith this reminder, we can now hightlight several patters that can be observed in Petri nets.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#and-convergence-and-divergence",
    "href": "petri_nets.html#and-convergence-and-divergence",
    "title": "Petri nets",
    "section": "AND-convergence, AND-divergence",
    "text": "AND-convergence, AND-divergence",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#or-convergence-and-or-divergence",
    "href": "petri_nets.html#or-convergence-and-or-divergence",
    "title": "Petri nets",
    "section": "OR-convergence and OR-divergence",
    "text": "OR-convergence and OR-divergence",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#nondeterminism-in-a-pn",
    "href": "petri_nets.html#nondeterminism-in-a-pn",
    "title": "Petri nets",
    "section": "Nondeterminism in a PN",
    "text": "Nondeterminism in a PN\nIn the four patters just enumerated, we have seen that the last one – the OR-divergence – is not deterministic. Indeed, consider the following example.\n\nExample 8  \n\n\n\nNondeterminism in a Petri net\n\n\n\nIn other words, we can incorporate a nondeterminism in a model.\n\n\n\n\n\n\nNondeterminism in automata\n\n\n\nRecall that something similar can be encountered in automata, if the active event set for a given state contains more than one element (event,transition).",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#subclasses-of-petri-nets",
    "href": "petri_nets.html#subclasses-of-petri-nets",
    "title": "Petri nets",
    "section": "Subclasses of Petri nets",
    "text": "Subclasses of Petri nets\nWe can identify two subclasses of Petri nets:\n\nevent graphs,\nstate machines.\n\n\nEvent graph\n\nEach place has just one input and one output transition (all ws equal to 1).\nNo OR-convergence, no OR-divergence.\nAlso known as Decision-free PN.\nIt can model synchronization.\n\n\nExample 9 (Event graph)  \n\n\n\nExample of an event graph\n\n\n\n\n\nState machine\n\nEach transition has just one input and one output place.\nNo AND-convergence, no AND-divergence.\nDoes not model synchronization.\nIt can model race conditions.\nWith no source (input) and sink (output) transitions, the number of tokens is preserved.\n\n\nExample 10 (State machine)  \n\n\n\nExample of a state machine\n\n\n\n\n\nIncidence matrix\nWe consider a Petri net with n places and m transitions. The incidence matrix is defined as \n\\bm A \\in \\mathbb{Z}^{n\\times m},\n where \na_{ij} = w(t_j,p_i) - w(p_i,t_j).\n\n\n\n\n\n\n\nTranspose\n\n\n\nSome define the incidence matrix as the transpose of our definition.\n\n\n\n\nState equation for a Petri net\nWith the incidence matrix defined above, the state equation for a Petri net can be written as \n\\bm x^+ = \\bm x + \\bm A \\bm u,\n where \\bm u is a firing vector for the enabled j-th transition \n\\bm u = \\bm e_j = \\begin{bmatrix}0 \\\\ \\vdots \\\\ 0 \\\\ 1\\\\ 0\\\\ \\vdots\\\\ 0\\end{bmatrix}\n with the 1 at the j-th position.\n\n\n\n\n\n\nNote\n\n\n\nNote that in [1] they define everything in terms of the transposed quantities, but we prefer sticking to the notion of a state vector as a column.\n\n\n\nExample 11 (State equation for a Petri net) Consider the Petri net from Example 5, which we show again below in Figure 8.\n\n\n\n\n\n\nFigure 8: Example of a Petri net\n\n\n\nThe initial state is given by the vector \n\\bm x_0\n=\n\\begin{bmatrix}\n2\\\\ 0\\\\ 0\\\\ 1\n\\end{bmatrix}\n\nThe incidence matrix is \n\\bm A = \\begin{bmatrix}\n-1 & 0 & -1\\\\\n1 & 0 & 0\\\\\n1 & -1 & -1\\\\\n0 & 1 & -1\n\\end{bmatrix}\n\nAnd the state vector evolves according to \n\\begin{aligned}\n\\bm x_1 &= \\bm x_0 + \\bm A \\bm u_1\\\\\n\\bm x_2 &= \\bm x_1 + \\bm A \\bm u_2\\\\\n\\vdots &\n\\end{aligned}\n\n\n\n\n\n\n\n\nCaution\n\n\n\nWe repeat once again just to make sure: the lower index corresponds to the discrete time.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#queueing-systems-modelled-by-pn",
    "href": "petri_nets.html#queueing-systems-modelled-by-pn",
    "title": "Petri nets",
    "section": "Queueing systems modelled by PN",
    "text": "Queueing systems modelled by PN\nAlthough Petri nets can be used to model a vast variety of systems, below we single out one particular class of systems that can be modelled by Petri nets – queueing systems. The general symbol is shown in Figure 9.\n\n\n\n\n\n\nFigure 9: Queing systems and its components and transitions/events\n\n\n\nWe can associate the transitions with the events in the queing system:\n\na is a spontaneous transition (no input places).\ns needs a customer in the queue and the server being idle.\nc needs the server being busy.\n\nWe can now start drawing the Petri net by drawin the bars corresponding to the transitions. Then in between every two bars, we draw a circle for a place. The places can be associated with three bold-face letters above, namely:\n\\quad \\mathcal{P} = \\{Q, I, B\\}, that is, queue, idle, busy.\n\n\n\nPetri net corresponding to the queing system\n\n\n\n\n\n\n\n\nThe input transition adds tokens to the system\n\n\n\nThe transition a is an input transition – the tokens are added to the system through this transition.\n\n\nNote how we consider the token in the I place. This is not only to express that the server is initially idle, ready to serve as soon as a customer arrives to the queue, it also ensures that no serving of a new customer can start before the serving of the current customer is completed.\nThe initial state: [0,1,0]^\\top. Consider now a particular trace (of transitions/events) \\{a,s,a,a,c,s,a\\}. Verify that this leads to the final state [2,0,1]^\\top.\n\nSome more extensions\nWe can keep adding features to the model of a queing system. In particular,\n\nthe arrival transition always enabled,\nthe server can break down, and then be repaired,\ncompleting the service \\neq customer departure.\n\nThese are incorporated into the Petri net in Figure 10.\n\n\n\n\n\n\nFigure 10: Extended model of a queueing system\n\n\n\nIn the Petri net, d is an output transition – the tokens are removed from the system.\n\nExample 12 (Beverage vending machine) Below we show a Petri net for a beverage vending machine. While building it, we find it useful to identify the events/transitions that can happen in the system.\n\n\n\nPetri net for a beverage vending machine",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#some-extensions-of-basic-petri-nets",
    "href": "petri_nets.html#some-extensions-of-basic-petri-nets",
    "title": "Petri nets",
    "section": "Some extensions of basic Petri nets",
    "text": "Some extensions of basic Petri nets\n\nColoured Petri nets (CPN): tokens can by of several types (colours), and the transitions can be enabled only if the tokens have the right colours.\n…\n\nWe do not cover these extensions in our course. But there is one particular extension that we do want to cover, and this amounts to introducing time into Petri nets, leading to timed Petri nets, which we will discuss in the next chapter.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "stability_references.html",
    "href": "stability_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "8. Stability",
      "Literature"
    ]
  },
  {
    "objectID": "des_software.html",
    "href": "des_software.html",
    "title": "Software",
    "section": "",
    "text": "In this course we will encounter a few more software packages but in this first learning block we will only lightly introduce two, both by The Mathworks:",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "des_software.html#matlab-and-simulink",
    "href": "des_software.html#matlab-and-simulink",
    "title": "Software",
    "section": "Matlab and Simulink",
    "text": "Matlab and Simulink\n\nStateFlow – fnite state automata within Simulink. Can also model hybrid automata. A nice interactive tutorial is launched directly within Simulink upon entering learning.simulink.launchOnramp(“stateflow”) in Matlab. We will primarily use this tool in our course. It extends nicely to hybrid systems.\nSimEvents – oriented towards one instance of the (state) automata, namely queuing systems. You may want to have a look at the series of introductory videos by the Mathworks. We will not particularly need it in our course. Several tools are also available outside Matlab and Simulink:",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "des_software.html#python",
    "href": "des_software.html#python",
    "title": "Software",
    "section": "Python",
    "text": "Python\nSimPy – discrete-event simulation in Python.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "des_software.html#julia",
    "href": "des_software.html#julia",
    "title": "Software",
    "section": "Julia",
    "text": "Julia\n\nConcurrentSim.jl – discrete-event simulation in Julia.\nDiscreteEvents.jl – discrete-event simulation in Julia.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "des_software.html#openmodelica",
    "href": "des_software.html#openmodelica",
    "title": "Software",
    "section": "(Open)Modelica",
    "text": "(Open)Modelica\nStarting with Modelica 3.3, some support for state machines is now built into the language. It is already implemented in OpenModelica, see the example.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "des_software.html#uppaal",
    "href": "des_software.html#uppaal",
    "title": "Software",
    "section": "UPPAAL",
    "text": "UPPAAL\nDedicated software for timed automata. Not only modelling and simulation but also formal verification. Available at https://uppaal.org/.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Software"
    ]
  },
  {
    "objectID": "max_plus_algebra.html",
    "href": "max_plus_algebra.html",
    "title": "Max-plus algebra",
    "section": "",
    "text": "Max-plus algebra, also written as (max,+) algebra (and also known as tropical algebra/geometry and dioid algebra), is an algebraic framework in which we can model and analyze a class of discrete-event systems, namely event graphs, which we introduced as a subset of Petri nets. The framework is appealing in that the models than look like state equations for classical linear dynamical systems. We call these max-plus linear systems, or just MPL systems. Concepts such as poles, stability and observability can be defined, following closely the standard definitions. In fact, we can even formulate control problems for these models in a way that mimicks the conventional control theory for LTI systems, including MPC control.\nBut before we get to these applications, we first need to introduce the (max,+) algebra itself. And before we do that, we recapitulate the definition of a standard algebra.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#algebra",
    "href": "max_plus_algebra.html#algebra",
    "title": "Max-plus algebra",
    "section": "Algebra",
    "text": "Algebra\nAlgebra is a set of elements equipped with\n\ntwo operations:\n\naddition (plus, +)\nmultiplication (times, ×)\n\nneutral (identity) element with respect to addition: zero, 0 a+0=a.\nneutral (identity) element with respect to multiplication: one, 1 a\\times 1 = a.\n\nInverse elements can also be defined, namely\n\nInverse element wrt addition: -a a+(-a) = 0.\nInverse element wrt multiplication (except for 0): a^{-1} a \\times a^{-1} = 1.\n\nIf the inverse wrt multiplication exists for every (nonzero) element, the algebra is called a field, otherwise it is called a ring.\nProminent examples of a ring are integers and polynomials. For integers, it is only the numbers 1 and -1 that have integer inverses. For polynomials, it is only zero-th degree polynomials that have inverses qualifying as polynomials too.\nProminent example of a field is the set of real numbers.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#max-algebra-redefining-the-addition-and-multiplication",
    "href": "max_plus_algebra.html#max-algebra-redefining-the-addition-and-multiplication",
    "title": "Max-plus algebra",
    "section": "(max,+) algebra: redefining the addition and multiplication",
    "text": "(max,+) algebra: redefining the addition and multiplication\nElements of the (max,+) algebra are real numbers numbers, but it is still a ring and not a field since the two operations are defined differently.\nThe new operations of addition, which we denote by \\oplus to distinguish it from the standard addition, is defined as \\boxed{\n  x\\oplus y \\equiv \\max(x,y).\n  }\n\nThe new operation of multiplication, which we denote by \\otimes to distinguish it from the standard multiplication, is defined as \\boxed{\n  x\\otimes y \\equiv x+y}.\n\n\n\n\n\n\n\nImportant\n\n\n\nIndeed, there is no typo here, the standard addition is replaced by \\otimes and not \\oplus.\n\n\n\n\n\n\n\n\n(min,+) also possible\n\n\n\nIndeed, we can also define the (min,+) algebra. But for our later purposes in modelling we prefer the (max,+) algebra.\n\n\n\nReals must be extended with the negative infinity\nStrictly speaking, the (max,+) algebra is a broader set than just \\mathbb R. We need to extend the reals with the minus infinity. We denote the extended set by \\mathbb R_\\varepsilon \\boxed{\n\\mathbb R_\\varepsilon \\coloneqq \\mathbb R \\cup \\{-\\infty\\}}.\n\nThe reason for the notation is that a dedicated symbol \\varepsilon is assigned to this minus infinity, that is, \\boxed\n{\\varepsilon \\coloneqq -\\infty.}\n\nIt may yield some later expressions less cluttered. Of course, at the cost of introducing one more symbol.\nWe are now going to see the reason for this extension.\n\n\nNeutral elements\n\nNeutral element with respect to \\oplus\nThe neutral element with respect to \\oplus, the zero, is -\\infty. Indeed, for x \\in \\mathbb R_\\varepsilon \nx \\oplus \\varepsilon = x,\n because \\max(x,-\\infty) = x.\n\n\nNeutral element with respect to \\otimes\nThe neutral element with respect to \\otimes, the one, is 0. Indeed, for x \\in \\mathbb R_\\varepsilon \nx \\otimes \\varepsilon = x,\n because x+0=x.\n\n\n\n\n\n\nNonsymmetric notation, but who cares?\n\n\n\nThe notation is rather nonsymmetric here. We now have a dedicated symbol \\varepsilon for the zero element in the new algebra, but no dedicated symbol for the one element in the new algebra. It may be a bit confusing as “the old 0 is the new 1”. Perhaps similarly as we introduced dedicated symbols for the new operations of addition of multiplication, we could have introduced dedicated symbols such as ⓪ and ①, which would lead to expressions such as x⊕⓪=x and x ⊗ ① = x. In fact, in some software packages they do define something like mp-zero and mp-one to represent the two special elements. But this is not what we will mostly encounter in the literature. Perhaps the best attitude is to come to terms with this notational asymetry… After all, I myself was not even able to figure out how to encircle numbers in LaTeX…\n\n\n\n\n\nInverse elements\n\nInverse with respect to \\oplus\nThe inverse element with respect to \\oplus in general does not exist! Think about it for a few moments, this is not necessarily intuitive. For which element(s) does it exist? Only for \\varepsilon.\nThis has major consequences, for example, x\\oplus x=x.\nCan you verify this statement? How is is related to the fact that the inverse element with respect to \\oplus does not exist in general?\nThis is the key difference with respect to a conventional algebra, wherein the inverse element of a wrt conventional addition is -a, while here we do not even define \\ominus.\nFormally speaking, the (max,+) algebra is only a semi-ring.\n\n\nInverse with respect to \\otimes\nThe inverse element with respect to \\otimes does not exist for all elements. The \\varepsilon element does not have an inverse element with respect to \\otimes. But in this aspect the (max,+) algebra just follows the conventional algebra, beucase 0 has no inverse either.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#powers-and-the-inverse-with-respect-to-otimes",
    "href": "max_plus_algebra.html#powers-and-the-inverse-with-respect-to-otimes",
    "title": "Max-plus algebra",
    "section": "Powers and the inverse with respect to \\otimes",
    "text": "Powers and the inverse with respect to \\otimes\nHaving defined the fundamental operations and the fundamental elements, we can proceed with other operations. Namely, we consider powers. Fot an integer r\\in\\mathbb Z, the rth power of x, denoted by x^{\\otimes^r}, is defined, unsurprisingly as x^{\\otimes^r} \\coloneqq x\\otimes x \\otimes \\ldots \\otimes x.\nObserve that it corresponds to rx in the conventional algebra x^{\\otimes^r} = rx.\nBut then the inverse element with respect to \\otimes can also be determined using the (-1)th power as x^{\\otimes^{-1}} = -x.\nThis is not actually surprising, is it?\nThere are few more implications. For example,\nx^{\\otimes^0} = 0.\nThere is also no inverse element with respect to \\otimes for \\varepsilon, but it is expected as \\varepsilon is a zero wrt \\oplus. Furthermore, for r\\neq -1, if r&gt;0 , then \\varepsilon^{\\otimes^r} = \\varepsilon, if r&lt;0 , then \\varepsilon^{\\otimes^r} is undefined, which are both expected. Finally, \\varepsilon^{\\otimes^0} = 0 by convention.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#order-of-evaluation-of-max-formulas",
    "href": "max_plus_algebra.html#order-of-evaluation-of-max-formulas",
    "title": "Max-plus algebra",
    "section": "Order of evaluation of (max,+) formulas",
    "text": "Order of evaluation of (max,+) formulas\nIt is the same as that for the conventional algebra:\n1. power, \n2. multiplication, \n3. addition.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#max-polynomials-aka-tropical-polynomials",
    "href": "max_plus_algebra.html#max-polynomials-aka-tropical-polynomials",
    "title": "Max-plus algebra",
    "section": "(max,+) polynomials (aka tropical polynomials)",
    "text": "(max,+) polynomials (aka tropical polynomials)\nHaving covered addition, multiplication and powers, we can now define (max,+) polynomials. In order to get started, consider the the univariate polynomial p(x) = a_{n}\\otimes x^{\\otimes^{n}} \\oplus a_{n-1}\\otimes x^{\\otimes^{n-1}} \\oplus \\ldots \\oplus a_{1}\\otimes x \\oplus a_{0},\n where a_i\\in \\mathbb R_\\varepsilon and n\\in \\mathbb N.\nBy interpreting the operations, this translates to the following function \\boxed\n{p(x) = \\max\\{nx + a_n, (n-1)x + a_{n-1}, \\ldots, x+a_1, a_0\\}.}\n\n\nExample 1 (1D polynomial) Consider the following (max,+) polynomial \np(x) = 2\\otimes x^{\\otimes^{2}} \\oplus 3\\otimes x \\oplus 1.\n\nWe can interpret it in the conventional algebra as \np(x) = \\max\\{2x+2,x+3,1\\},  \n which is a piecewise linear (actually affine) function.\n\n\nCode\nusing Plots\nx = -5:3\nf(x) = max(2*x+2,x+3,1)\nplot(x,f.(x),label=\"\",thickness_scaling = 2)\nxc = [-2,1]\nyc = f.(xc)\nscatter!(xc,yc,markercolor=[:red,:red],label=\"\",thickness_scaling = 2)\n\n\n\n\nExample 2 (Example of a 2D polynomial) Nothing prevents us from defining a polynomial in two (and more) variables. For example, consider the following (max,+) polynomial \np(x,y) = 0 \\otimes x \\otimes y.\n\n\n\nCode\nusing Plots\nx = -2:0.1:2;\ny = -2:0.1:2;\nf(x,y) = max(0,x,y)\nz = f.(x',y);\nwireframe(x,y,z,legend=false,camera=(5,30))\nxlabel!(\"x\")\nylabel!(\"y\")\nzlabel!(\"f(x,y)\")\n\n\n\n\nExample 3 (Another 2D polynomial) Consider another 2D (max,+) polynomial \np(x,y) = 0 \\otimes x \\otimes y \\oplus (-1)\\otimes x^{\\otimes^2} \\oplus 1\\otimes x\\otimes y \\oplus (-1)\\otimes y^{\\otimes^2}.\n\n\n\nCode\nusing Plots\nx = -2:0.1:2;\ny = -2:0.1:2;\nf(x,y) = max(0,x,y,2*x-1,x+y+1,2*y-1)\nz = f.(x',y);\nwireframe(x,y,z,legend=false,camera=(15,30))\nxlabel!(\"x\")\nylabel!(\"y\")\nzlabel!(\"p(x,y)\")\n\n\n\n\n\n\n\n\n\nPiecewise affine (PWA) functions\n\n\n\nPiecewise affine (PWA) functions will turn out a frequent buddy in our course.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#solution-set-zero-set",
    "href": "max_plus_algebra.html#solution-set-zero-set",
    "title": "Max-plus algebra",
    "section": "Solution set (zero set)",
    "text": "Solution set (zero set)\n…",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#matrix-computations",
    "href": "max_plus_algebra.html#matrix-computations",
    "title": "Max-plus algebra",
    "section": "Matrix computations",
    "text": "Matrix computations\n\nAddition and multiplication\nWhat is nice about the whole (max,+) framework is that it also extends nicely to matrices. For matrices, whose elements are in \\mathbb R_\\varepsilon, we define the operations of addition and multiplication identically as in the conventional case, we just use different definitions of the two basic scalar operations. (A\\oplus B)_{ij} = a_{ij}\\oplus b_{ij} = \\max(a_{ij},b_{ij}) \n\\begin{aligned}\n(A\\otimes B)_{ij} &= \\bigoplus_{k=1}^n a_{ik}\\otimes b_{kj}\\\\\n&= \\max_{k=1,\\ldots, n}(a_{ik}+b_{kj})\n\\end{aligned}\n\n\n\nZero and identity matrices\n(max,+) zero matrix \\mathcal{E}_{m\\times n} has all its elements equal to \\varepsilon, that is, \n\\mathcal{E}_{m\\times n} =\n\\begin{bmatrix}\n\\varepsilon & \\varepsilon & \\ldots & \\varepsilon\\\\\n\\varepsilon & \\varepsilon & \\ldots & \\varepsilon\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n\\varepsilon & \\varepsilon & \\ldots & \\varepsilon\n\\end{bmatrix}.\n\n(max,+) identity matrix I_n has 0 on the diagonal and \\varepsilon elsewhere, that is, \nI_{n} =\n\\begin{bmatrix}\n0 & \\varepsilon & \\ldots & \\varepsilon\\\\\n\\varepsilon & 0 & \\ldots & \\varepsilon\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n\\varepsilon & \\varepsilon & \\ldots & 0\n\\end{bmatrix}.\n\n\n\nMatrix powers\nThe zerothe power of a matrix is – unsurprisingly – the identity matrix, that is, A^{\\otimes^0} = I_n.\nThe kth power of a matrix, for k\\in \\mathbb N\\setminus\\{0\\}, is then defined using A^{\\otimes^k} = A\\otimes A^{\\otimes^{k-1}}.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#connection-with-graph-theory-precedence-graph",
    "href": "max_plus_algebra.html#connection-with-graph-theory-precedence-graph",
    "title": "Max-plus algebra",
    "section": "Connection with graph theory – precedence graph",
    "text": "Connection with graph theory – precedence graph\nConsider A\\in \\mathbb R_\\varepsilon^{n\\times n}. For this matrix, we can define the precedence graph \\mathcal{G}(A) as a weighted directed graph with the vertices 1, 2, …, n, and with the arcs (j,i) with the associated weights a_{ij} for all a_{ij}\\neq \\varepsilon. The kth power of the matrix is then\n\n(A)^{\\otimes^k}_{ij} = \\max_{i_1,\\ldots,i_{k-1}\\in \\{1,2,\\ldots,n\\}} \\{a_{ii_1} + a_{i_1i_2} + \\ldots + a_{i_{k-1}j}\\}\n for all i,j and k\\in \\mathbb N\\setminus 0.\n\nExample 4 (Example) \nA =\n\\begin{bmatrix}\n2 & 3 & \\varepsilon\\\\\n1 & \\varepsilon & 0\\\\\n2 & -1 & 3\n\\end{bmatrix}\n\\qquad\nA^{\\otimes^2} =\n\\begin{bmatrix}\n4 & 5 & 3\\\\\n3 & 4 & 3\\\\\n5 & 5 & 6\n\\end{bmatrix}\n\n\n\n\n\n\n\n\n\nG\n\n\n1\n\n1\n\n\n\n1-&gt;1\n\n\n2\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n1\n\n\n\n3\n\n3\n\n\n\n1-&gt;3\n\n\n2\n\n\n\n2-&gt;1\n\n\n3\n\n\n\n2-&gt;3\n\n\n-1\n\n\n\n3-&gt;2\n\n\n0\n\n\n\n3-&gt;3\n\n\n3\n\n\n\n\n\n\nFigure 1: An example of a precedence graph\n\n\n\n\n\n\n\nIrreducibility of a matrix\n\nMatrix in \\mathbb R_\\varepsilon^{n\\times n} is irreducible if its precedence graph is strongly connected.\nMatrix is irreducible iff \n(A \\oplus A^{\\otimes^2} \\oplus \\ldots A^{\\otimes^{n-1}})_{ij} \\neq \\varepsilon \\quad \\forall i,j, i\\neq j.\n\\tag{1}",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#eigenvalues-and-eigenvectors",
    "href": "max_plus_algebra.html#eigenvalues-and-eigenvectors",
    "title": "Max-plus algebra",
    "section": "Eigenvalues and eigenvectors",
    "text": "Eigenvalues and eigenvectors\nEigenvalues and eigenvectors constitute another instance of a straightforward import of concepts from the conventional algebra into the (max,+) algebra – just take the standard definition of an eigenvalue-eigenvector pair and replace the conventional operations with the (max,+) alternatives \nA\\otimes v = \\lambda \\otimes v.\n\nA few comments:\n\nIn general, total number of (max,+) eigenvalues &lt;n.\nAn irreducible matrix has only one (max,+) eigenvalue.\nGraph-theoretic interpretation: maximum average weight over all elementary circuits…\n\n\nEigenvalue-related property of irreducible matrices\nFor large enough k and c, it holds that \\boxed\n{A^{\\otimes^{k+c}} = \\lambda^{\\otimes^c}\\otimes A^{\\otimes^k}.}",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#solving-max-linear-equations",
    "href": "max_plus_algebra.html#solving-max-linear-equations",
    "title": "Max-plus algebra",
    "section": "Solving (max,+) linear equations",
    "text": "Solving (max,+) linear equations\nWe can also define and solve linear equations within the (max,+) algebra. Considering A\\in \\mathbb R_\\varepsilon^{n\\times n},\\, b\\in \\mathbb R_\\varepsilon^n, we can formulate and solve the equation \nA\\otimes x = b.\n\nIn general no solution even if A is square. However, often we can find some use for a subsolution defined as \nA\\otimes x \\leq b.\n\nTypically we search for the maximal subsolution instead, or subsolutions optimal in some other sense.\n\nExample 5 (Greatest subsolution) \nA =\n\\begin{bmatrix}\n2 & 3 & \\varepsilon\\\\\n1 & \\varepsilon & 0\\\\\n2 & -1 & 3\n\\end{bmatrix},\n\\qquad\nb =  \n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\n\nx =\n\\begin{bmatrix}\n1\\\\ -2 \\\\ 0\n\\end{bmatrix}\n\n\nA \\otimes x =\n\\begin{bmatrix}\n1\\\\ 0 \\\\ 1\n\\end{bmatrix}\n\\leq b\n\n\nWith this introduction to the (max,+) algebra, we are now ready to move on to the modeling of discrete-event systems using the max-plus linear (MPL) systems.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "des.html",
    "href": "des.html",
    "title": "Discrete-event systems",
    "section": "",
    "text": "We have already mentioned that hybrid systems are composed of time-driven subsystems and event-driven subsystems. Assuming that the primary audience of this course are already familiar with the former (having been exposed to state equations and transfer function), here we are going to focus on the latter, also called discrete-event systems DES (or DEVS).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#discrete-event",
    "href": "des.html#discrete-event",
    "title": "Discrete-event systems",
    "section": "(Discrete) event",
    "text": "(Discrete) event\nWe need to start with the definition of an event. Sometimes an adjective discrete is added (to get discrete event), although it appears rather redundant.\nThe primary characteristic of an event is instantaneous occurence, that is, an event takes no time.\nWithin the context of systems, an event is associated with a change of state – transition of the system from one state to another. Between two events, the systems remains in the same state, it doesn’t evolve.\n\n\n\n\n\n\nThe concept of a state\n\n\n\nTrue, here we are making a reference to the concept of a state, which we haven’t defined yet. But we can surely rely on understanding this concept developed by studying the time-driven systems (modelled by state equations).\n\n\nAlthough it is not instrumental in defining the event, the state space is frequently assumed discrete (even if infinite).\n\nExample 1 (DES state trajectory) In the figure below we can see an example state trajectory of a discrete-event system corresponding to a particular sequence of events.\n\nIt is perhaps worth emphasizing that the state space is not necessarily equidistantly discretized.\nAlso note that for some events no transitions occur (\\(e_3\\) at \\(t_3\\)).\n\n\n\n\n\n\n\nFrequent notational confusion: does the lower index represent discrete time or an element of a set?\n\n\n\nThe previous example also displays one particular annoying (and frequently occuring in literature) notational conflict. How shall we interpret the lower index? Sometimes it is used to refer to (discrete) time, and on some other occasions it can just refer to a particular element of a set. In other words, this is a notational clash between name of the variable and value of the variable. In the example above we obviously adopted the latter interpretation. But in other cases, we ourselves are prone to inconsistency. Just make sure you understand what the author means.\n\n\n\nExample 2 (State trajectory of a continuous-time dynamical systems) Compare now the above example of a state trajectory in a DES with the example of a continuous-time state space system below, whose model could be \\(\\dot x(t) = f(x)\\). In the latter, any change, however small, takes time. In other words, the system evolves continuously in time.\n\nThe set of states (aka state space) is \\(\\mathbb{R}\\) (or a subset) in this case (in general \\(\\mathbb{R}^n\\) or a subset).\n\n\nExample 3 (State trajectory of a time-discretized (aka sampled-data) system) As a yet another example of a state trajectory, consider the response of a discrete-time (actually time-discretized or also sampled-data system) system model by \\(x_k = f(x_k)\\) in the figure below. Although we could view the sampling instances as the events, these are given by time, hence the moments of transitions are predictable. Hence the system can still be viewed and analyzed as a time-driven and not event driven one.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#when-do-events-occur",
    "href": "des.html#when-do-events-occur",
    "title": "Discrete-event systems",
    "section": "When do events occur?",
    "text": "When do events occur?\nThere are three major possibilities:\n\nwhen action is taken (button press, clutch released, …),\nspontaneously: well, this is just an “excuse” when the reason is difficult to trace down (computer failure, …),\nwhen some condition is met (water level is reached, …). This needs an introduction of a concept of a hybrid systems, wait for it.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#sequence-of-time-stamped-events-aka-timed-trace",
    "href": "des.html#sequence-of-time-stamped-events-aka-timed-trace",
    "title": "Discrete-event systems",
    "section": "Sequence of “time-stamped” events (aka timed trace)",
    "text": "Sequence of “time-stamped” events (aka timed trace)\nThe sequence of pairs (event, time) \\[(e_1,t_1), (e_2,t_2), (e_3,t_3), \\ldots\\]\nis sufficient to characterize an execution of a deterministic system, that is, a system with a unique initial state and a unique transitions at a given state and an event.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#des-can-be-stochastic-but-what-exactly-is-stochastic-then",
    "href": "des.html#des-can-be-stochastic-but-what-exactly-is-stochastic-then",
    "title": "Discrete-event systems",
    "section": "DES can be stochastic, but what exactly is stochastic then?",
    "text": "DES can be stochastic, but what exactly is stochastic then?\nStochasticity can be introduced in\n\nthe event times (e.g. Poisson process),\nbut also in the transitions (e.g. probabilistic automata, more on this later).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#sometimes-time-stamps-not-needed-the-ordering-of-events-is-enough",
    "href": "des.html#sometimes-time-stamps-not-needed-the-ordering-of-events-is-enough",
    "title": "Discrete-event systems",
    "section": "Sometimes time stamps not needed – the ordering of events is enough",
    "text": "Sometimes time stamps not needed – the ordering of events is enough\nThe sequence of events (aka trace) \\[e_1,e_2,e_3, \\ldots\\] can be enough for some analysis, in which only the order of the events is important.\n\nExample 4 credit_card_swiped, pin_entered, amount_entered, money_withdrawn",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#discrete-event-systems-are-studied-through-their-languages",
    "href": "des.html#discrete-event-systems-are-studied-through-their-languages",
    "title": "Discrete-event systems",
    "section": "Discrete-event systems are studied through their languages",
    "text": "Discrete-event systems are studied through their languages\nWhen studying discrete-event systems, soon we are exposed to terminology from the formal language theory such as alphabet, word, and language. This must be rather confusing for most students (at least those with no education in computer science). In our course we are not going to use these terms actively (after all our only motivation for introducing the discipline of discrete-event systems is to take away just a few concepts that are useful in hybrid systems), but we want to sketch the motivation for their introduction to the discipline, which may make it easier for a student to skim through some materials on discrete-event systems.\nWe define at least those three terms that we have just mentioned. The definitions correspond to the everyday usage of these terms.\n\nAlphabet\n\na set of symbols.\n\nWord (or string)\n\na sequence of symbols from a finite alphabet.\n\nLanguage\n\na set of words from the given alphabet.\n\n\nNow, a symbol is used to label an event. Alphabet is then a set of possible events. A particular sequence of events (we also call it trace) is then represented by a word. Since we agreed that events are associated with state transitions of a corresponding system, a word represents a possible execution or run of a system. A set of all possible executions of a given system can then be formally viewed as language.\nIndeed, all this is just a formalism, the agreement how to talk about things. We will see an example of this “jargon” when in the next section when we introduce the concept of an automaton and some of its properties.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#modelling-frameworks-for-des-as-used-in-our-course",
    "href": "des.html#modelling-frameworks-for-des-as-used-in-our-course",
    "title": "Discrete-event systems",
    "section": "Modelling frameworks for DES (as used in our course)",
    "text": "Modelling frameworks for DES (as used in our course)\nThese are the three frameworks that we are going to cover in our course. They may be some more, but these three are the major ones, and from these there is always some lesson to be learnt that we will find useful later when finally studying hybrid systems\n\n(State) automaton (pl. automata)\nPetri net\n(max,plus) algebra, MPL systems\n\nWhile the first two frameworks are essentially equally powerful when it comes to modelling DES, the third one can be regarded as an algebraic framework for a subset of systems modelled by Petri nets.\nWe are going to cover all the three frameworks in this course as a prequel to hybrid systems.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "stability_via_common_lyapunov_function.html",
    "href": "stability_via_common_lyapunov_function.html",
    "title": "Common Lyapunov function",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Common Lyapunov function"
    ]
  },
  {
    "objectID": "classes_PWA.html",
    "href": "classes_PWA.html",
    "title": "Piecewise affine systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Piecewise affine systems"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html",
    "href": "verification_temporal_logics.html",
    "title": "Temporal logics",
    "section": "",
    "text": "It is natural to invoke the standard (propositional) logic when defining whatever requirements – we require that “if this and that conditions are satisfied, then yet another condition must not hold”, and so on.\nIt turns out, however, that the spectrum of requirements expressed with propositional logic is not rich enough when specifying requirements for discrete-event and hybrid systems whose states evolve causally in time. Temporal logics add some more expressiveness.\nIndeed, the plural is correct – there are several temporal logics. Before listing the most common ones, we introduce the key temporal operators that are going to be used together with logical operators.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#temporal-operators",
    "href": "verification_temporal_logics.html#temporal-operators",
    "title": "Temporal logics",
    "section": "Temporal operators",
    "text": "Temporal operators\nThe name might be misleading here – the adjective temporal has nothing to do with time as measured by the wall clock. Instead, as (discrete) state trajectories form sequencies, temporal operators help express when certain properties must (or must not) be satisfied along the state trajectories.\n\nExample 1 Consider the state automaton for a controller for two traffic lights. The state trajectory for each light is a sequence of color states \\{\\text{green}, \\text{yellow}, \\text{red}, \\text{red-yellow}\\} of the traffic light. We may want to impose a requirement such that \\text{green} is never on at both lights at the same time. This we can easily express just with the standard logical operators, namely, \\neg(\\text{green}_1 \\land \\text{green}_2). But now consider that we require that sooner or later, \\text{green} must be on for each light (to guarantee fairness). And that this must be true all the time, that is, \\text{green} must come infinitely often. And, furthermore, that \\text{red} cannot come imediately after its respective \\text{green}.\n\nRequirements like these cannot be expressed with standard logical operators such as \\lnot, \\land, \\lor, \\implies and \\iff, and temporal operators must be introduced. Here they are.\n\nTemporal operators\n\n\nSymbol\nAlternative symbol\nMeaning\n\n\n\n\n\\mathbf{F}\n\\Diamond\nEventually (Finally)\n\n\n\\mathbf{G}\n\\Box\nGlobally (Always)\n\n\n\\mathbf{X}\n\\bigcirc\nNeXt\n\n\n\\mathbf{U}\n\\sqcup\nUntill\n\n\n\nWe are explaining their use while we introduce our first temporal logic.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#linear-temporal-logic-ltl",
    "href": "verification_temporal_logics.html#linear-temporal-logic-ltl",
    "title": "Temporal logics",
    "section": "Linear temporal logic (LTL)",
    "text": "Linear temporal logic (LTL)\n“Linear” refers to linearity in time (one after another, as opposed to branching). Consider a sequence of discrete states (aka state trajectory or path) of a given discrete-event or hybrid system that is iniated at some state x.\nWe now consider some property \\phi(x) of a sequence of states emanating from the state x. \\phi(x) evaluates to true or false. And indeed, while the argument of \\phi is a particular state, when evaluating \\phi, the full sequence is taken into consideration when evaluating \\phi(x).\nIn order to be able to express requirements on future states, \\phi() cannot be just a logical formula, it must by a LTL formula. Here comes a formal definition \n\\begin{aligned}\n\\phi &= \\text{true} \\, | \\, p \\, | \\, \\neg \\phi_1 \\, | \\, \\phi_1 \\land \\phi_2 \\, | \\, \\phi_1 \\lor \\phi_2 \\\\\n&\\quad | \\, \\mathbf{X} \\phi_1 \\, | \\, \\mathbf{F} \\phi_1 \\, | \\, \\mathbf{G} \\phi_1 | \\, \\phi_1 \\mathbf{U} \\phi_2\n\\end{aligned}\n\nHaving an LTL formula, we write that a state sequence emanating from a given discrete state x satisfies the formula as x \\models \\phi if \\phi is true for all possible state trajectories starting at this state.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#examples-of-ltl-formulas",
    "href": "verification_temporal_logics.html#examples-of-ltl-formulas",
    "title": "Temporal logics",
    "section": "Examples of LTL formulas",
    "text": "Examples of LTL formulas\n\n\\mathbf{G}\\neg \\phi\n\n\n\\mathbf{G}\\mathbf{F} \\phi\n\n\n\\mathbf{F}\\mathbf{G} \\phi\n\n\n\\mathbf{F}(\\phi_1 \\land \\mathbf{X}\\mathbf{F}\\phi_2)",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#ctl-ctl-mixed-with-ltl-supports-branching",
    "href": "verification_temporal_logics.html#ctl-ctl-mixed-with-ltl-supports-branching",
    "title": "Temporal logics",
    "section": "CTL* (CTL mixed with LTL) supports branching",
    "text": "CTL* (CTL mixed with LTL) supports branching\n\nExistential quantifiers needed\n\n\\mathbf{A}: For all\n\\mathbf{E}: There exists",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#literature",
    "href": "verification_temporal_logics.html#literature",
    "title": "Temporal logics",
    "section": "Literature",
    "text": "Literature\n\nLin, Hai, and Panos J. Antsaklis. Hybrid Dynamical Systems: Fundamentals and Methods. Advanced Textbooks in Control and Signal Processing. Cham: Springher, 2022. Chapter 3.\nMitra, Sayan. Verifying Cyber-Physical Systems: A Path to Safe Autonomy. Cyber Physical Systems Series. Cambridge, MA, USA: MIT Press, 2021. https://sayanmitracode.github.io/cpsbooksite/about.html.\nBaier, Christel, and Joost-Pieter Katoen. Principles of Model Checking. Cambridge, MA, USA: MIT Press, 2008.\nClarke, Edmund M., Jr, Orna Grumberg, Daniel Kroening, Doron Peled, and Helmut Veith. Model Checking. 2nd ed. Cyber Physical Systems Series. Cambridge, MA, USA: MIT Press, 2018.\nMurray, Richard M, Ufuk Topcu, and Nok Wongpiromsarn. ‘Lecture 3 Linear Temporal Logic (LTL)’. Lecture presented at the EECI-IGSC, Belgrade (Serbia), 9 March 2020. http://www.cds.caltech.edu/~murray/courses/eeci-sp2020/L3_ltl-09Mar2020.pdf.\nWongpiromsarn, Nok, Richard M. Murray, and Ufuk Topcu. ‘Lecture 4 Model Checking and Logic Synthesis’. Lecture presented at the EECI-IGSC, Belgrade (Serbia), 9 March 2020. http://www.cds.caltech.edu/~murray/courses/eeci-sp2020//L4_model_checking-09Mar2020.pdf.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "max_plus_references.html",
    "href": "max_plus_references.html",
    "title": "Literature",
    "section": "",
    "text": "One last time in this course we refer to Cassandras and Lafortune (2021), a comprehensive and popular introduction do discrete event systems. A short introduction to the framework (max,+) algebra can be found (under the somewhat less known name “Dioid algebras”) in Chapter 5.4.\nBut as a recommendable alternative, (any one of) the a series of papers by Bart de Schutter (TU Delft) and his colleagues can be read instead. For example De Schutter et al. (2020) and De Schutter and van den Boom (2000).\nFor anyone interested in learning yet more, a beautiful (and freely online) book is Baccelli et al. (2001), which we have also mentioned in the context of Petri nets.\nMax-plus algebra is relevant outside the domain of discrete-event systems – it is also investigated in optimization for its connection with piecewise linear/affine functions. Note that the community prefers using the name tropical geometry (to emphasise that they view it as a branch of algebraic geometry). A lovely tutorial is Rau (2017).\n\n\n\n\n Back to topReferences\n\nBaccelli, François, Guy Cohen, Geert Jan Olsder, and Jean-Pierre Quadrat. 2001. Synchronization and Linearity: An Algebra for Discrete Event Systems. Web edition. Chichester: Wiley. https://www.rocq.inria.fr/metalau/cohen/documents/BCOQ-book.pdf.\n\n\nCassandras, Christos G., and Stéphane Lafortune. 2021. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer. https://doi.org/10.1007/978-3-030-72274-6.\n\n\nDe Schutter, Bart, and Ton van den Boom. 2000. “Model Predictive Control for Max-Plus-Linear Discrete-Event Systems: Extended Report & Addendum.” Technical Report bds:99-10a. Delft, The Netherlands: Delft University of Technology. https://pub.deschutter.info/abs/99_10a.html.\n\n\nDe Schutter, Bart, Ton van den Boom, Jia Xu, and Samira S. Farahani. 2020. “Analysis and Control of Max-Plus Linear Discrete-Event Systems: An Introduction.” Discrete Event Dynamic Systems 30 (1): 25–54. https://doi.org/10.1007/s10626-019-00294-w.\n\n\nRau, Johannes. 2017. “A First Expedition to Tropical Geometry.” https://www.math.uni-tuebingen.de/user/jora/downloads/FirstExpedition.pdf.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Literature"
    ]
  },
  {
    "objectID": "solution_references.html",
    "href": "solution_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "7. Solution",
      "Literature"
    ]
  },
  {
    "objectID": "classes_switched.html",
    "href": "classes_switched.html",
    "title": "Switched systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Switched systems"
    ]
  },
  {
    "objectID": "verification_reachability.html",
    "href": "verification_reachability.html",
    "title": "Reachability",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "12. Formal verification",
      "Reachability"
    ]
  },
  {
    "objectID": "verification_barrier.html",
    "href": "verification_barrier.html",
    "title": "Barrier certificates",
    "section": "",
    "text": "This is another technique for verification of safety of hybrid system. Unlike the optimal-control based and set-propagation based techniques, it is not based on explicit computational characterization of the evolution of states in time. Instead, it is based on searching for a function of a state that satisfies certain properties. The function is called a barrier function and it serves as a certificate of safety.\nFor notational and conceptual convenience we start with an explanation of the method for continuous systems, and only then we extend it to hybrid systems.",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#barrier-certificate-for-continuous-systems",
    "href": "verification_barrier.html#barrier-certificate-for-continuous-systems",
    "title": "Barrier certificates",
    "section": "Barrier certificate for continuous systems",
    "text": "Barrier certificate for continuous systems\nWe consider a continuous-time dynamical system modelled by \n\\dot{\\bm x}(t) = \\mathbf f(\\bm x, \\bm d),\n where \\bm d represents an uncertainy in the system description – it can be an uncertain parameter or an external disturbance acting on the system.\nWe now define two regions of the state space:\n\nthe set of initial states \\mathcal X_0,\nand the set of unsafe states \\mathcal X_\\mathrm{u}.\n\nOur goal is to prove (certify) that the system does not reach the unsafe states for an arbitrary initial state \\bm x(0)\\in \\mathcal X_0 and for an arbitrary d\\in \\mathcal D.\nWe define a barrier function B(\\bm x) with the following three properties\nB(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u},\nB(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0,\n\\nabla B(\\bm x)^\\top \\mathbf f(\\bm x, \\bm d) \\leq 0,\\quad \\forall \\bm x, \\bm d \\, \\text{such that} \\, B(\\bm x) = 0.\nNow, upon finding a function B(\\bm x) with such properties, we will prove (certify) safety of the system – the function serves as a certificate of safety.\n\n\n\n\n\n\nNote\n\n\n\nIt cannot go unnoticed that the properties of a barrier function B(\\bm x) and the motivation for its finding resemble those of a Lyapunov function. Indeed, the two concepts are related. But they are not the same.\n\n\nHow do we find such function? We will reuse the computational technique based on sum-of-squares (SOS) polynomials that we already used for Lyapunov functions. But first we need to handle one unpleasant aspect of the third condition above – nonconvexity of the set given by B(\\bm x) = 0.",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#convex-relaxation-of-the-barrier-certificate-problem",
    "href": "verification_barrier.html#convex-relaxation-of-the-barrier-certificate-problem",
    "title": "Barrier certificates",
    "section": "Convex relaxation of the barrier certificate problem",
    "text": "Convex relaxation of the barrier certificate problem\nWe relax the third condition so that it holds not only at B(\\bm x) = 0 but everywhere. The three conditions are then B(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u},\nB(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0,\n\\nabla B(\\bm x)^\\top \\mathbf f(\\bm x, \\bm d) \\leq 0,\\quad \\forall \\bm x\\in \\mathcal X, \\bm d \\in \\mathcal D.\nLet’s now demonstrate this by means of an example.\n\nExample 1 Consider the system modelled by \n\\begin{aligned}\n\\dot x_1 &= x_2\\\\\n\\dot x_2 &= -x_1 + \\frac{p}{3}x_1^3 - x_2,\n\\end{aligned}\n where the parameter p\\in [0.9,1.1].\nThe initial set is given by \n\\mathcal X_0 = \\{ \\bm x \\in \\mathbb R^2 \\mid (x_1-1.5)^2 + x_2^2 \\leq 0.25 \\}\n and the unsafe set is given by \n\\mathcal X_\\mathrm{u} = \\{ \\bm x \\in \\mathbb R^2 \\mid (x_1+1)^2 + (x_2+1)^2 \\leq 0.16 \\}.\n\nThe vector field \\mathbf f and the initial and unsafe sets are shown in the figure below.\n\n\nCode\nusing SumOfSquares\nusing DynamicPolynomials\nusing MosekTools    \n\noptimizer = optimizer_with_attributes(Mosek.Optimizer, MOI.Silent() =&gt; true)\nmodel = SOSModel(optimizer)\n@polyvar x[1:2] \n\np = 1;\n\nf = [ x[2],\n     -x[1] + (p/3)*x[1]^3 - x[2]]\n\ng₁ = -(x[1]+1)^2 - (x[2]+1)^2 + 0.16  # 𝒳ᵤ = {x ∈ R²: g₁(x) ≥ 0}\nh₁ = -(x[1]-1.5)^2 - x[2]^2 + 0.25    # 𝒳₀ = {x ∈ R²: h₁(x) ≥ 0}\n\nX = monomials(x, 0:4)\n@variable(model, B, Poly(X))\n\nε = 0.001\n@constraint(model, B &gt;= ε, domain = @set(g₁ &gt;= 0))\n\n@constraint(model, B &lt;= 0, domain = @set(h₁ &gt;= 0))\n\nusing LinearAlgebra # Needed for `dot`\ndBdt = dot(differentiate(B, x), f)\n@constraint(model, -dBdt &gt;= 0)\n\nJuMP.optimize!(model)\n\nJuMP.primal_status(model)\n\nimport DifferentialEquations, Plots, ImplicitPlots\nfunction phase_plot(f, B, g₁, h₁, quiver_scaling, Δt, X0, solver = DifferentialEquations.Tsit5())\n    X₀plot = ImplicitPlots.implicit_plot(h₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"X₀\", linecolor=:blue)\n    Xᵤplot = ImplicitPlots.implicit_plot!(g₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"Xᵤ\", linecolor=:teal)\n    Bplot  = ImplicitPlots.implicit_plot!(B; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"B = 0\", linecolor=:red)\n    Plots.plot(X₀plot)\n    Plots.plot!(Xᵤplot)\n    Plots.plot!(Bplot)\n    ∇(vx, vy) = [fi(x[1] =&gt; vx, x[2] =&gt; vy) for fi in f]\n    ∇pt(v, p, t) = ∇(v[1], v[2])\n    function traj(v0)\n        tspan = (0.0, Δt)\n        prob = DifferentialEquations.ODEProblem(∇pt, v0, tspan)\n        return DifferentialEquations.solve(prob, solver, reltol=1e-8, abstol=1e-8)\n    end\n    ticks = -5:0.5:5\n    X = repeat(ticks, 1, length(ticks))\n    Y = X'\n    Plots.quiver!(X, Y, quiver = (x, y) -&gt; ∇(x, y) / quiver_scaling, linewidth=0.5)\n    for x0 in X0\n        Plots.plot!(traj(x0), vars=(1, 2), label = nothing)\n    end\n    Plots.plot!(xlims = (-2, 3), ylims = (-2.5, 2.5))\nend\n\nphase_plot(f, value(B), g₁, h₁, 10, 30.0, [[x1, x2] for x1 in 1.2:0.2:1.7, x2 in -0.35:0.1:0.35])\n\n\nPrecompiling DifferentialEquations\n  ✓ StatsFuns → StatsFunsInverseFunctionsExt\n  ✓ RandomNumbers\n  ✓ Random123\n  ✓ DiffEqBase → DiffEqBaseDistributionsExt\n  ✓ JumpProcesses\n  ✓ DiffEqNoiseProcess\n  ✓ StochasticDiffEq\n  ✓ DifferentialEquations\n  8 dependencies successfully precompiled in 14 seconds. 227 already precompiled.\n┌ Warning: To maintain consistency with solution indexing, keyword argument vars will be removed in a future version. Please use keyword argument idxs instead.\n│   caller = ip:0x0\n└ @ Core :-1\n┌ Warning: At t=4.42311829094011, dt was forced below floating point epsilon 8.881784197001252e-16, and step error estimate = 1.139012671019052. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/hq1ku/src/integrator_interface.jl:600",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#barrier-certificate-for-hybrid-systems",
    "href": "verification_barrier.html#barrier-certificate-for-hybrid-systems",
    "title": "Barrier certificates",
    "section": "Barrier certificate for hybrid systems",
    "text": "Barrier certificate for hybrid systems\nFor a hybrid automaton with l locations \\{q_1,q_2,\\ldots,q_l\\}, not just one but l barrier functions/certificates are needed:\nB_i(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u}(q_i),\nB_i(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0(q_i),\n\\nabla B_i(\\bm x)^\\top \\mathbf f_i(\\bm x, \\bm u) \\leq 0,\\quad \\forall \\bm x, \\bm u \\, \\text{such that} \\, B_i(\\bm x) = 0,\n\n\\begin{aligned}\nB_i(\\bm x) \\leq 0,\\quad &\\forall \\bm x \\in \\mathcal R(q_j,q_i,\\bm x^-)\\,\\text{for some}\\, q_j\\,\\\\\n&\\text{and}\\, \\bm x^-\\in\\mathcal G(q_j,q_i)\\,\\text{with}\\, B_j(\\bm x^-)\\leq 0.\n\\end{aligned}",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#convex-relaxation-of-barrier-certificates-for-hybrid-systems",
    "href": "verification_barrier.html#convex-relaxation-of-barrier-certificates-for-hybrid-systems",
    "title": "Barrier certificates",
    "section": "Convex relaxation of barrier certificates for hybrid systems",
    "text": "Convex relaxation of barrier certificates for hybrid systems\n\\nabla B_i(\\bm x)^\\top \\mathbf f_i(\\bm x, \\bm u) \\leq 0,\\quad \\forall \\bm x\\in X_0(q_i), \\bm u\\in\\mathcal U(q_i),\n\n\\begin{aligned}\nB_i(\\bm x) \\leq 0,\\quad &\\forall (\\bm x, \\bm x^-)\\,\\text{such that}\\, \\bm x \\in \\mathcal R(q_j,q_i,\\bm x^-), \\\\\n&\\text{and}\\, \\bm x^-\\in\\mathcal G(q_i,q_j).\n\\end{aligned}",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "mld_references.html",
    "href": "mld_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Literature"
    ]
  },
  {
    "objectID": "mpc_mld_online.html",
    "href": "mpc_mld_online.html",
    "title": "Online MPC for hybrid systems",
    "section": "",
    "text": "First, we need to set the cost function for the optimal control problem. As usual in optimal control, we want to impose different weights on invididual state and control variables. The most popular is the quadratic cost function well known from the LQ-optimal control\n\\[\nJ_0(x(0),U_0) = x_N^T S_N x_N + \\sum_{k=0}^{N-1} \\left( x_k^T Q x_k + u_k^T R u_k \\right)\n\\]\nBut other (weighted) norms can also be used, in particular 1-norm and infinity-norm\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_1 + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_1 + \\|R u_k\\|_1 \\right),\n\\]\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_{\\infty} + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_{\\infty} + \\|R u_k\\|_{\\infty} \\right).\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_online.html#optimal-control-on-a-finite-horizon",
    "href": "mpc_mld_online.html#optimal-control-on-a-finite-horizon",
    "title": "Online MPC for hybrid systems",
    "section": "",
    "text": "First, we need to set the cost function for the optimal control problem. As usual in optimal control, we want to impose different weights on invididual state and control variables. The most popular is the quadratic cost function well known from the LQ-optimal control\n\\[\nJ_0(x(0),U_0) = x_N^T S_N x_N + \\sum_{k=0}^{N-1} \\left( x_k^T Q x_k + u_k^T R u_k \\right)\n\\]\nBut other (weighted) norms can also be used, in particular 1-norm and infinity-norm\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_1 + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_1 + \\|R u_k\\|_1 \\right),\n\\]\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_{\\infty} + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_{\\infty} + \\|R u_k\\|_{\\infty} \\right).\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_online.html#optimization-problem",
    "href": "mpc_mld_online.html#optimization-problem",
    "title": "Online MPC for hybrid systems",
    "section": "Optimization problem",
    "text": "Optimization problem\nCombining the cost function with the MLD model, and perhaps we some extra constraints imposed on the control inputs as well as state variables, we get \\[\n\\operatorname*{minimize}_{u_0, u_1, \\ldots, u_{N-1}} J_0(x(0),(u_0, u_1, \\ldots, u_{N-1}))\n\\]\nsubject to \\[\n\\begin{aligned}\nx_{k+1} &= Ax_k + B_u u_k + B_\\delta\\delta_k + B_z z_k + B_0\\\\\ny_k &= Cx_k + D_u u_k + D_\\delta \\delta_k + D_z z_k + D_0\\\\\nE_\\delta \\delta_k &+ E_z z_k \\leq E_u u_k + E_x x_k + E_0 \\\\\nu_{\\min} &\\leq u_k \\leq u_{\\max} \\\\\nx_{\\min} &\\leq x_k \\leq x_{\\max} \\\\\nP x_N &\\leq r \\\\\nx_0 &= x(0)\n\\end{aligned}\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "B(E)3M35HYS – Hybrid systems",
    "section": "",
    "text": "This website constitutes the lecture notes for the graduate course Hybrid Systems (B3M35HYS, BE3M35HYS) taught within Cybernetics and Robotics graduate program at Faculty of Electrical Engineering, Czech Technical University in Prague.\nOrganizational instructions, description of grading policy, assignments of homework problems and other course related material relevant for officially enrolled students are located elsewhere (the course page within the FEL Moodle).\n\n\n\n Back to top"
  },
  {
    "objectID": "petri_nets_software.html",
    "href": "petri_nets_software.html",
    "title": "Software",
    "section": "",
    "text": "Petri Net Toolbox (probably commercial, not immediately available for download)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Software"
    ]
  },
  {
    "objectID": "petri_nets_software.html#matlab",
    "href": "petri_nets_software.html#matlab",
    "title": "Software",
    "section": "",
    "text": "Petri Net Toolbox (probably commercial, not immediately available for download)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Software"
    ]
  },
  {
    "objectID": "petri_nets_software.html#python",
    "href": "petri_nets_software.html#python",
    "title": "Software",
    "section": "Python",
    "text": "Python\nSNAKES (github)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Software"
    ]
  },
  {
    "objectID": "petri_nets_software.html#julia",
    "href": "petri_nets_software.html#julia",
    "title": "Software",
    "section": "Julia",
    "text": "Julia\nPetri.jl AlgebraicPetri.jl TimedPetriNetEditor.jl",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Software"
    ]
  },
  {
    "objectID": "petri_nets_software.html#standalone",
    "href": "petri_nets_software.html#standalone",
    "title": "Software",
    "section": "Standalone",
    "text": "Standalone\nTimedPetriNetEditor pn-editor (It uses pnrs, a safe rust wrapper for pns written in C)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Software"
    ]
  },
  {
    "objectID": "complementarity_constraints.html",
    "href": "complementarity_constraints.html",
    "title": "Complementarity constraints",
    "section": "",
    "text": "Yet another framework for modelling hybrid systems, which comes with a rich theory and efficient algorithms, is based on complementaristy constraints. Before we introduce that modelling framework in the next section, we first explain the very concept of complementarity constraints.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#why-complementarity-constraints",
    "href": "complementarity_constraints.html#why-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "",
    "text": "Yet another framework for modelling hybrid systems, which comes with a rich theory and efficient algorithms, is based on complementaristy constraints. Before we introduce that modelling framework in the next section, we first explain the very concept of complementarity constraints.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#definition-of-complementarity-constraints",
    "href": "complementarity_constraints.html#definition-of-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "Definition of complementarity constraints",
    "text": "Definition of complementarity constraints\nTwo variables x\\in\\mathbb R and y\\in\\mathbb R satisfy the complementarity constraint if x or y is equal to zero and both are nonnegative\nxy=0, \\; x\\geq 0,\\; y\\geq 0,\nor, using a dedicated compact notation:\n\\boxed{0\\leq x \\perp y \\geq 0.}\n\n\n\n\n\n\nBoth variables can be zero\n\n\n\nThe or in the above definition is not exclusive, therefore it is possible that both x and y are zero.\n\n\nThe concept and notation extends to vectors x\\in\\mathbb R^n and y\\in\\mathbb R^n, in which case the constraint is interpreted componentwise \\boxed{\\bm 0\\leq \\bm x \\perp \\bm y \\geq \\bm 0.}",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#geometric-interpretation-of-complementarity-constraints",
    "href": "complementarity_constraints.html#geometric-interpretation-of-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "Geometric interpretation of complementarity constraints",
    "text": "Geometric interpretation of complementarity constraints\nThe set of admissible pairs (x,y) in the \\mathbb R^2 plane is constrained to the L-shaped subset given by the nonnegative x and y semi-axes (including the origin). The set is obviously nonconvex.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "verification_intro.html",
    "href": "verification_intro.html",
    "title": "What is verification?",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "12. Formal verification",
      "What is verification?"
    ]
  },
  {
    "objectID": "des_automata.html",
    "href": "des_automata.html",
    "title": "(State) automata",
    "section": "",
    "text": "Having just discussed the concept of a discrete-event system, we now introduce the most popular modeling framework for such systems: a state automaton, or just an automaton (plural automata). It is also known as a state machine or a (discrete) transition system.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#marked-states",
    "href": "des_automata.html#marked-states",
    "title": "(State) automata",
    "section": "Marked states",
    "text": "Marked states\nIn some literature, the definition of the automaton also includes a set \\mathcal X_\\mathrm{m} \\subseteq \\mathcal X of marked or accepting states, in which case the definition of an automaton now includes three (sub)sets of states: \\mathcal X, \\mathcal X_0 and \\mathcal X_\\mathrm{m}. \\boxed{\nG = \\{\\mathcal X,\\mathcal X_0,\\mathcal E,\\mathcal F, \\mathcal X_\\mathrm{m}\\}.}\n\nThe marked states are just some states with special roles in the system. Namely, these are the states into which the system should be controlled. I do not particularly like this idea of mixing the model of the system with the requirements, but some part of the community likes it this way.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automaton-as-a-digraph-also-a-state-transition-diagram",
    "href": "des_automata.html#automaton-as-a-digraph-also-a-state-transition-diagram",
    "title": "(State) automata",
    "section": "Automaton as a (di)graph (also a state transition diagram)",
    "text": "Automaton as a (di)graph (also a state transition diagram)\nSo far the definition of an automaton was not particularly visual. This can be changes by viewing the automaton as a directed graph (digraph) with. Thesa are the basic rules\n\nState is represented as a node of the graph.\nTransition from a given state to another state is represented as an edge connecting the two nodes.\nEvents (actions) are the labels attached to the edges. It is not necessary that each edge has its unique label.\n\n\nExample 1 (Automaton as a digraph) Consider an automaton defined by these sets: \\mathcal X = \\{x_1,x_2,x_3\\}, \\mathcal X_0 = \\{x_1\\}, \\mathcal E = \\{e_1,e_2,e_3\\}, \\mathcal F = \\{(x_1,e_1,x_2),(x_2,e_2,x_1),(x_1,e_3,x_3),(x_2,e_2,x_3)\\}.\nThe corresponding digraph is in Figure 1.\n\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nx₁\n\nx₁\n\n\n\ninit-&gt;x₁\n\n\n\n\n\nx₂\n\nx₂\n\n\n\nx₁-&gt;x₂\n\n\ne₁\n\n\n\nx₃\n\nx₃\n\n\n\nx₁-&gt;x₃\n\n\ne₂\n\n\n\nx₂-&gt;x₁\n\n\ne₂\n\n\n\nx₂-&gt;x₃\n\n\ne₃\n\n\n\n\n\n\nFigure 1: An example automaton as a digraph\n\n\n\n\n\n\nWe may encounter the following term\n\nDefinition 2 (Active event function and set) Active event function (actually a multivalued function) \\Gamma: \\mathcal X \\rightarrow 2^\\mathcal{E} assigns to each state a set of active events. Active event set \\Gamma(x) is the set of active events in a particular state x.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#finite-state-automaton-fsa",
    "href": "des_automata.html#finite-state-automaton-fsa",
    "title": "(State) automata",
    "section": "Finite state automaton (FSA)",
    "text": "Finite state automaton (FSA)\n\nFinite set \\mathcal X of states.\nAlso: Finite state machine (FSM).\n\n\nRather superfluous definition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#execution-of-an-automaton",
    "href": "des_automata.html#execution-of-an-automaton",
    "title": "(State) automata",
    "section": "Execution of an automaton",
    "text": "Execution of an automaton\n\nx_1\\xrightarrow{e_1} x_2\\xrightarrow{e_2} x_1 \\xrightarrow{e_1} x_2 \\xrightarrow{e_4} x_3\\ldots\nSometimes also written as x_1,e_1,x_2,e_2,\\ldots\n\n\n\n\n\n\n\n\nNotational confusion\n\n\n\nx_k for some k is the name of a particular state. It is not the name of a (yet to be introduced) state variable; In fact, it can be viewed of its value (also valuation).\n\n\n\nSome authors strictly distinguish between the state variable and the state (variable valuation),\n\nsimilarly as in probability theory random variable X vs its value x, as in F(x) = P(X\\leq x);\n\nsome do not, but then it may lead to confusion;\nyet some others avoid the problem by not introducing state variables and only working with enumerated states.\n\n\n\n\n\n\n\n\nNotational confusion 2\n\n\n\nEven worse, it is also tempting to interpret the lower index k as (discrete) time, but nope, in the previous k is not the time index.\nAgain, some authors do not distinguish…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#path-of-an-automaton",
    "href": "des_automata.html#path-of-an-automaton",
    "title": "(State) automata",
    "section": "Path of an automaton",
    "text": "Path of an automaton\nCorresponding to the execution\nx_1\\xrightarrow{e_1} x_2\\xrightarrow{e_2} x_1 \\xrightarrow{e_1} x_2 \\xrightarrow{e_4} x_3\\ldots\nthe path is just the sequence of visited states:\nx_1,x_2,x_1,x_2,x_3,\\ldots\n\nIn continuous-valued dynamical systems, we have a state trajectory, but then time stamps are attached to each visited state.\n\n\nExample 2 (Beverage vending machine)  \n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nwaiting\n\nwaiting\n\n\n\ninit-&gt;waiting\n\n\n\n\n\nswiped\n\nswiped\n\n\n\nwaiting-&gt;swiped\n\n\nswipe card\n\n\n\nswiped-&gt;waiting\n\n\nreject payment\n\n\n\npaid\n\npaid\n\n\n\nswiped-&gt;paid\n\n\naccept payment\n\n\n\ncoke_dispensed\n\ncoke_dispensed\n\n\n\npaid-&gt;coke_dispensed\n\n\nchoose coke\n\n\n\nfanta_dispensed\n\nfanta_dispensed\n\n\n\npaid-&gt;fanta_dispensed\n\n\nchoose fanta\n\n\n\ncoke_dispensed-&gt;waiting\n\n\ntake coke\n\n\n\nfanta_dispensed-&gt;waiting\n\n\ntake fanta\n\n\n\n\n\n\n\n\n\nState sequence (path): waiting, swiped, paid, coke_dispensed, waiting\nEvents sequence: swipe card, accept payment, choose coke, take coke\n\n\n\n\nIndeed, the two states coke_dispensed and fanta_dispensed can be merged into just beverage_dispensed.\nHow about other paths? Longer? Shorter?",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-beverage-vending-machine",
    "href": "des_automata.html#example-beverage-vending-machine",
    "title": "(State) automata",
    "section": "Example: Beverage vending machine",
    "text": "Example: Beverage vending machine\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nwaiting\n\n\nwaiting\n\n\n\ninit-&gt;waiting\n\n\n\n\n\nswiped\n\nswiped\n\n\n\nwaiting-&gt;swiped\n\n\nswipe card\n\n\n\nswiped-&gt;waiting\n\n\nreject payment\n\n\n\npaid\n\npaid\n\n\n\nswiped-&gt;paid\n\n\naccept payment\n\n\n\ncoke_dispensed\n\ncoke_dispensed\n\n\n\npaid-&gt;coke_dispensed\n\n\nchoose coke\n\n\n\nfanta_dispensed\n\nfanta_dispensed\n\n\n\npaid-&gt;fanta_dispensed\n\n\nchoose fanta\n\n\n\ncoke_dispensed-&gt;waiting\n\n\ntake coke\n\n\n\nfanta_dispensed-&gt;waiting\n\n\ntake fanta\n\n\n\n\n\n\n\n\nThe waiting state can be marked (is accepting).\n\nExample 3 (Longitudinal control of a ground vehicle)  \n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nstill\n\nstill\n\n\n\ninit-&gt;still\n\n\n\n\n\naccelerating\n\naccelerating\n\n\n\nstill-&gt;accelerating\n\n\npush acc\n\n\n\ncruising\n\ncruising\n\n\n\naccelerating-&gt;cruising\n\n\ncruise ON\n\n\n\ncoasting\n\ncoasting\n\n\n\naccelerating-&gt;coasting\n\n\nrel acc\n\n\n\ncruising-&gt;accelerating\n\n\npush acc\n\n\n\ncruising-&gt;coasting\n\n\nrel acc\n\n\n\nbraking\n\nbraking\n\n\n\ncruising-&gt;braking\n\n\npush brake\n\n\n\ncoasting-&gt;braking\n\n\npush brake\n\n\n\nbraking-&gt;still\n\n\nzero vel\n\n\n\nbraking-&gt;cruising\n\n\ncruise ON\n\n\n\nbraking-&gt;coasting\n\n\nrel brake\n\n\n\n\n\n\n\n\n\n\n\nBy cruise on I mean switching on some kind of a cruise control system, which keeps the velocity constant.\nIt turns out the optimal control strategy for trains (under some circumstances).\nNote that some of the events are indeed actions started by the driver, but some are just coming from the physics of the vehicle (transition from braking to zero velocity).\n\n\n\nExample 4 (Corridor switch)  \n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\nswitch₁,switch₂\n\n\n\nON-&gt;OFF\n\n\nswitch₁,switch₂\n\n\n\n\n\n\n\n\n\nTwo events associated with one transitions can be seen as two transitions, each with a single event, both sharing the starting and ending states.\n\n\n\nExample 5 (Double intensity switching)  \n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\npush\n\n\n\nON-&gt;OFF\n\n\npush\n\n\n\nON2\n\nON2\n\n\n\nON-&gt;ON2\n\n\npush\n\n\n\nON2-&gt;OFF\n\n\npush\n\n\n\n\n\n\n\n\n\nObviously we need to introduce time into the automaton…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-as-the-value-of-a-state-variable",
    "href": "des_automata.html#state-as-the-value-of-a-state-variable",
    "title": "(State) automata",
    "section": "State as the value of a state variable",
    "text": "State as the value of a state variable\n\nDefinition of the state space by enumeration doesn’t scale well.\nState can be characterized as the value (sometimes also valuation) of a state variable.\nState variable x is given by\n\nthe name,\nthe “type” (boolean, integer, vector, …).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#examples-of-state-variables",
    "href": "des_automata.html#examples-of-state-variables",
    "title": "(State) automata",
    "section": "Examples of state variables",
    "text": "Examples of state variables\n\nCorridor switch: x \\in \\{\\mathrm{false},\\mathrm{true}\\} (also \\{0,1\\}).\nDouble intensity switching:\n\nx \\in \\{0,1,2\\} \\subset \\mathbb Z,\nor \\bm x = \\begin{bmatrix}x_1\\\\ x_2 \\end{bmatrix}, where x_1,x_2 \\in \\{0,1\\}.\n\n\n\n\nValuation is the value of a variable in a particular state.\nIt is not necessarily only numeric.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-transition-equation",
    "href": "des_automata.html#state-transition-equation",
    "title": "(State) automata",
    "section": "State (transition) equation",
    "text": "State (transition) equation\n\\boxed{x^+ = f(x,e)}\n\nUpon introduction of discrete-time (index) k x_{k+1} = f(x_k,e_k)\nor x[k+1] = f(x[k],e[k]).\n\n\n\nThe function f can be defined by a computer code rather than a clean mathematical formula.\nThe discrete-time index of the event is sometimes considered shifted, that is $x_{k+1} = f(x_k,e_{k+1}).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extension-moore-machine",
    "href": "des_automata.html#extension-moore-machine",
    "title": "(State) automata",
    "section": "Extension: Moore machine",
    "text": "Extension: Moore machine\n\nAutomaton with state outputs.\nOutput function assigns outputs to the states y = g(x).\nThe output is produced (emitted) when the (new) state is entered.\nThe output does not depend on the input. When plugged into feedback, no algebraic loops.\n\n\nExample 6 (Moore machine)  \n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nclosed\n\nNO FLOW\nValve\nclosed\n\n\n\ninit-&gt;closed\n\n\n\n\n\npartial\n\nFLOW\nValve\npartially\nopen\n\n\n\nclosed-&gt;partial\n\n\nopen valve one turn\n\n\n\npartial-&gt;closed\n\n\nclose valve one turn\n\n\n\nfull\n\nFLOW\nValve\nfully open\n\n\n\npartial-&gt;full\n\n\nopen valve one turn\n\n\n\nfull-&gt;closed\n\n\nemergency shut off\n\n\n\nfull-&gt;partial\n\n\nclose valve one turn\n\n\n\n\n\n\n\n\nThe outputs are the labels of the states.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extension-mealy-machine",
    "href": "des_automata.html#extension-mealy-machine",
    "title": "(State) automata",
    "section": "Extension: Mealy machine",
    "text": "Extension: Mealy machine\n\nAutomaton with input/output transition labels.\nThe transition label e_\\mathrm{i}/e_\\mathrm{o} on the transion from x_1 to x_2 reads as “the input event e_\\mathrm{i} at state x_1 activates the transition to x_2, which outputs the event e_\\mathrm{o}”. x_1\\xrightarrow{e_\\mathrm{i}/e_\\mathrm{o}} x_2\nIt can be viewed as if the output function also considers the input and not only the state y = e_\\mathrm{o} = g(x,e_\\mathrm{i}).\nThe output is produced (emitted) during the transition (before the new state is entered).\n\n\nExample 7 (Mealy machine) Coffee machine: coffee for 30 CZK, machine accepting 10 and 20 CZK coins, no change.\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\nNo coin\n\n\n\ninit-&gt;0\n\n\n\n\n\n10\n\n10 CZK\n\n\n\n0-&gt;10\n\n\ninsert 10 CZK / no coffee\n\n\n\n20\n\n20 CZK\n\n\n\n0-&gt;20\n\n\ninsert 20 CZK / no coffee\n\n\n\n10-&gt;0\n\n\ninsert 20 CZK / coffee\n\n\n\n10-&gt;20\n\n\ninsert 10 CZK / no coffee\n\n\n\n20-&gt;0\n\n\ninsert 10 CZK / coffee\n\n\n\n20-&gt;10\n\n\ninsert 20 CZK / coffee",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#reformulate-the-previous-example-as-a-moore-machine",
    "href": "des_automata.html#reformulate-the-previous-example-as-a-moore-machine",
    "title": "(State) automata",
    "section": "Reformulate the previous example as a Moore machine",
    "text": "Reformulate the previous example as a Moore machine\nTwo more states wrt Mealy\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\nNO COFFEE\nNo\ncoin\n\n\n\ninit-&gt;0\n\n\n\n\n\n10\n\nNO COFFEE\n10\nCZK\n\n\n\n0-&gt;10\n\n\ninsert 10 CZK\n\n\n\n20\n\nNO COFFEE\n20\nCZK\n\n\n\n0-&gt;20\n\n\ninsert 20 CZK\n\n\n\n10-&gt;20\n\n\ninsert 10 CZK\n\n\n\n30\n\nCOFFEE\n10+20\nCZK\n\n\n\n10-&gt;30\n\n\ninsert 20 CZK\n\n\n\n20-&gt;30\n\n\ninsert 10 CZK\n\n\n\n40\n\nCOFFEE\n20+20\nCZK\n\n\n\n20-&gt;40\n\n\ninsert 20 CZK\n\n\n\n30-&gt;0\n\n\n\n\n\n30-&gt;10\n\n\ninsert 10 CZK\n\n\n\n30-&gt;20\n\n\ninsert 20 CZK\n\n\n\n40-&gt;10\n\n\n\n\n\n40-&gt;20\n\n\ninsert 10 CZK\n\n\n\n40-&gt;30\n\n\ninsert 20 CZK",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#dijkstra-token-passing",
    "href": "des_automata.html#dijkstra-token-passing",
    "title": "(State) automata",
    "section": "Dijkstra token passing",
    "text": "Dijkstra token passing\n\n\n\n\n\n\n\nG\n\n\n0\n\n0\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\n\n\n\n3-&gt;0",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#data-type-for-the-state-vector",
    "href": "des_automata.html#data-type-for-the-state-vector",
    "title": "(State) automata",
    "section": "Data type for the state vector",
    "text": "Data type for the state vector\n```{julia}\nstruct DijkstraTokenRing\n    number_of_nodes::Int64\n    max_value_of_state_variable::Int64\n    state_vector::Vector{Int64}\nend\n```",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-update-transition-function",
    "href": "des_automata.html#state-update-transition-function",
    "title": "(State) automata",
    "section": "State update (transition) function",
    "text": "State update (transition) function\n```{julia}\nfunction update!(dtr::DijkstraTokenRing)                        \n    n = dtr.number_of_nodes\n    k = dtr.max_value_of_state_variable\n    x = dtr.state_vector\n    xnext = copy(x)\n1    for i in eachindex(x)\n        if i == 1                                              \n2            xnext[i] = (x[i] == x[n]) ? mod(x[i] + 1,k) : x[i]\n        else                                                    \n3            xnext[i] = (x[i] != x[i-1]) ? x[i-1] : x[i]\n        end\n    end\n    dtr.x .= xnext                                              \nend\n```\n\n1\n\nMind the +1 shift. x[2] corresponds to x₁ in the literature.\n\n2\n\nIncrement if the left neighbour is identical.\n\n3\n\nUpdate by the differing left neighbour.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#output-function",
    "href": "des_automata.html#output-function",
    "title": "(State) automata",
    "section": "Output function",
    "text": "Output function\nIt gives the position of the token.\n```{julia}\nfunction output(dtr::DijkstraTokenRing)\n    x = dtr.state_vector\n    y = similar(x)\n    y[1] = iszero(x[1]-x[end])\n    y[2:end] .= .!iszero.(diff(x))\n    return y\nend\n```",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#section",
    "href": "des_automata.html#section",
    "title": "(State) automata",
    "section": "",
    "text": "n = 4                           # Concrete number of nodes.\nk = n                           # Concrete max value of a state variable (must be &gt;= n).\nx_initial = rand(0:k,n)         # Initial state vector that does not necessarily guarantee acceptability (more than 1 token in the ring).\ndtr = DijkstraTokenRing(n,k,x_initial)\noutput(dtr)                     # Show where the token is (are).\n\nupdate!(dtr), output(dtr)       # Perform the update, show the state vector and show where the token is.\nupdate!(dtr), output(dtr)       # Repeat a few times to see the stabilization.    \nupdate!(dtr), output(dtr)",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extended-state-automaton",
    "href": "des_automata.html#extended-state-automaton",
    "title": "(State) automata",
    "section": "Extended-state automaton",
    "text": "Extended-state automaton\n\nIndeed, the hyphen is there on purpose – we are extending the state space by additional state variables.\nAugmenting the state variable(s) that define the states/modes/locations (in the graph) by additional (typed) state variables: Int, Enum, Bool,…\n\nTransitions are then guarded by conditions on theses extra state variables.\nBesides the guard condition, the transitions is labelled also by a reset function that resets the extended state variables.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-counting-up-to-10",
    "href": "des_automata.html#example-counting-up-to-10",
    "title": "(State) automata",
    "section": "Example: counting up to 10",
    "text": "Example: counting up to 10\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\nint k=0\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\npress\n\n\n\nON-&gt;OFF\n\n\n(press ⋁ k ≥ 10); k=0\n\n\n\nON-&gt;ON\n\n\n(press ∧ k &lt; 10); k=k+1",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-state-machines-in-umlsysml",
    "href": "des_automata.html#automata-state-machines-in-umlsysml",
    "title": "(State) automata",
    "section": "Automata (state machines) in UML/SysML",
    "text": "Automata (state machines) in UML/SysML\n\n\nThey can do hierarchies and more.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-state-machines-in-openmodelica",
    "href": "des_automata.html#automata-state-machines-in-openmodelica",
    "title": "(State) automata",
    "section": "Automata (state machines) in (Open)Modelica",
    "text": "Automata (state machines) in (Open)Modelica",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-in-simulink---stateflow-chart",
    "href": "des_automata.html#automata-in-simulink---stateflow-chart",
    "title": "(State) automata",
    "section": "Automata in Simulink -> Stateflow Chart",
    "text": "Automata in Simulink -&gt; Stateflow Chart",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#composing-automata",
    "href": "des_automata.html#composing-automata",
    "title": "(State) automata",
    "section": "Composing automata",
    "text": "Composing automata\nSynchronization through events: !,?\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n1\n\n1\n\n\n\ninit-&gt;1\n\n\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\npress?\n\n\n\n3\n\n3\n\n\n\n3-&gt;3\n\n\npress!",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#languages-and-automata",
    "href": "des_automata.html#languages-and-automata",
    "title": "(State) automata",
    "section": "Languages and automata",
    "text": "Languages and automata\n\nExtend the transition function: f: \\mathcal X \\times \\mathcal E^\\ast \\rightarrow \\mathcal X, where \\mathcal E^\\ast stands for “all possible sequences of events”.\nLanguage generated by the automaton is \n  \\mathcal L(\\mathcal G) = \\{s\\in\\mathcal E^\\ast \\mid f(x_0,s) \\;\\text{is defined}\\}\n  \nLanguage marked by the automaton (the automaton is accepting or recognizing that language) \n  \\mathcal L_\\mathrm{m}(\\mathcal G) = \\{s\\in\\mathcal L(\\mathcal G) \\mid f(x_0,s) \\in \\mathcal{X}_\\mathrm{m}\\}",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-languaged-accepted-by-automaton",
    "href": "des_automata.html#ex.-languaged-accepted-by-automaton",
    "title": "(State) automata",
    "section": "Ex.: languaged accepted by automaton",
    "text": "Ex.: languaged accepted by automaton\n\n\\mathcal{E} = \\{a,b\\}, \\mathcal{L} = \\{a,aa,ba,aaa,aba,baa,bba,\\ldots\\}\n\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n1\n\n\n1\n\n\n\n1-&gt;1\n\n\na\n\n\n\n1-&gt;0\n\n\nb\n\n\n\n0-&gt;1\n\n\na\n\n\n\n0-&gt;0\n\n\nb\n\n\n\n\n\n\n\n\n\nWhat if we remove the self loop at state 1? The automaton then accepts languages starting with a and endis with a.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#what-is-the-language-view-of-automata-good-for",
    "href": "des_automata.html#what-is-the-language-view-of-automata-good-for",
    "title": "(State) automata",
    "section": "What is the “language view of automata” good for?",
    "text": "What is the “language view of automata” good for?\n\nDefinitions, analysis, synthesis.\nWe then need language concepts such as\n\nconcatenation of strings: \\quad c = ab\nempty string \\varepsilon: \\quad\\varepsilon a = a \\varepsilon = a\nprefix, suffix\nprefix closure \\bar{\\mathcal{L}} (of the language \\mathcal L)\n…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#blocking",
    "href": "des_automata.html#blocking",
    "title": "(State) automata",
    "section": "Blocking",
    "text": "Blocking\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n2\n\n\n2\n\n\n\n2-&gt;0\n\n\ng\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\na\n\n\n\n1-&gt;2\n\n\nb\n\n\n\n5\n\n5\n\n\n\n1-&gt;5\n\n\ng\n\n\n\n3\n\n3\n\n\n\n1-&gt;3\n\n\na\n\n\n\n4\n\n4\n\n\n\n3-&gt;4\n\n\nb\n\n\n\n4-&gt;3\n\n\na\n\n\n\n4-&gt;4\n\n\ng\n\n\n\n\n\n\n\n\n\nDeadlock at state 2. Livelock at states 3 and 4.\n\\bar{\\mathcal{L}}_\\mathrm{m}(\\mathcal G) \\sub \\mathcal L(\\mathcal G).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-systems",
    "href": "des_automata.html#queueing-systems",
    "title": "(State) automata",
    "section": "Queueing systems",
    "text": "Queueing systems\n\nentities (also customers, jobs, tasks, requests, etc.)\nresources (also servers, processors, etc.): customers are waiting for them\nqueues (also buffers): where waiting is done\n\n. . .",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#examples-of-queueing-systems",
    "href": "des_automata.html#examples-of-queueing-systems",
    "title": "(State) automata",
    "section": "Examples of queueing systems",
    "text": "Examples of queueing systems\n\nentities: people waiting for service in a bank or at a bust stop\nresources: people (again) in a bank at the counter\nqueues: bank lobbies, bus stops, warehouses, …\n\n\nWhat are other examples? - entities: packets, … - resources: processor, computer periphery, router, … - queues: …",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#why-study",
    "href": "des_automata.html#why-study",
    "title": "(State) automata",
    "section": "Why study?",
    "text": "Why study?\n\nResources are not unlimited\nTradeoff needed between customer satisfaction and fair resources allocation",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#networks-of-queueing-systems",
    "href": "des_automata.html#networks-of-queueing-systems",
    "title": "(State) automata",
    "section": "Networks of queueing systems",
    "text": "Networks of queueing systems",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-systems-as-automata",
    "href": "des_automata.html#queueing-systems-as-automata",
    "title": "(State) automata",
    "section": "Queueing systems as automata",
    "text": "Queueing systems as automata\n\nevents: \\mathcal E = \\{\\text{arrival},\\text{departure}\\}\nstates: number of customers in the queue \n\\mathcal X = \\{0,1,2,3,\\ldots\\}, \\quad \\mathcal X_0 = \\{0\\}\n\n\nnot a finite state automation, unless the queue is bounded.\n\nstate transition: \nf(x,e) =\n\\begin{cases}\nx+1, & \\text{if}\\; x\\leq 0 \\land e = \\mathrm{arrival}\\\\\nx-1, & \\text{if}\\; x &gt; 0 \\land e = \\mathrm{departure}\n\\end{cases}\n\n\n\nWhether the queue’s length is bounded is a modelling assumption.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-system-as-an-automaton",
    "href": "des_automata.html#queueing-system-as-an-automaton",
    "title": "(State) automata",
    "section": "Queueing system as an automaton",
    "text": "Queueing system as an automaton\n\n\nOnce again, note how the states correspond to the value of the state variable.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-of-a-queueing-system-jobs-processing-by-a-cpu",
    "href": "des_automata.html#example-of-a-queueing-system-jobs-processing-by-a-cpu",
    "title": "(State) automata",
    "section": "Example of a queueing system: jobs processing by a CPU",
    "text": "Example of a queueing system: jobs processing by a CPU",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#stochastic-queueing-systems",
    "href": "des_automata.html#stochastic-queueing-systems",
    "title": "(State) automata",
    "section": "Stochastic queueing systems",
    "text": "Stochastic queueing systems\n\nArrivals can be modelled using random processes.\nSimilarly the departures – delays (processing time) of the server can be modelled as random.\nBut then time needs to be included in the automaton, and so far we do not have it there.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#timed-automaton",
    "href": "des_automata.html#timed-automaton",
    "title": "(State) automata",
    "section": "Timed automaton",
    "text": "Timed automaton\n\nMotivation\n\nHow many events of a certain type in a given interval?\nIs the time interval between two events above a given threshold?\nHow long does the system spend in a given state?\n…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#timed-automaton-with-guards-alur-dill",
    "href": "des_automata.html#timed-automaton-with-guards-alur-dill",
    "title": "(State) automata",
    "section": "Timed automaton with guards (Alur & Dill)",
    "text": "Timed automaton with guards (Alur & Dill)\n\none or several resettable clocks: c_i,\\, i=1,\\ldots, k, driven by the ODE \n  \\frac{\\mathrm{d} c_i(t)}{\\mathrm d t} = 1, \\quad c_i(0) = 0.\n  \neach transition labelled by the tripple {guard; event; reset}\n\n\nBoth satisfaction of the guard and arrival of the event constitute enabling conditions for the transition. They could be wrapped into a single compound condition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-ta-with-guards",
    "href": "des_automata.html#ex.-ta-with-guards",
    "title": "(State) automata",
    "section": "Ex.: TA with guards",
    "text": "Ex.: TA with guards\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n-; msg; c₁\n\n\n\n1-&gt;1\n\n\nc₁≥1; msg; c₁\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n0&lt;c₁&lt;1; msg; c₁\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\nc₁&lt;1; alarm; -",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-ta-with-guards-and-invariant",
    "href": "des_automata.html#ex.-ta-with-guards-and-invariant",
    "title": "(State) automata",
    "section": "Ex.: TA with guards and invariant",
    "text": "Ex.: TA with guards and invariant\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n2\n\n2\nc₁&lt;1\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\n-; alarm; -\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n-; msg; c₁\n\n\n\n1-&gt;2\n\n\n0&lt;c₁&lt;1; msg; c₁\n\n\n\n1-&gt;1\n\n\nc₁≥1; msg; c₁",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#invariant-vs-guard",
    "href": "des_automata.html#invariant-vs-guard",
    "title": "(State) automata",
    "section": "Invariant vs guard",
    "text": "Invariant vs guard\n\nInvariant ((of a location)) gives an upper bound on the time the system can stay at the given location. It can leave earlier but not later.\nGuard (of a given transition) gives an enabling condition on leaving the location through the given transition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-several-trains-approaching-a-bridge",
    "href": "des_automata.html#example-several-trains-approaching-a-bridge",
    "title": "(State) automata",
    "section": "Example: several trains approaching a bridge",
    "text": "Example: several trains approaching a bridge\n\nBehrmann, Gerd, Alexandre David, and Kim G. Larsen. ‘A Tutorial on Uppaal’. In Formal Methods for the Design of Real-Time Systems, edited by Marco Bernardo and Flavio Corradini, 200–236. Lecture Notes in Computer Science 3185. Berlin, Heidelberg: Springer, 2004. https://doi.org/10.1007/978-3-540-30080-9_7.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "mld_DHA.html",
    "href": "mld_DHA.html",
    "title": "Discrete hybrid automata",
    "section": "",
    "text": "Since the new modelling framework is expected to be useful for prediction of a system response within model predictive control, it must model a hybrid system in discrete time. This is a major difference from what we did in our course so far.\nIn particular, we are going to model a hybrid system as a discrete(-time) hybrid automaton (DHA), which means that",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#four-components-of-a-discrete-time-hybrid-automaton",
    "href": "mld_DHA.html#four-components-of-a-discrete-time-hybrid-automaton",
    "title": "Discrete hybrid automata",
    "section": "Four components of a discrete(-time) hybrid automaton",
    "text": "Four components of a discrete(-time) hybrid automaton\nWe are already well familiar with the concept of a hybrid automaton, and the restriction to discrete time does not seem to warrant reopening the definition (modes/locations, guards, invariants/domains, reset maps, …). However, it turns out that reformulating/restructuring the hybrid automaton will be useful for our ultimate goal of developing an MPC-friendly modelling framework. In particular, we consider four components of a DHA:\n\nswitched affine system (SAS),\nmode selector (MS),\nevent generator (EG),\nfinite state machine (FSM).\n\nTheir interconnection is shown in the following figure.\n\nDraw the block diagram from Bemporad’s materials (book, toolbox documentation).\n\nLet’s discuss the individual components (and while doing that, you can think about the equivalent concept in the classical definition of a hybrid automaton such as mode, invariant, guard, …).\n\nSwitched affine systems (SAS)\nThis is a model of the continuous-value dynamics parameterized by the index i that evolves in (discrete) time \n\\begin{aligned}\nx_c(k+1) &= A_{i(k)} x_c(k) + B_{i(k)} u_c(k) + f_{i(k)}\\\\\ny_c(k) &= C_{i(k)} x_c(k) + D_{i(k)} u_c(k) + g_{i(k)}\n\\end{aligned}\n\nIn principle there is no need to restrict the right hand sides to affine functions as we did, but the fact is that the methods and tools are currently only available for this restricted class of systems.\n\n\nEvent generator (EG)\nWe consider partitioning of the state space or possibly state-control space into polyhedral regions. The system is then in the ith region of the state-input space, if the continuous-value state x_c(k) and the continuous-value control input u_c satisfy \nH_i x_c(k) + J_i u_c(k) + K_i \\leq 0\n\nThe event indicated by the (vector) binary variable \n\\delta_e(k) = h(x_c(k), u_c(k)) \\in \\{0,1\\}^m,\n\nwhere \nh_i(x_c(k), u_c(k)) = \\begin{cases}1 & H_i x_c(k) + J_i u_c(k) + K_i \\leq 0\\\\ 0 & \\text{otherwise}. \\end{cases}\n\n\n\nFinite state machine (FSM)\n\nx_d(k+1) = f_d(x_d(k),u_d(k),\\delta_e(k))\n\n\n\nMode selector (MS)\ni(k) \\in \\{1, 2, \\ldots, s\\}\n\ni(k) = \\mu(x_d(k), u_d(k), \\delta_e(k))",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#trajectory-of-a-dha",
    "href": "mld_DHA.html#trajectory-of-a-dha",
    "title": "Discrete hybrid automata",
    "section": "Trajectory of a DHA",
    "text": "Trajectory of a DHA\n\n\\begin{aligned}\n\\delta_e(k) &= h(x_c(k), u_c(k))\\\\\ni(k) &= \\mu(x_d(k), u_d(k), \\delta_e(k))\\\\\ny_c(k) &= C_{i(k)} x_c(k) + D_{i(k)} u_c(k) + g_{i(k)}\\\\\ny_d(k) &= g_d(x_d(k), u_d(k), \\delta_e(k))\\\\\nx_c(k+1) &= A_{i(k)} x_c(k) + B_{i(k)} u_c(k) + f_{i(k)}\\\\\nx_d(k+1) &= f_d(x_d(k),u_d(k),\\delta_e(k))\n\\end{aligned}",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#how-to-get-rid-of-the-if-then-conditions-in-the-model",
    "href": "mld_DHA.html#how-to-get-rid-of-the-if-then-conditions-in-the-model",
    "title": "Discrete hybrid automata",
    "section": "How to get rid of the IF-THEN conditions in the model?",
    "text": "How to get rid of the IF-THEN conditions in the model?",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#main-resources-for-the-lecture",
    "href": "mld_DHA.html#main-resources-for-the-lecture",
    "title": "Discrete hybrid automata",
    "section": "Main resource(s) for the lecture",
    "text": "Main resource(s) for the lecture\n\nBorrelli, Francesco, Alberto Bemporad, and Manfred Morari. Predictive Control for Linear and Hybrid Systems. Cambridge, New York: Cambridge University Press, 2017.\nBemporad, Alberto. Hybrid Toolbox for Matlab.",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mpc_mld_references.html",
    "href": "mpc_mld_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Literature"
    ]
  },
  {
    "objectID": "stability_via_multiple_lyapunov_function.html",
    "href": "stability_via_multiple_lyapunov_function.html",
    "title": "Multiple Lyapunov function",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Multiple Lyapunov function"
    ]
  },
  {
    "objectID": "complementarity_references.html",
    "href": "complementarity_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Literature"
    ]
  },
  {
    "objectID": "petri_nets_references.html",
    "href": "petri_nets_references.html",
    "title": "Literature",
    "section": "",
    "text": "Literature for Petri nets is vast, but a decent (and perfectly satisfactory) introduction can be found in Chapter 4 and 5.3 (for the timed PN) of the classical (and award-winning) reference [1]. Note that electronic version (in fact, PDF) is accessible through the NTK library (upon CTU login, for example to usermap first).\nA nice introduction is also in Chapter 2 of the freely online available book [2].\nThe survey paper that is particularly focused on Petri nets from the control systems perspective is [3] and it gives a wealth of other references.\nA few more monographs, mostly inclined towards control systems, are [4], [5], [6].",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Literature"
    ]
  },
  {
    "objectID": "petri_nets_references.html#petri-nets-and-their-derivatives-such-as-grafcet-in-international-standards",
    "href": "petri_nets_references.html#petri-nets-and-their-derivatives-such-as-grafcet-in-international-standards",
    "title": "Literature",
    "section": "Petri nets and their derivatives such as Grafcet in international standards",
    "text": "Petri nets and their derivatives such as Grafcet in international standards\nWe mention at the beginning of this chapter that Petri nets have made it to international standards. Here they are: [7], [8], and [9].\nBased on Petri nets, another framework has been derived and standardized, namely GRAFCET, see [10] and [11], upon which, in turn, the popular Sequential Function Chart (SFC) language for PLC programming [12] is based.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Literature"
    ]
  },
  {
    "objectID": "solution_conditions.html",
    "href": "solution_conditions.html",
    "title": "Solution conditions",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "7. Solution",
      "Solution conditions"
    ]
  }
]