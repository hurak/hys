---
title: "(State) automata"
---

Having just discussed the concept of a discrete-event system, we now the most popular modeling framework for such systems: a *state automaton*, or just an *automaton* (plural automata). It is also known as a *state machine* or a *(discrete) transition system*.

::: {#def-automaton}
## Automaton
Automaton is a tuple
$$\boxed{
G = \{\mathcal X,\mathcal X_0,\mathcal E,\mathcal F\},}
$$    
where

- $\mathcal X$ is the set of *states* (also called *modes* or *locations*).
- $\mathcal X_0 \subseteq \mathcal X$ is the set of *initial states*.
- $\mathcal E$ is the set of *events* (also *actions*, *transition labels*, *symbols*). Also called *alphabet*.
- $\mathcal F\subseteq \mathcal X \times \mathcal E \times \mathcal X$ is the set of transitions.
	- In the deterministic case it can also be narrowed down to a *transition function* $f:\mathcal X \times \mathcal E \rightarrow \mathcal X$. 
        - $f$ is a partial function.
  - Sometimes used even for multivalued functions: $f:\mathcal X \times \mathcal E \rightarrow 2^\mathcal{X}$ , where $2^\mathcal{X}$ is a power set.
:::


::: {.notes}
- The set of states is often denoted by $\mathcal Q$ to spare the letter $\mathcal X$ for the continuous valued state space of hybrid systems.
- The set of events is often denoted by $\mathcal A$ to spare the letter $\mathcal E$ for the set of transitions (edges), because $F$ and $f$ may also need to be spared for the continuous-valued transitions. But then the letter A actually fits this purpose nicely because the event set is also called the alphabet.
- The power set is a set of all subsets of $X$.
:::

## Definition of an automaton can include marked states
$$\boxed{
G = \{\mathcal X,\mathcal X_0,\mathcal E,\mathcal F, \mathcal X_\mathrm{m}\},}
$$ 
$\mathcal X_\mathrm{m} \subseteq \mathcal X$ is the set of *marked* or *accepting* states.

::: {.notes}
- I do not particularly like this idea of mixing the model of the system with the requirements, but this is how it is. 
- Note that within this definition we have three sets (subsets) of states: $\mathcal X$, $\mathcal X_0$ and $\mathcal X_\mathrm{m}$.
:::

## Comment on an alternative notation 

- Note that later (when introducing hybrid automata), we will replace the letter $\mathcal X$ with $\mathcal Q$ in favour of continuous-valued dynamical (sub)systems described by differential equations $\dot x = f(x,u)$.
- Similarly for other letters. 	  

## Automaton as (di)graph (also state transition diagram)

- States as nodes.
- Transitions as edges.
- Events (actions) as labels for the edges
    - (not necessarily unique). 

## Example

- $\mathcal X = \{x_1,x_2,x_3\},\quad \mathcal X_0 = \{x_1\}$
- $\mathcal E = \{e_1,e_2,e_3\}$
- $\begin{aligned}\mathcal F = \{(x_1,e_1,x_2),(x_2,e_2,x_1),(x_1,e_3,x_3),(x_2,e_2,x_3)\}\end{aligned}$

. . .

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle];
    init -> x₁;
    x₁ -> x₂ [label = "e₁"];
    x₂ -> x₁ [label = "e₂"];
    x₂ -> x₃ [label = "e₃"];
    x₁ -> x₃ [label = "e₂"];
}
```

## Active event function and set

- Active event function $\Gamma: \mathcal X \rightarrow 2^\mathcal{E}$ assigns to each state a set of active events.
- Active event set $\Gamma(x)$ is the set of active events in particular state $x$.

## Finite state automaton (FSA)
- Finite set $\mathcal X$ of states.
- Also: Finite state machine (FSM).

::: {.notes}
Rather superfluous definition.
:::

## Execution of an automaton

- $x_1\xrightarrow{e_1} x_2\xrightarrow{e_2} x_1 \xrightarrow{e_1} x_2 \xrightarrow{e_4} x_3\ldots$
- Sometimes also written as $x_1,e_1,x_2,e_2,\ldots$ 

--- 

::: {.callout-warning}
## Notational confusion
$x_k$ for some $k$ is the name of a particular state. It is not the name of a (yet to be introduced) *state variable*; In fact, it can be viewed of its *value* (also *valuation*). 
:::

- Some authors strictly distinguish between the state variable and the state (variable valuation),
    - similarly as in probability theory random variable $X$ vs its value $x$, as in $F(x) = P(X\leq x)$;
- some do not, but then it may lead to confusion; 
- yet some others avoid the problem by not introducing state variables and only working with enumerated states.

---

::: {.callout-warning}
## Notational confusion 2
Even worse, it is also tempting to interpret the lower index *k* as (discrete) time, but nope, in the previous *k* is not the time index.

Again, some authors do not distinguish...
:::

## Path of an automaton

Corresponding to the execution 

$$x_1\xrightarrow{e_1} x_2\xrightarrow{e_2} x_1 \xrightarrow{e_1} x_2 \xrightarrow{e_4} x_3\ldots$$ 

the path is just the sequence of visited states: 

$$x_1,x_2,x_1,x_2,x_3,\ldots$$

:::{.notes}
In continuous-valued dynamical systems, we have a *state trajectory*, but then time stamps are attached to each visited state.  
:::

## Example: Beverage vending machine

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=1.4 margin=0 fixedsize=true];
    init -> waiting;
    waiting -> swiped [label = "swipe card"];
    swiped -> waiting [label = "reject payment"];
    swiped -> paid [label = "accept payment"];
    paid -> coke_dispensed [label = "choose coke"];
    paid -> fanta_dispensed   [label = "choose fanta"];
    coke_dispensed -> waiting   [label = "take coke"];
    fanta_dispensed -> waiting   [label = "take fanta"];
}
```

- State sequence (path): `waiting`, `swiped`, `paid`, `coke_dispensed`, `waiting`
- Events sequence: `swipe card`, `accept payment`, `choose coke`, `take coke`

:::{.notes}
- Indeed, the two states `coke_dispensed` and `fanta_dispensed` can be merged into just `beverage_dispensed`.
- How about other paths? Longer? Shorter?
:::

## Example: Beverage vending machine

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = doublecircle width=1.4 margin=0 fixedsize=true]; waiting
    node [shape = circle width=1.4 margin=0 fixedsize=true];
    init -> waiting;
    waiting -> swiped [label = "swipe card"];
    swiped -> waiting [label = "reject payment"];
    swiped -> paid [label = "accept payment"];
    paid -> coke_dispensed [label = "choose coke"];
    paid -> fanta_dispensed   [label = "choose fanta"];
    coke_dispensed -> waiting   [label = "take coke"];
    fanta_dispensed -> waiting   [label = "take fanta"];
}
```

The `waiting` state can be *marked* (is *accepting*).

## Example: Longitudinal control of a ground vehicle

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=1 margin=0 fixedsize=true];
    init -> still;
    still -> accelerating [label = "push acc"];
    accelerating -> cruising [label = "cruise ON"];
    accelerating -> coasting [label = "rel acc"];
    cruising -> accelerating [label = "push acc"];
    cruising -> braking [label = "push brake"];
    braking -> cruising [label = "cruise ON"];
    braking -> still [label = "zero vel"];
    braking -> coasting [label = "rel brake"];
    cruising -> coasting [label = "rel acc"];
    coasting -> braking [label = "push brake"];
}
```

:::{.notes}
- By `cruise on` I mean switching on some kind of a cruise control system, which keeps the velocity constant.
- It turns out the optimal control strategy for trains (under some circumstances).
- Note that some of the events are indeed actions started by the driver, but some are just coming from the physics of the vehicle (transition from braking to zero velocity).
:::

## Example: Corridor switch

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.6 margin=0 fixedsize=true];
    init -> OFF;
    OFF -> ON [label = "switch₁,switch₂"];
    ON -> OFF [label = "switch₁,switch₂"];
}
```

- Two events associated with one transitions can be seen as two transitions, each with a single event, both sharing the starting and ending states.

## Example: Double intensity switching

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.7 margin=0 fixedsize=true];
    init -> OFF;
    OFF -> ON [label = "push"];
    ON -> OFF [label = "push"];
    ON -> ON2 [label = "push"];
    ON2 -> OFF [label = "push"];
}
```

- Obviously we need to introduce *time* into the automaton...

## State as the value of a state variable

- Definition of the state space by enumeration doesn't scale well. 
- State can be characterized as the *value* (sometimes also *valuation*) of a *state variable*.
- State variable $x$ is given by 
    - the name, 
    - the "type" (boolean, integer, vector, ...).

## Examples of state variables
- Corridor switch: $x \in \{\mathrm{false},\mathrm{true}\}$ (also $\{0,1\}$).
- Double intensity switching: 
    - $x \in \{0,1,2\} \subset \mathbb Z$, 
    - or $\bm x = \begin{bmatrix}x_1\\ x_2 \end{bmatrix}$, where $x_1,x_2 \in \{0,1\}$.

:::{.notes}
- Valuation is the value of a variable in a particular state. 
- It is not necessarily only numeric.
:::

## State (transition) equation

$$\boxed{x^+ = f(x,e)}$$

- Upon introduction of discrete-time (index) $k$
$$x_{k+1} = f(x_k,e_k)$$

- or
$$x[k+1] = f(x[k],e[k]).$$


:::{.notes}
- The function f can be defined by a computer code rather than a clean mathematical formula.
- The discrete-time index of the event is sometimes considered shifted, that is $$x_{k+1} = f(x_k,e_{k+1})$.
:::

## Extension: Moore machine

- Automaton with state outputs.
- Output function assigns outputs to the states
$$y = g(x).$$
- The output is produced (emitted) when the (new) state is entered.
- The output does not depend on the input. 
    When plugged into feedback, no algebraic loops.

## Example of a Moore machine

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.9 margin=0 fixedsize=true];
    closed [label = "NO FLOW\n\nValve\nclosed\n\n\n"]
    partial [label = "FLOW\n\nValve\npartially\nopen\n\n\n"]
    full [label = "FLOW\n\nValve\nfully open\n\n\n"]
    init -> closed [];
    closed -> partial [label = "open valve one turn"];
    partial -> closed [label = "close valve one turn"];
    partial -> full [label = "open valve one turn"];
    full -> partial [label = "close valve one turn"];
    full -> closed [label = "emergency shut off"];
}
```
The outputs are the labels of the states.

## Extension: Mealy machine

- Automaton with input/output transition labels.
- The transition label $e_\mathrm{i}/e_\mathrm{o}$ on the transion from $x_1$ to $x_2$ reads as "the input event $e_\mathrm{i}$ at state $x_1$ activates the transition to $x_2$, which outputs the event $e_\mathrm{o}$".
$$x_1\xrightarrow{e_\mathrm{i}/e_\mathrm{o}} x_2$$
- It can be viewed as if the output function also considers the input and not only the state
$y = e_\mathrm{o} = g(x,e_\mathrm{i})$.
- The output is produced (emitted) during the transition (before the new state is entered).

## Example of a Mealy machine
Coffee machine: coffee for 30 CZK, machine accepting 10 and 20 CZK coins, no change.
```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.9 margin=0 fixedsize=true];
    0 [label = "No coin"]
    10 [label = "10 CZK"]
    20 [label = "20 CZK"]
    init -> 0 [];
    0 -> 10 [label = "insert 10 CZK / no coffee"];
    0 -> 20 [label = "insert 20 CZK / no coffee"];
    10 -> 20 [label = "insert 10 CZK / no coffee"];
    20 -> 0 [label = "insert 10 CZK / coffee"];
    10 -> 0 [label = "insert 20 CZK / coffee"];
    20 -> 10 [label = "insert 20 CZK / coffee"];
}
```

## Example: reformulate the previous example as a Moore machine

. . .

Two more states wrt Mealy
```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.9 margin=0 fixedsize=true];
    0 [label = "NO COFFEE\n\nNo\ncoin\n\n\n"]
    10 [label = "NO COFFEE\n\n10\nCZK\n\n\n"]
    20 [label = "NO COFFEE\n\n20\nCZK\n\n\n"]
    30 [label = "COFFEE\n\n10+20\nCZK\n\n\n"]
    40 [label = "COFFEE\n\n20+20\nCZK\n\n\n"]
    init -> 0 [];
    0 -> 10 [label = "insert 10 CZK"];
    0 -> 20 [label = "insert 20 CZK"];
    10 -> 20 [label = "insert 10 CZK"];
    20 -> 30 [label = "insert 10 CZK"];
    20 -> 40 [label = "insert 20 CZK"];
    10 -> 30 [label = "insert 20 CZK"];
    30 -> 0 [label = ""];
    30 -> 10 [label = "insert 10 CZK"];
    30 -> 20 [label = "insert 20 CZK"];
    40 -> 10 [label = ""];
    40 -> 20 [label = "insert 10 CZK"];
    40 -> 30 [label = "insert 20 CZK"];
}
```

:::{.notes}
There are transitions from 30 and 40 back to 0 that are not labelled by any event. This does not seem to follow the general rule that transitions are always triggered by events. Not what? It can be resolved upon introducing time as the timeout transitions.
:::

## Example: Dijkstra token passing

```{dot}
digraph G {
    layout=circo;
    bgcolor = "transparent";
    #rankdir = "LR";
    node [shape = box width=0.7 margin=0 fixedsize=true];
    0 -> 1;
    1 -> 2;
    2 -> 3;
    3 -> 0;
}
```

## Data type for the state vector

```{{julia}}
struct DijkstraTokenRing
    number_of_nodes::Int64
    max_value_of_state_variable::Int64
    state_vector::Vector{Int64}
end
```

## State update (transition) function
```{{julia}}
function update!(dtr::DijkstraTokenRing)                        
    n = dtr.number_of_nodes
    k = dtr.max_value_of_state_variable
    x = dtr.state_vector
    xnext = copy(x)
    for i in eachindex(x)   # <1>
        if i == 1                                              
            xnext[i] = (x[i] == x[n]) ? mod(x[i] + 1,k) : x[i]  # <2>
        else                                                    
            xnext[i] = (x[i] != x[i-1]) ? x[i-1] : x[i]         # <3>
        end
    end
    dtr.x .= xnext                                              
end
```
1. Mind the +1 shift. x[2] corresponds to x₁ in the literature.
2. Increment if the left neighbour is identical.
3. Update by the differing left neighbour.

## Output function 
It gives the position of the token. 

```{{julia}}
function output(dtr::DijkstraTokenRing)
    x = dtr.state_vector
    y = similar(x)
    y[1] = iszero(x[1]-x[end])
    y[2:end] .= .!iszero.(diff(x))
    return y
end
```

##
```julia
n = 4                           # Concrete number of nodes.
k = n                           # Concrete max value of a state variable (must be >= n).
x_initial = rand(0:k,n)         # Initial state vector that does not necessarily guarantee acceptability (more than 1 token in the ring).
dtr = DijkstraTokenRing(n,k,x_initial)
output(dtr)                     # Show where the token is (are).

update!(dtr), output(dtr)       # Perform the update, show the state vector and show where the token is.
update!(dtr), output(dtr)       # Repeat a few times to see the stabilization.    
update!(dtr), output(dtr)
```

## Extended-state automaton
- Indeed, the hyphen is there on purpose – we are extending the state space by additional state variables.
- Augmenting the state variable(s) that define the states/modes/locations (in the graph) by **additional (typed) state variables**: `Int`, `Enum`, `Bool`,...    
- Transitions are then **guarded** by conditions on theses extra state variables.
- Besides the guard condition, the transitions is labelled also by a **reset function** that resets the extended state variables.


## Example: counting up to 10

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.6 margin=0 fixedsize=true];
    init -> OFF [label = "int k=0"];
    OFF -> ON [label = "press"];
    ON -> ON [label = "(press ∧ k < 10); k=k+1"];
    ON -> OFF [label = "(press ⋁ k ≥ 10); k=0"];
}
```

## Automata (state machines) in UML/SysML

![](figures/statemachine_sysml.png)

:::{.notes}
They can do hierarchies and more.
:::

## Automata (state machines) in (Open)Modelica

![](figures/statemachine_modelica.png)

## Automata in Simulink -> Stateflow Chart

![](figures/aircontrol-chart_stateflow.png)

## Composing automata

Synchronization through events: `!`,`?` 

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.6 margin=0 fixedsize=true];
    init -> 1 [];
    1 -> 2 [label = "press?"];
    3 -> 3 [label = "press!"];
}
```

## Languages and automata

- Extend the transition function: $f: \mathcal X \times \mathcal E^\ast \rightarrow \mathcal X$, where $\mathcal E^\ast$ stands for "all possible sequences of events".

- Language **generated** by the automaton is
    $$
    \mathcal L(\mathcal G) = \{s\in\mathcal E^\ast \mid f(x_0,s) \;\text{is defined}\}
    $$    

- Language **marked** by the automaton (the automaton is **accepting** or **recognizing** that language)
    $$
    \mathcal L_\mathrm{m}(\mathcal G) = \{s\in\mathcal L(\mathcal G) \mid f(x_0,s) \in \mathcal{X}_\mathrm{m}\}
    $$

## Ex.: languaged accepted by automaton

$$
\mathcal{E} = \{a,b\}, \mathcal{L} = \{a,aa,ba,aaa,aba,baa,bba,\ldots\}
$$

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = doublecircle width=0.3 fixedsize=true]; 1
    node [shape = circle width=0.3 margin=0 fixedsize=true];
    init -> 0 [label = ""];
    0 -> 1 [label = "a"];
    1 -> 0 [label = "b"];
    0 -> 0 [label = "b"];
    1 -> 1 [label = "a"];
}
```

:::{.notes}
What if we remove the self loop at state 1? The automaton then accepts languages starting with *a* and endis with *a*. 
:::


## What is the "language view of automata" good for? 

- Definitions, analysis, synthesis.
- We then need language concepts such as
    - concatenation of strings: $\quad c = ab$
    - empty string $\varepsilon$: $\quad\varepsilon a = a \varepsilon = a$
    - prefix, suffix
    - prefix closure $\bar{\mathcal{L}}$ (of the language $\mathcal L$)
    - ...

## Blocking

```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = doublecircle]; 2
    node [shape = circle width=0.6 margin=0 fixedsize=true];
    init -> 0 [label = ""];
    0 -> 1 [label = "a"];
    1 -> 2 [label = "b"];
    2 -> 0 [label = "g"];
    1 -> 5 [label = "g"];
    1 -> 3 [label = "a"];
    3 -> 4 [label = "b"];
    4 -> 3 [label = "a"];
    4 -> 4 [label = "g"];
}
```

- Deadlock at state 2. Livelock at states 3 and 4.
- $\bar{\mathcal{L}}_\mathrm{m}(\mathcal G) \sub \mathcal L(\mathcal G)$. 

## Queueing systems

- entities (also customers, jobs, tasks, requests, etc.)
- resources (also servers, processors, etc.): customers are waiting for them
- queues (also buffers): where waiting is done

. . .

![](figures/queueing_system.png)

## Examples of queueing systems
 - entities: people waiting for service in a bank or at a bust stop
 - resources: people (again) in a bank at the counter
 - queues: bank lobbies, bus stops, warehouses, ...

:::{.notes}
What are other examples?
- entities: packets, ...
- resources: processor, computer periphery, router, ...
- queues: ...
:::

## Why study?

- Resources are not unlimited
- Tradeoff needed between customer satisfaction and *fair* resources allocation 

## Networks of queueing systems

![](figures/queueing_system_network.png)

## Queueing systems as automata

- events: $\mathcal E = \{\text{arrival},\text{departure}\}$

- states: number of customers in the queue
$$
\mathcal X = \{0,1,2,3,\ldots\}, \quad \mathcal X_0 = \{0\}
$$

    - not a finite state automation, unless the queue is bounded.

- state transition:
$$
f(x,e) = 
\begin{cases}
x+1, & \text{if}\; x\leq 0 \land e = \mathrm{arrival}\\
x-1, & \text{if}\; x > 0 \land e = \mathrm{departure}
\end{cases}
$$

:::{.notes}
Whether the queue's length is bounded is a modelling assumption.
:::

## Queueing system as an automaton

![](figures/queueing_system_as_automaton.png)

:::{.notes}
Once again, note how the states correspond to the value of the state variable.
:::

## Example of a queueing system: jobs processing by a CPU


## Stochastic queueing systems

- Arrivals can be modelled using **random processes**.
- Similarly the departures – delays (processing time) of the server can be modelled as random.
- But then **time** needs to be included in the automaton, and so far we do not have it there. 

## Timed automaton

- Motivation
    - How many events of a certain type in a given interval?
    - Is the time interval between two events above a given threshold?
    - How long does the system spend in a given state?
    - ...

## Timed automaton with guards (Alur & Dill)

- one or several resettable clocks: $c_i,\, i=1,\ldots, k$, driven by the ODE
    $$
    \frac{\mathrm{d} c_i(t)}{\mathrm d t} = 1, \quad c_i(0) = 0.
    $$
- each transition labelled by the tripple 
{guard; event; reset}

:::{.notes}
Both satisfaction of the guard and arrival of the event constitute enabling conditions for the transition. They could be wrapped into a single compound condition.
:::

## Ex.: TA with guards
```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.9 margin=0 fixedsize=true];
    init -> 0 [label = ""];
    0 -> 1 [label = "-; msg; c₁"];
    1 -> 1 [label = "c₁≥1; msg; c₁"];
    1 -> 2 [label = "0<c₁<1; msg; c₁"];
    2 -> 3 [label = "c₁<1; alarm; -"];
}
```

## Ex.: TA with guards and invariant
```{dot}
digraph G {
    bgcolor = "transparent";
    rankdir = "LR";
    node [shape = plaintext]; init
    node [shape = circle width=0.9 margin=0 fixedsize=true];
    2 [label = "2\nc₁<1"]

    init -> 0 [label = ""];
    0 -> 1 [label = "-; msg; c₁"];
    1 -> 1 [label = "c₁≥1; msg; c₁"];
    1 -> 2 [label = "0<c₁<1; msg; c₁"];
    2 -> 3 [label = "-; alarm; -"];
}
```

## Invariant vs guard 

- Invariant ((of a location)) gives an upper bound on the time the system can stay at the given location. It can leave earlier but not later.
- Guard (of a given transition) gives an enabling condition on leaving the location through the given transition.

## Example: several trains approaching a bridge

- Behrmann, Gerd, Alexandre David, and Kim G. Larsen. ‘A Tutorial on Uppaal’. In Formal Methods for the Design of Real-Time Systems, edited by Marco Bernardo and Flavio Corradini, 200–236. Lecture Notes in Computer Science 3185. Berlin, Heidelberg: Springer, 2004. https://doi.org/10.1007/978-3-540-30080-9_7.

## Software

- UPPAAL (for timed automata)
- Stateflow
- SimEvents
- (Open)Modelica
– SimPy
- DiscreteEvents.jl, ConcurrentSim.jl
- ...


## Literature

:::: {.columns}

::: {.column width="40%"}
Cassandras, Christos G., and Stéphane Lafortune. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer, 2021.
:::

::: {.column width="60%"}
![](figures/cassandras_discrete_event_FRONT_PAGE.jpg){width=60%}
:::

::::

## Literature

- Lafortune, Stéphane. „Discrete Event Systems: Modeling, Observation, and Control". Annual Review of Control, Robotics, and Autonomous Systems 2, č. 1 (2019): 141–59. https://doi.org/10.1146/annurev-control-053018-023659. 



