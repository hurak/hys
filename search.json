[
  {
    "objectID": "hybrid_automata.html",
    "href": "hybrid_automata.html",
    "title": "Hybrid automata",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Hybrid automata"
    ]
  },
  {
    "objectID": "hybrid_equations_references.html",
    "href": "hybrid_equations_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Literature"
    ]
  },
  {
    "objectID": "intro_outline.html",
    "href": "intro_outline.html",
    "title": "Course outline",
    "section": "",
    "text": "The course is structured into 14 topics, each of them corresponding to one lecture. The topics are as follows:\n\nDiscrete-event systems\n\n(State) automata (state machines) (incl. timed variants)\nPetri nets (and timed Petri nets),\nMax-Plus algebra and Max-Plus Linear (MPL) systems\n\nHybrid systems\n\nHybrid automata\nHybrid equations\n\nSpecial classes of hybrid systems\n\nReset (control) systems, Switched/switching systems, Piecewise affine systems (PWA)\nComplementarity dynamical systems (and complementarity optimization constraints)\n\n\n\n\nSolutions of hybrid systems\n\n\nStability of hybrid systems\n\nCommon Lyapunov function\n\nQuadratic Lyapunov function via linear matrix inequality (LMI) and semidefinite programming (SDP)\nPolynomial Lyapunov function via sum-of-squares (SOS) programming\n\nPiecewise quadratic/polynomial Lyapunov function via S-procedure\n\n\n\nMixed-logical dynamical (MLD) description of hybrid systems\nModel predictive control (MPC) for MLD systems\n(Formal) verification of hybrid systems\n\n\n\n\n Back to top",
    "crumbs": [
      "0. Introduction",
      "Course outline"
    ]
  },
  {
    "objectID": "verification_references.html",
    "href": "verification_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "12. Formal verification",
      "Literature"
    ]
  },
  {
    "objectID": "mld_intro.html",
    "href": "mld_intro.html",
    "title": "Mixed logical dynamical",
    "section": "",
    "text": "Our motivation is to get rid of the IF-THEN conditions in the model."
  },
  {
    "objectID": "mld_intro.html#propositional-logic-and-connectives",
    "href": "mld_intro.html#propositional-logic-and-connectives",
    "title": "Mixed logical dynamical",
    "section": "Propositional logic and connectives",
    "text": "Propositional logic and connectives\n\nBoolean variable (or elementary proposition) \\(X\\) evaluates to true or false.\n\nFor convenience also 0 or 1, but …\n\nConnectives\n\nConjunction (logical and): \\(X_1 \\land X_2\\)\nDisjunction (logical or): \\(X_1 \\lor X_2\\)\nNegation: \\(\\neg X_2\\) (or \\(\\overline{X_2}\\) or \\(\\sim X_2\\))\nImplication: \\(X_1 \\implies X_2\\)\nEquivalence: \\(X_1 \\iff X_2\\)\nLogical XOR: \\(X_1 \\oplus X_2\\)"
  },
  {
    "objectID": "mld_intro.html#equivalences-of-logic-propositions",
    "href": "mld_intro.html#equivalences-of-logic-propositions",
    "title": "Mixed logical dynamical",
    "section": "Equivalences of logic propositions",
    "text": "Equivalences of logic propositions\n. . .\n\\[\nX_1 \\implies X_2 \\quad  \\text{is equivalent to} \\quad \\neg X_2 \\implies \\neg X_1\n\\]\n. . .\n\\[\nX_1 \\iff X_2 \\quad  \\text{eq.} \\quad (X_1 \\implies X_2) \\land (X_2 \\implies X_1)\n\\]\n. . .\n\\[\nX_1 \\land X_2 \\qquad  \\text{eq.} \\qquad \\neg (\\neg X_1 \\lor \\neg X_2)\n\\]\n. . .\n\\[\nX_1 \\implies X_2 \\qquad  \\text{eq.} \\qquad \\neg X_1 \\lor X_2\n\\]\n\nThe last one can be seen as follows: it cannot happen that \\(X1 \\land \\neg X2\\), that is, it holds that \\(\\neg(X1 \\land \\neg X2)\\). De Morgan gives \\(\\neg X1 \\lor X2\\)"
  },
  {
    "objectID": "mld_intro.html#binary-variables-related-to-the-boolean-ones",
    "href": "mld_intro.html#binary-variables-related-to-the-boolean-ones",
    "title": "Mixed logical dynamical",
    "section": "Binary variables related to the Boolean ones",
    "text": "Binary variables related to the Boolean ones\n\nAssociate with the Boolean variable \\(X\\) a binary variable \\(\\delta\\in\\{0,1\\}\\) such that \\[\n\\delta =\n\\begin{cases}\n0 & \\text{if} \\; \\neg X\\\\\n1 & \\text{if} \\; X\n\\end{cases}\n\\]"
  },
  {
    "objectID": "mld_intro.html#integer-inequalities-related-to-the-logical-formulas",
    "href": "mld_intro.html#integer-inequalities-related-to-the-logical-formulas",
    "title": "Mixed logical dynamical",
    "section": "Integer (in)equalities related to the logical formulas",
    "text": "Integer (in)equalities related to the logical formulas"
  },
  {
    "objectID": "mld_intro.html#and",
    "href": "mld_intro.html#and",
    "title": "Mixed logical dynamical",
    "section": "And",
    "text": "And\n\\[X_1 \\land X_2\\]\n. . .\n\\[[\\delta_1=1] \\land [\\delta_2=1]\\]\n. . .\n\\[\\delta_1=1, \\; \\delta_2=1\\]\n\nAnother (discarded) possibility:\n\n. . .\n\\[\\delta_1 \\delta_2 = 1\\]"
  },
  {
    "objectID": "mld_intro.html#or",
    "href": "mld_intro.html#or",
    "title": "Mixed logical dynamical",
    "section": "Or",
    "text": "Or\n\\[X_1 \\lor X_2\\]\n. . .\n\\[[\\delta_1=1] \\lor [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 + \\delta_2\\geq 1\\]"
  },
  {
    "objectID": "mld_intro.html#negation",
    "href": "mld_intro.html#negation",
    "title": "Mixed logical dynamical",
    "section": "Negation",
    "text": "Negation\n\\[\\neg X_1\\]\n. . .\n\\[\\neg [\\delta_1=1]\\]\n. . .\n\\[\\delta_1 = 0\\]"
  },
  {
    "objectID": "mld_intro.html#xor",
    "href": "mld_intro.html#xor",
    "title": "Mixed logical dynamical",
    "section": "Xor",
    "text": "Xor\n\\[X_1 \\oplus X_2\\]\n. . .\n\\[[\\delta_1=1] \\oplus [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 + \\delta_2 = 1\\]"
  },
  {
    "objectID": "mld_intro.html#implication",
    "href": "mld_intro.html#implication",
    "title": "Mixed logical dynamical",
    "section": "Implication",
    "text": "Implication\n\\[X_1 \\implies X_2\\]\n. . .\n\\[[\\delta_1=1] \\implies [\\delta_2=1]\\]\n\nequivalently, using \\(\\neg X_1 \\lor X_2\\), \\[\\neg [\\delta_1=1] \\lor [\\delta_2=1],\\]\nwhich translates to \\[(1-\\delta_1) + \\delta_2\\geq 1,\\]\nwhich simplifies to \\[\\delta_1 - \\delta_2 \\leq 0\\]"
  },
  {
    "objectID": "mld_intro.html#equivalence",
    "href": "mld_intro.html#equivalence",
    "title": "Mixed logical dynamical",
    "section": "Equivalence",
    "text": "Equivalence\n\\[X_1 \\iff X_2\\]\n. . .\n\\[[\\delta_1=1] \\iff [\\delta_2=1]\\]\n. . .\n\\[\\delta_1 - \\delta_2 = 0\\]"
  },
  {
    "objectID": "mld_intro.html#assignment",
    "href": "mld_intro.html#assignment",
    "title": "Mixed logical dynamical",
    "section": "Assignment",
    "text": "Assignment\n\\[X_3 \\iff (X_1 \\land X_2)\\]\n. . .\n\\[[\\delta_3=1] \\iff ([\\delta_1=1] \\land [\\delta_2=1])\\]\n\nExpressing the equivalence using implications \\[X_3 \\implies X_1,\\; X_3\\implies X_2, \\; (X_1 \\land X_2) \\implies X_3\\]\nThe the last one is equivalent to \\[\\neg (X_1 \\land X_2) \\lor X_3\\]\nwhich can be simplified to \\[\\neg X_1 \\lor \\neg X_2 \\lor X_3\\]\nwhich translates to \\[\\neg [\\delta_1=1] \\lor \\neg [\\delta_2 = 1] \\lor [\\delta_3 = 1]\\]\nwhich finally leads to the inequality \\[(1-\\delta_1) + (1-\\delta_2) + \\delta_3 \\geq 1\\]\nand after simplification \\[\\delta_1 + \\delta_2 - \\delta_3 \\leq 1.\\]\nAnd don’t forget to consider the first to inequalities too \\[\n-\\delta_1 + \\delta_3 \\leq 0, \\quad -\\delta_2 + \\delta_3 \\leq 0.\n\\]"
  },
  {
    "objectID": "mld_intro.html#general-transformation-of-boolean-expressions-to-integer-inequalities",
    "href": "mld_intro.html#general-transformation-of-boolean-expressions-to-integer-inequalities",
    "title": "Mixed logical dynamical",
    "section": "General transformation of Boolean expressions to integer inequalities",
    "text": "General transformation of Boolean expressions to integer inequalities\n\nFrom Conjunctive Normal Form (CNF) \\[\n\\bigwedge_{j=1}^m \\left[\\left(\\lor_{i\\in \\mathcal{P}_j} X_i\\right) \\lor \\left(\\lor_{i\\in \\mathcal{N}_j} \\neg X_i\\right)\\right]\n\\]\nto 0-1 integer inequalities defining a polyhedron \\[\n\\begin{aligned}\n\\sum_{i\\in \\mathcal{P}_1} \\delta_i + \\sum_{i\\in \\mathcal{N}_1} (1-\\delta_i) &\\geq 1,\\\\\n&\\vdots\\\\\n\\sum_{i\\in \\mathcal{P}_m} \\delta_i + \\sum_{i\\in \\mathcal{N}_m} (1-\\delta_i) &\\geq 1.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#finite-state-machine-fsm-using-binary-variables",
    "href": "mld_intro.html#finite-state-machine-fsm-using-binary-variables",
    "title": "Mixed logical dynamical",
    "section": "Finite state machine (FSM) using binary variables",
    "text": "Finite state machine (FSM) using binary variables\n\nEncode the discrete state variables in binary \\[\nx_b \\in \\{0,1\\}^{n_b}\n\\]\nSimilarly the discrete inputs \\[\nu_b \\in \\{0,1\\}^{m_b}\n\\]\nThe logical state equation then \\[\nx_b(k+1) = f_b(x_b(k),u_b(k),\\delta_e(k))\n\\]"
  },
  {
    "objectID": "mld_intro.html#example",
    "href": "mld_intro.html#example",
    "title": "Mixed logical dynamical",
    "section": "Example",
    "text": "Example\n. . .\n\n\nState update/transition equation \\[\n\\begin{aligned}\n& x_d(k+1) = \\\\\n&\\begin{cases}\n\\text{Red} & \\text{if}\\; ([x_d = \\text{green}] \\land \\neg [\\delta_3=1]) \\lor ([x_d = \\text{red}] \\land \\neg [\\delta_3=1])\\\\\n\\text{Green} & \\text{if} \\; \\ldots\\\\\n\\text{Blue} & \\text{if} \\; \\ldots\n\\end{cases}\n\\end{aligned}\n\\]\nBinary encoding of the discrete states \\[\n\\text{Red}: x_b = \\begin{bmatrix}0\\\\0 \\end{bmatrix}, \\; \\text{Green}: x_b = \\begin{bmatrix}0\\\\1 \\end{bmatrix}, \\; \\text{Blue}: x_b = \\begin{bmatrix}1\\\\0 \\end{bmatrix}\n\\]\nReformulating the state update equations for binary variables \\[\n\\begin{aligned}\nx_{b1} &= (\\neg [x_{b1} = 1] \\land \\neg [x_{b2} = 1]  \\land \\neg [\\delta_1=1]) \\\\\n&\\quad (\\neg [x_{b1} = 1] \\land \\neg [x_{b2} = 1]  \\land [\\delta_1=1]) \\land [u_{b2}=1]\\\\\n&\\quad (\\neg [x_{b1} = 1] \\land [x_{b2} = 1]  \\land \\neg [u_{b1}=1] \\land [\\delta_3=1])\\\\\n&\\quad \\lor ([x_{b1} = 1]\\land \\neg [\\delta_2=1])\\\\\nx_{b2} &= \\ldots\n\\end{aligned}\n\\]\nSimplify, convert to CNF."
  },
  {
    "objectID": "mld_intro.html#mixing-logical-and-continuous",
    "href": "mld_intro.html#mixing-logical-and-continuous",
    "title": "Mixed logical dynamical",
    "section": "Mixing logical and continuous",
    "text": "Mixing logical and continuous\n\nsee Indicator variables."
  },
  {
    "objectID": "mld_intro.html#logical-implies-continuous",
    "href": "mld_intro.html#logical-implies-continuous",
    "title": "Mixed logical dynamical",
    "section": "Logical implies continuous",
    "text": "Logical implies continuous\n\\[X \\implies [f(x)\\leq 0]\\]\n. . .\n\\[[\\delta = 1] \\implies [f(x)\\leq 0]\\]\n\nintroduce \\(M\\) \\[\nf(x) \\leq (1-\\delta) M\n\\]\nthat is large enough so that when \\(\\delta=0\\), there is no practical restriction on \\(f\\).\n\nBig-M technique."
  },
  {
    "objectID": "mld_intro.html#continuous-implies-logical",
    "href": "mld_intro.html#continuous-implies-logical",
    "title": "Mixed logical dynamical",
    "section": "Continuous implies logical",
    "text": "Continuous implies logical\n\\[[f(x)\\leq 0] \\implies X\\]\n. . .\n\\[[f(x)\\leq 0] \\implies [\\delta = 1]\\]\n\nEquivalently \\[\\neg [\\delta = 1] \\implies \\neg [f(x)\\leq 0],\\]\nthat is, \\[[\\delta = 0] \\implies [f(x) &gt; 0]\\]\nIntroduce \\(m\\) such that \\(f(x)&gt;0\\) is enforced when \\(\\delta=0\\) \\[\nf(x) &gt; m\\delta\n\\]\nbut small enough that there is no restriction on \\(f\\) when \\(\\delta=1\\).\nFor numerical reasons, modify to nonstrict inequality \\[\nf(x) \\geq \\epsilon + (m-\\epsilon)\\delta,\n\\] where \\(\\epsilon\\approx 0\\) (for example, machine epsilon)."
  },
  {
    "objectID": "mld_intro.html#equivalence-between-logical-and-continuous",
    "href": "mld_intro.html#equivalence-between-logical-and-continuous",
    "title": "Mixed logical dynamical",
    "section": "Equivalence between logical and continuous",
    "text": "Equivalence between logical and continuous\n\nCombining the previous two implications.\n\n. . .\n\\[\n\\begin{aligned}\nf(x) &\\leq (1-\\delta) M,\\\\\nf(x) &\\geq \\epsilon + (m-\\epsilon)\\delta.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#if-then-else-rule-as-an-inequality",
    "href": "mld_intro.html#if-then-else-rule-as-an-inequality",
    "title": "Mixed logical dynamical",
    "section": "IF-THEN-ELSE rule as an inequality",
    "text": "IF-THEN-ELSE rule as an inequality\n\nIf \\(X\\)\n\nthen \\(z = a^\\top x + b^\\top u + f\\),\nelse \\(z = 0\\).\n\nIt can be expressed as a product \\[\nz = \\delta\\,(a^\\top x + b^\\top u + f)\n\\]\n\n. . .\n\\[\n\\begin{aligned}\nz &\\leq M\\delta,\\\\\n- z &\\leq -m\\delta,\\\\\nz &\\leq a^\\top x + b^\\top u + f - m(1-\\delta),\\\\\n-z &\\leq -(a^\\top x + b^\\top u + f) + M(1-\\delta).\n\\end{aligned}\n\\]\n\nThe reasoning is that if \\(\\delta=0\\), then \\(z\\) is restricted, while \\(a^\\top x + b^\\top u + f\\) is not. And the other way around."
  },
  {
    "objectID": "mld_intro.html#another-if-then-else-rule",
    "href": "mld_intro.html#another-if-then-else-rule",
    "title": "Mixed logical dynamical",
    "section": "Another IF-THEN-ELSE rule",
    "text": "Another IF-THEN-ELSE rule\n\nIf \\(X\\)\n\nthen \\(z = a_1^\\top x + b_1^\\top u + f_1\\),\nelse \\(z = a_2^\\top x + b_2^\\top u + f_2\\).\n\nIt can be expressed as \\[\n\\begin{aligned}\nz &= \\delta\\,(a_1^\\top x + b_1^\\top u + f_1) \\\\\n&\\quad + (1-\\delta)(a_2^\\top x + b_2^\\top u + f_2)\n\\end{aligned}\n\\]\n\n. . .\n\\[\n\\begin{aligned}\n(m_2-M_1)\\delta  + z &\\leq a_2^\\top x + b_2^\\top u + f_2,\\\\\n(m_1-M_2)\\delta  - z &\\leq -a_2^\\top x - b_2^\\top u - f_2,\\\\\n(m_1-M_2)(1-\\delta)  + z &\\leq a_1^\\top x + b_1^\\top u + f_1,\\\\\n(m_2-M_1)(1-\\delta)  - z &\\leq -a_1^\\top x - b_1^\\top u - f_1.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#generation-of-events-by-mixing-logical-and-continuous-variables-in-inequalities",
    "href": "mld_intro.html#generation-of-events-by-mixing-logical-and-continuous-variables-in-inequalities",
    "title": "Mixed logical dynamical",
    "section": "Generation of events by mixing logical and continuous variables in inequalities",
    "text": "Generation of events by mixing logical and continuous variables in inequalities\n\\[\n\\begin{aligned}\nh_i(x_c(k), u_c(k)) &\\leq M_i (1-\\delta_{e,i})\\\\\nh_i(x_c(k), u_c(k)) &\\geq \\epsilon + (m_i-\\epsilon) \\delta_{e,i}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#switched-affine-system",
    "href": "mld_intro.html#switched-affine-system",
    "title": "Mixed logical dynamical",
    "section": "Switched affine system",
    "text": "Switched affine system\n\nWe want to get rid of the IF-THEN and formulate the switching mechanism into the format of inequalities too.\n\n. . .\n\\[\nx_c(k+1) = \\sum_{i=1}^s z_i(k),  \n\\]\n\nwhere \\[\nz_1(k) =\n\\begin{cases}\nA_1 x_c(k) + B_1 u_c(k) + f_1 & \\text{if}\\;i(k)=1\\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\n. . .\n\\[\\quad \\vdots\\]\n. . .\n\\[\nz_s(k) =\n\\begin{cases}\nA_s x_c(k) + B_s u_c(k) + f_s & \\text{if}\\;i(k)=s\\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\nFor each \\(i\\in \\{1, 2, \\ldots, s\\}\\)\n\n. . .\n\\[\n\\begin{aligned}\nz_i &\\leq M_i\\delta_i,\\\\\n- z_i &\\leq -m_i\\delta_i,\\\\\nz_i &\\leq a_i^\\top x + b_i^\\top u + f_i - m_i(1-\\delta_i),\\\\\n-z_i &\\leq -(a_i^\\top x + b_i^\\top u + f_i) + M_i(1-\\delta_i).\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#mixed-logical-dynamical-mld-system",
    "href": "mld_intro.html#mixed-logical-dynamical-mld-system",
    "title": "Mixed logical dynamical",
    "section": "Mixed logical dynamical (MLD) system",
    "text": "Mixed logical dynamical (MLD) system\n\\[\n\\begin{aligned}\nx(k+1) &= Ax(k) + B_u u(k) + B_\\delta\\delta + B_zz(k) + B_0\\\\\ny(k) &= Cx(k) + D_u u(k) + D_\\delta \\delta + D_z z + D_0\\\\\nE_\\delta \\delta &+ E_z z(k) \\leq E_u u(k) + E_x x(k) + E_0  \n\\end{aligned}\n\\]"
  },
  {
    "objectID": "mld_intro.html#simple-example",
    "href": "mld_intro.html#simple-example",
    "title": "Mixed logical dynamical",
    "section": "Simple example",
    "text": "Simple example"
  },
  {
    "objectID": "mld_intro.html#hysdel-language",
    "href": "mld_intro.html#hysdel-language",
    "title": "Mixed logical dynamical",
    "section": "HYSDEL language",
    "text": "HYSDEL language"
  },
  {
    "objectID": "mld_intro.html#piecewise-affine-systems",
    "href": "mld_intro.html#piecewise-affine-systems",
    "title": "Mixed logical dynamical",
    "section": "Piecewise affine systems",
    "text": "Piecewise affine systems\n. . .\n\\[\n\\begin{aligned}\nx(k+1) &= A_{i(k)}x(k) + B_{i(k)} u(k) + f_{i(k)}\\\\\ny(k) &= C_{i(k)}x(k) + D_{i(k)} u(k) + g_{i(k)}\\\\\n& \\; H_{i(k)} x(k) + J_{i(k)} u(k) \\leq K_{i(k)}\n\\end{aligned}\n\\]\n\nDHA, MLD, PWA are equivalent."
  },
  {
    "objectID": "petri_nets_timed.html",
    "href": "petri_nets_timed.html",
    "title": "Timed Petri nets",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Timed Petri nets"
    ]
  },
  {
    "objectID": "mpc_mld_explicit.html",
    "href": "mpc_mld_explicit.html",
    "title": "Explicit MPC for hybrid systems",
    "section": "",
    "text": "Model predictive control (MPC) is not computationally cheap (compared to, say, PID or LQG control) as it requires solving optimization problem – typically a quadratic program (QP) - online. The optimization solver needs to be a part of the controller.\nThere is an alternative, though, at least in same cases. It is called explicit MPC. The computationally heavy optimization is only perfomed only during the design process and the MPC controller is then implemented just as an affine state feedback\n\\bm u_k(\\bm x(k)) = \\mathbf F_k^i \\bm x(k) + \\mathbf g_k^i,\\; \\text{if}\\; \\bm x(k) \\in \\mathcal R_k^i,\nwith the coefficients picked from some kind of a lookup table in real time Although retreiving the coefficients of the feedback controller is not computationally trivial, still it is cheaper than full optimization.",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Explicit MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_explicit.html#multiparametric-programming",
    "href": "mpc_mld_explicit.html#multiparametric-programming",
    "title": "Explicit MPC for hybrid systems",
    "section": "Multiparametric programming",
    "text": "Multiparametric programming\nThe key technique for explicit MPC is multi-parametric programming. In order to explain it, consider the following problem\n\nJ^\\ast(x) = \\inf_z J(z;x).\n\nThe z variable is an optimization variable, while x is a parameter. For a given parameter x, the cost function J is minimized. We study how the optimal cost J^\\ast depends on the parameter, hence the name parametric programming. If x is a vector, the name of the problem changes to multiparametric programming.\n\nExample: scalar variable, single parameter\nConsider the following cost function J(z;x) in z parameterized by x. The optimization variable z is constrained and this constraint is also parameterized by x. \n\\begin{aligned}\nJ(z;x) &= \\frac{1}{2} z^2 + 2zx + 2x^2 \\\\\n\\text{subject to} &\\quad  z \\leq 1 + x.\n\\end{aligned}\n\nIn this simple case we can aim at analytical solution. We proceed in the standard way – we introduce a Lagrange multiplicator \\lambda and form the augmented cost function \nL(z,\\lambda; x) = \\frac{1}{2} z^2 + 2zx + 2x^2 + \\lambda (z-1-x).\n\nThe necessary conditions of optimality for the inequality-constrained problem come in the form of KKT conditions \n\\begin{aligned}\nz + 2x + \\lambda &= 0,\\\\\nz - 1 - x &\\leq  0,\\\\\n\\lambda & \\geq 0,\\\\\n\\lambda (z - 1 - x) &= 0.\n\\end{aligned}\n\nThe last condition – the complementarity condition – gives rise to two scenarios: one corresponding to \\lambda = 0, and the other corresponding to z - 1 - x = 0. We consider them separately below.\nAfter substituting \\lambda = 0 into the KKT conditions, we get \n\\begin{aligned}\nz + 2x &= 0,\\\\\nz - 1 - x & \\leq  0.\n\\end{aligned}\n\nFrom the first equation we get how z depends on x, and from the second we obtain a bound on x. Finally, we can also substitute the expression for z into the cost function J to get the optimal cost J^\\ast as a function of x. All these are summarized here \n\\begin{aligned}\nz &= -2x,\\\\\nx & \\geq -\\frac{1}{3},\\\\\nJ^\\ast(x) &= 0.\n\\end{aligned}\n\nNow, the other scenario. Upon substitutin z - 1 - x = 0 into the KKT conditions we get\n\n\\begin{aligned}\nz + 2x + \\lambda &= 0,\\\\\nz - 1 - x &=  0,\\\\\n\\lambda & \\geq 0.\n\\end{aligned}\n\nFrom the second equation we get the expression for z in terms of x, substituting into the first equation and invoking the condition on nonnegativity of \\lambda we get the bound on x (not suprisingly it complements the one obtained in the previous scenario). Finally, substituting for z in the cost function J we get a formula for the cost J^\\ast as a function of x.\n\n\\begin{aligned}\nz &= 1 + x,\\\\\n\\lambda &= -z - 2x \\geq 0 \\quad \\implies \\quad x \\leq -\\frac{1}{3},\\\\\nJ^\\ast(x) &= \\frac{9}{2}x^2 + 3x + \\frac{1}{2}.\n\\end{aligned}\n\nThe two scenarios can now be combined into a single piecewise affine function z(x) \nz(x) = \\begin{cases}\n1+x & \\text{if } x \\leq -\\frac{1}{3},\\\\\n-2x & \\text{if } x &gt; -\\frac{1}{3}.\n\\end{cases}\n\n\nx = range(-1, 1, length=100)\nz(x) = x &lt;= -1/3 ? 1 + x : -2x\nJstar(x) = x &lt;= -1/3 ? 9/2*x^2 + 3x + 1/2 : 0\n\nusing Plots\nplot(x, z.(x), label=\"z(x)\")\nvline!([-1/3],line=:dash)\nxlabel!(\"x\")\nylabel!(\"z(x)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand a piecewise quadratic cost function J^\\ast(x) \nJ^\\ast(x) = \\begin{cases}\n\\frac{9}{2}x^2 + 3x + \\frac{1}{2} & \\text{if } x \\leq -\\frac{1}{3},\\\\\n0 & \\text{if } x &gt; -\\frac{1}{3}.\n\\end{cases}\n\n\nplot(x, Jstar.(x), label=\"J*(x)\")\nvline!([-1/3],line=:dash)\nxlabel!(\"x\")\nylabel!(\"J*(x)\")",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Explicit MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mld_why.html",
    "href": "mld_why.html",
    "title": "Why another framework?",
    "section": "",
    "text": "We are going to introduce yet another framework for modeling hybrid systems – mixed logical dynamical (MLD) description. A question must inevitably pop up: “why yet another framework?”\nThe answer is, that we would like to have a model of a hybrid system that is suitable for model predictive control (MPC). Recall that the role of the model in MPC is that the model is used to define some constraints (equations and inequalities) in the numerical optimization problem. The frameworks that we considered so far did not offer it.\nIn particular, with the state variable and control input vectors composed of continuous and discrete variables \n\\bm x = \\begin{bmatrix}\\bm x_c\\\\\\bm x_d\\end{bmatrix}, \\quad \\bm u = \\begin{bmatrix}\\bm u_c\\\\\\bm u_d\\end{bmatrix},\n where \\bm x_c\\in\\mathbb R^{n_c},\\;\\bm x_d\\in\\mathbb N^{n_d},\\; \\bm u_c\\in\\mathbb R^{m_c} and \\bm u_d\\in\\mathbb N^{m_d}, we would like to formulate the model in the form of state equations, say \n\\begin{aligned}\n\\begin{bmatrix}\\bm x_c(k+1) \\\\ \\bm x_d(k+1)\\end{bmatrix}\n&=\n\\begin{bmatrix} \\mathbf f_c(\\bm x(k), \\bm u(k)) \\\\ \\mathbf f_d(\\bm x(k), \\bm u(k)) \\end{bmatrix}\n\\end{aligned}\n\nIs it possible?\nUnfortunately no. At least not exactly in this form. But something close to it is achievable instead.\nBut first we need to set the terminology and notation used to define a discrete(-time) hybrid automaton.\n\n\n\n Back to top",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Why another framework?"
    ]
  },
  {
    "objectID": "classes_references.html",
    "href": "classes_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Literature"
    ]
  },
  {
    "objectID": "stability_concepts.html",
    "href": "stability_concepts.html",
    "title": "Stability of hybrid systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Stability of hybrid systems"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "B(E)3M35HYS – Hybrid systems",
    "section": "",
    "text": "This website constitutes the lecture notes for the graduate course Hybrid Systems (B3M35HYS, BE3M35HYS) taught within Cybernetics and Robotics graduate program at Faculty of Electrical Engineering, Czech Technical University in Prague.\nOrganizational instructions, description of grading policy, assignments of homework problems and other course related material relevant for officially enrolled students are located elsewhere (the course page within the FEL Moodle).\n\n\n\n Back to top"
  },
  {
    "objectID": "mpc_mld_online.html",
    "href": "mpc_mld_online.html",
    "title": "Online MPC for hybrid systems",
    "section": "",
    "text": "First, we need to set the cost function for the optimal control problem. As usual in optimal control, we want to impose different weights on invididual state and control variables. The most popular is the quadratic cost function well known from the LQ-optimal control\n\\[\nJ_0(x(0),U_0) = x_N^T S_N x_N + \\sum_{k=0}^{N-1} \\left( x_k^T Q x_k + u_k^T R u_k \\right)\n\\]\nBut other (weighted) norms can also be used, in particular 1-norm and infinity-norm\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_1 + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_1 + \\|R u_k\\|_1 \\right),\n\\]\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_{\\infty} + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_{\\infty} + \\|R u_k\\|_{\\infty} \\right).\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_online.html#optimal-control-on-a-finite-horizon",
    "href": "mpc_mld_online.html#optimal-control-on-a-finite-horizon",
    "title": "Online MPC for hybrid systems",
    "section": "",
    "text": "First, we need to set the cost function for the optimal control problem. As usual in optimal control, we want to impose different weights on invididual state and control variables. The most popular is the quadratic cost function well known from the LQ-optimal control\n\\[\nJ_0(x(0),U_0) = x_N^T S_N x_N + \\sum_{k=0}^{N-1} \\left( x_k^T Q x_k + u_k^T R u_k \\right)\n\\]\nBut other (weighted) norms can also be used, in particular 1-norm and infinity-norm\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_1 + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_1 + \\|R u_k\\|_1 \\right),\n\\]\n\\[\nJ_0(x(0),U_0) = \\|S_N x_N\\|_{\\infty} + \\sum_{k=0}^{N-1} \\left( \\|Q x_k\\|_{\\infty} + \\|R u_k\\|_{\\infty} \\right).\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mpc_mld_online.html#optimization-problem",
    "href": "mpc_mld_online.html#optimization-problem",
    "title": "Online MPC for hybrid systems",
    "section": "Optimization problem",
    "text": "Optimization problem\nCombining the cost function with the MLD model, and perhaps we some extra constraints imposed on the control inputs as well as state variables, we get \\[\n\\operatorname*{minimize}_{u_0, u_1, \\ldots, u_{N-1}} J_0(x(0),(u_0, u_1, \\ldots, u_{N-1}))\n\\]\nsubject to \\[\n\\begin{aligned}\nx_{k+1} &= Ax_k + B_u u_k + B_\\delta\\delta_k + B_z z_k + B_0\\\\\ny_k &= Cx_k + D_u u_k + D_\\delta \\delta_k + D_z z_k + D_0\\\\\nE_\\delta \\delta_k &+ E_z z_k \\leq E_u u_k + E_x x_k + E_0 \\\\\nu_{\\min} &\\leq u_k \\leq u_{\\max} \\\\\nx_{\\min} &\\leq x_k \\leq x_{\\max} \\\\\nP x_N &\\leq r \\\\\nx_0 &= x(0)\n\\end{aligned}\n\\]",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Online MPC for hybrid systems"
    ]
  },
  {
    "objectID": "mld_references.html",
    "href": "mld_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Literature"
    ]
  },
  {
    "objectID": "verification_barrier.html",
    "href": "verification_barrier.html",
    "title": "Barrier certificates",
    "section": "",
    "text": "This is another technique for verification of safety of hybrid system. Unlike the optimal-control based and set-propagation based techniques, it is not based on explicit computational characterization of the evolution of states in time. Instead, it is based on searching for a function of a state that satisfies certain properties. The function is called a barrier function and it serves as a certificate of safety.\nFor notational and conceptual convenience we start with an explanation of the method for continuous systems, and only then we extend it to hybrid systems.",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#barrier-certificate-for-continuous-systems",
    "href": "verification_barrier.html#barrier-certificate-for-continuous-systems",
    "title": "Barrier certificates",
    "section": "Barrier certificate for continuous systems",
    "text": "Barrier certificate for continuous systems\nWe consider a continuous-time dynamical system modelled by \n\\dot{\\bm x}(t) = \\mathbf f(\\bm x, \\bm d),\n where \\bm d represents an uncertainy in the system description – it can be an uncertain parameter or an external disturbance acting on the system.\nWe now define two regions of the state space:\n\nthe set of initial states \\mathcal X_0,\nand the set of unsafe states \\mathcal X_\\mathrm{u}.\n\nOur goal is to prove (certify) that the system does not reach the unsafe states for an arbitrary initial state \\bm x(0)\\in \\mathcal X_0 and for an arbitrary d\\in \\mathcal D.\nWe define a barrier function B(\\bm x) with the following three properties\nB(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u},\nB(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0,\n\\nabla B(\\bm x)^\\top \\mathbf f(\\bm x, \\bm d) \\leq 0,\\quad \\forall \\bm x, \\bm d \\, \\text{such that} \\, B(\\bm x) = 0.\nNow, upon finding a function B(\\bm x) with such properties, we will prove (certify) safety of the system – the function serves as a certificate of safety.\n\n\n\n\n\n\nNote\n\n\n\nIt cannot go unnoticed that the properties of a barrier function B(\\bm x) and the motivation for its finding resemble those of a Lyapunov function. Indeed, the two concepts are related. But they are not the same.\n\n\nHow do we find such function? We will reuse the computational technique based on sum-of-squares (SOS) polynomials that we already used for Lyapunov functions. But first we need to handle one unpleasant aspect of the third condition above – nonconvexity of the set given by B(\\bm x) = 0.",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#convex-relaxation-of-the-barrier-certificate-problem",
    "href": "verification_barrier.html#convex-relaxation-of-the-barrier-certificate-problem",
    "title": "Barrier certificates",
    "section": "Convex relaxation of the barrier certificate problem",
    "text": "Convex relaxation of the barrier certificate problem\nWe relax the third condition so that it holds not only at B(\\bm x) = 0 but everywhere. The three conditions are then B(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u},\nB(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0,\n\\nabla B(\\bm x)^\\top \\mathbf f(\\bm x, \\bm d) \\leq 0,\\quad \\forall \\bm x\\in \\mathcal X, \\bm d \\in \\mathcal D.\nLet’s now demonstrate this by means of an example.\n\nExample 1 Consider the system modelled by \n\\begin{aligned}\n\\dot x_1 &= x_2\\\\\n\\dot x_2 &= -x_1 + \\frac{p}{3}x_1^3 - x_2,\n\\end{aligned}\n where the parameter p\\in [0.9,1.1].\nThe initial set is given by \n\\mathcal X_0 = \\{ \\bm x \\in \\mathbb R^2 \\mid (x_1-1.5)^2 + x_2^2 \\leq 0.25 \\}\n and the unsafe set is given by \n\\mathcal X_\\mathrm{u} = \\{ \\bm x \\in \\mathbb R^2 \\mid (x_1+1)^2 + (x_2+1)^2 \\leq 0.16 \\}.\n\nThe vector field \\mathbf f and the initial and unsafe sets are shown in the figure below.\n\n\nCode\nusing SumOfSquares\nusing DynamicPolynomials\nusing MosekTools    \n\noptimizer = optimizer_with_attributes(Mosek.Optimizer, MOI.Silent() =&gt; true)\nmodel = SOSModel(optimizer)\n@polyvar x[1:2] \n\np = 1;\n\nf = [ x[2],\n     -x[1] + (p/3)*x[1]^3 - x[2]]\n\ng₁ = -(x[1]+1)^2 - (x[2]+1)^2 + 0.16  # 𝒳ᵤ = {x ∈ R²: g₁(x) ≥ 0}\nh₁ = -(x[1]-1.5)^2 - x[2]^2 + 0.25    # 𝒳₀ = {x ∈ R²: h₁(x) ≥ 0}\n\nX = monomials(x, 0:4)\n@variable(model, B, Poly(X))\n\nε = 0.001\n@constraint(model, B &gt;= ε, domain = @set(g₁ &gt;= 0))\n\n@constraint(model, B &lt;= 0, domain = @set(h₁ &gt;= 0))\n\nusing LinearAlgebra # Needed for `dot`\ndBdt = dot(differentiate(B, x), f)\n@constraint(model, -dBdt &gt;= 0)\n\nJuMP.optimize!(model)\n\nJuMP.primal_status(model)\n\nimport DifferentialEquations, Plots, ImplicitPlots\nfunction phase_plot(f, B, g₁, h₁, quiver_scaling, Δt, X0, solver = DifferentialEquations.Tsit5())\n    X₀plot = ImplicitPlots.implicit_plot(h₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"X₀\", linecolor=:blue)\n    Xᵤplot = ImplicitPlots.implicit_plot!(g₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"Xᵤ\", linecolor=:teal)\n    Bplot  = ImplicitPlots.implicit_plot!(B; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"B = 0\", linecolor=:red)\n    Plots.plot(X₀plot)\n    Plots.plot!(Xᵤplot)\n    Plots.plot!(Bplot)\n    ∇(vx, vy) = [fi(x[1] =&gt; vx, x[2] =&gt; vy) for fi in f]\n    ∇pt(v, p, t) = ∇(v[1], v[2])\n    function traj(v0)\n        tspan = (0.0, Δt)\n        prob = DifferentialEquations.ODEProblem(∇pt, v0, tspan)\n        return DifferentialEquations.solve(prob, solver, reltol=1e-8, abstol=1e-8)\n    end\n    ticks = -5:0.5:5\n    X = repeat(ticks, 1, length(ticks))\n    Y = X'\n    Plots.quiver!(X, Y, quiver = (x, y) -&gt; ∇(x, y) / quiver_scaling, linewidth=0.5)\n    for x0 in X0\n        Plots.plot!(traj(x0), vars=(1, 2), label = nothing)\n    end\n    Plots.plot!(xlims = (-2, 3), ylims = (-2.5, 2.5))\nend\n\nphase_plot(f, value(B), g₁, h₁, 10, 30.0, [[x1, x2] for x1 in 1.2:0.2:1.7, x2 in -0.35:0.1:0.35])\n\n\nPrecompiling DifferentialEquations\n  ✓ SciMLBase\n  ✓ SciMLBase → SciMLBaseChainRulesCoreExt\n  ✓ DiffEqBase\n  ✓ DiffEqBase → DiffEqBaseUnitfulExt\n  ✓ DiffEqBase → DiffEqBaseChainRulesCoreExt\n  ✓ DiffEqBase → DiffEqBaseDistributionsExt\n  ✓ JumpProcesses\n  ✓ DiffEqNoiseProcess\n  ✓ JumpProcesses → JumpProcessFastBroadcastExt\n  ✓ Sundials\n  ✓ LinearSolve\n  ✓ LinearSolve → LinearSolveFastAlmostBandedMatricesExt\n  ✓ SimpleNonlinearSolve\n  ✓ LinearSolve → LinearSolveBandedMatricesExt\n  ✓ SimpleNonlinearSolve → SimpleNonlinearSolveChainRulesCoreExt\n  ✓ LinearSolve → LinearSolveRecursiveArrayToolsExt\n  ✓ NonlinearSolve\n  ✓ NonlinearSolve → NonlinearSolveNLsolveExt\n  ✓ NonlinearSolve → NonlinearSolveBandedMatricesExt\n  ✓ DiffEqCallbacks\n  ✓ SteadyStateDiffEq\n  ✓ OrdinaryDiffEq\n  ✓ DelayDiffEq\n  ✓ StochasticDiffEq\n  ✓ BoundaryValueDiffEq\n  ✓ DifferentialEquations\n  26 dependencies successfully precompiled in 161 seconds. 210 already precompiled.\n┌ Warning: To maintain consistency with solution indexing, keyword argument vars will be removed in a future version. Please use keyword argument idxs instead.\n│   caller = ip:0x0\n└ @ Core :-1\n┌ Warning: At t=4.42311829094011, dt was forced below floating point epsilon 8.881784197001252e-16, and step error estimate = 1.139012671019052. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/jh7eV/src/integrator_interface.jl:600",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#barrier-certificate-for-hybrid-systems",
    "href": "verification_barrier.html#barrier-certificate-for-hybrid-systems",
    "title": "Barrier certificates",
    "section": "Barrier certificate for hybrid systems",
    "text": "Barrier certificate for hybrid systems\nFor a hybrid automaton with l locations \\{q_1,q_2,\\ldots,q_l\\}, not just one but l barrier functions/certificates are needed:\nB_i(\\bm x) &gt; 0,\\quad \\forall \\bm x \\in \\mathcal X_\\mathrm{u}(q_i),\nB_i(\\bm x) \\leq 0,\\quad \\forall \\bm x \\in \\mathcal X_0(q_i),\n\\nabla B_i(\\bm x)^\\top \\mathbf f_i(\\bm x, \\bm u) \\leq 0,\\quad \\forall \\bm x, \\bm u \\, \\text{such that} \\, B_i(\\bm x) = 0,\n\n\\begin{aligned}\nB_i(\\bm x) \\leq 0,\\quad &\\forall \\bm x \\in \\mathcal R(q_j,q_i,\\bm x^-)\\,\\text{for some}\\, q_j\\,\\\\\n&\\text{and}\\, \\bm x^-\\in\\mathcal G(q_j,q_i)\\,\\text{with}\\, B_j(\\bm x^-)\\leq 0.\n\\end{aligned}",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "verification_barrier.html#convex-relaxation-of-barrier-certificates-for-hybrid-systems",
    "href": "verification_barrier.html#convex-relaxation-of-barrier-certificates-for-hybrid-systems",
    "title": "Barrier certificates",
    "section": "Convex relaxation of barrier certificates for hybrid systems",
    "text": "Convex relaxation of barrier certificates for hybrid systems\n\\nabla B_i(\\bm x)^\\top \\mathbf f_i(\\bm x, \\bm u) \\leq 0,\\quad \\forall \\bm x\\in X_0(q_i), \\bm u\\in\\mathcal U(q_i),\n\n\\begin{aligned}\nB_i(\\bm x) \\leq 0,\\quad &\\forall (\\bm x, \\bm x^-)\\,\\text{such that}\\, \\bm x \\in \\mathcal R(q_j,q_i,\\bm x^-), \\\\\n&\\text{and}\\, \\bm x^-\\in\\mathcal G(q_i,q_j).\n\\end{aligned}",
    "crumbs": [
      "12. Formal verification",
      "Barrier certificates"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "What is a hybrid system?",
    "section": "",
    "text": "The adjective “hybrid” is used in a common language to express that the subject under consideration has a bit of this and a bit of that… When talking about hybridness of systems, we modify this vague definition into a more descriptive one: a hybrid system has a bit of this and an atom of that… By this bon mot we mean that hybrid systems contain some physical subsystems and components combined with if-then-else and/or timing rules that are mostly (but not always) implemented in software. This definition is certainly not the most precise one, but it is a good starting point.\nEven better definition is that hybrid systems are composed of systems whose evolution is driven by time (discrete or continuous) and by (discrete) events. The former modelled by ODE or DAE for continuous time case and difference equations in the discrete time case. The are latter are modelled by state automata and Petri nets, and they implement some propositonal (aka sentential or statement), predicate and/or temporal logics.\n\n\n\n\n\n\nHybrid systems vs cyberphysical systems\n\n\n\nRecently these systems containing both the computer/software/algorithmic parts and physical parts are also studied under the fancy name cyberphysical systems. The two concepts can hardly be distinguished. Agencies funding research just require new stuff… I also confess I am unhappy with the narrowing of the concept of cybernetics to just computers. Cybernetics, as introduced by Norbert Wiener, already encompasses physical and biological systems among others. Anyway, that is how it is and the take-away leeson is that a great deal of material relevant for our course on hybrid systems can be found in resources adopting the name of cyberphysical systems.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#definition-of-a-hybrid-system",
    "href": "intro.html#definition-of-a-hybrid-system",
    "title": "What is a hybrid system?",
    "section": "",
    "text": "The adjective “hybrid” is used in a common language to express that the subject under consideration has a bit of this and a bit of that… When talking about hybridness of systems, we modify this vague definition into a more descriptive one: a hybrid system has a bit of this and an atom of that… By this bon mot we mean that hybrid systems contain some physical subsystems and components combined with if-then-else and/or timing rules that are mostly (but not always) implemented in software. This definition is certainly not the most precise one, but it is a good starting point.\nEven better definition is that hybrid systems are composed of systems whose evolution is driven by time (discrete or continuous) and by (discrete) events. The former modelled by ODE or DAE for continuous time case and difference equations in the discrete time case. The are latter are modelled by state automata and Petri nets, and they implement some propositonal (aka sentential or statement), predicate and/or temporal logics.\n\n\n\n\n\n\nHybrid systems vs cyberphysical systems\n\n\n\nRecently these systems containing both the computer/software/algorithmic parts and physical parts are also studied under the fancy name cyberphysical systems. The two concepts can hardly be distinguished. Agencies funding research just require new stuff… I also confess I am unhappy with the narrowing of the concept of cybernetics to just computers. Cybernetics, as introduced by Norbert Wiener, already encompasses physical and biological systems among others. Anyway, that is how it is and the take-away leeson is that a great deal of material relevant for our course on hybrid systems can be found in resources adopting the name of cyberphysical systems.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#example-of-a-hybrid-system",
    "href": "intro.html#example-of-a-hybrid-system",
    "title": "What is a hybrid system?",
    "section": "Example of a hybrid system",
    "text": "Example of a hybrid system",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "intro.html#hybrid-system-is-an-open-and-unbounded-concept",
    "href": "intro.html#hybrid-system-is-an-open-and-unbounded-concept",
    "title": "What is a hybrid system?",
    "section": "Hybrid system is an open and unbounded concept",
    "text": "Hybrid system is an open and unbounded concept\nPartly because hybrid systems are investigated by many\n\nComputer science\nModeling & simulation\nControl systems\n\n\nHybrid systems in computer science\n\nThey start with discrete-event systems, typically modelled by finite state automata and/or timed automata, and add some (typically simple) continuous-time dynamics.\nMainly motivated by analysis (verification, model checking, …): safety, liveness, fairness, …\n\n\n\nHybrid systems in modeling and simulation\n\nEven when modeling purely physical systems, it can be beneficial to approximate some fast dynamics with discontinuous transitions – jumps (diodes and other semiconductor switches, computer networks, mechanical impacts, …).\nStrictly speaking, we should speak about hybrid models, because modeling a given system as hybrid is already a modeller’s decision. But the terminology is already settled…\n\n\n\nHybrid systems in control systems\n\nTypically focused on continuous-time dynamical systems to be controlled but introducing some logic through a controller (switching control, relay control, PLC, …)\nBesides synthesis (aka control design), properties such as stability, controllability, robustness.\nThere is yet another motivation for explicitly dealing with hybridness in control systems: some systems can only be stabilized by switching and switching can be formulated within the hybrid system framework.",
    "crumbs": [
      "0. Introduction",
      "What is a hybrid system?"
    ]
  },
  {
    "objectID": "solution_concepts.html",
    "href": "solution_concepts.html",
    "title": "Solution concepts",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "7. Solution",
      "Solution concepts"
    ]
  },
  {
    "objectID": "hybrid_automata_references.html",
    "href": "hybrid_automata_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "4. Hybrid systems: Hybrid automata",
      "Literature"
    ]
  },
  {
    "objectID": "des_references.html",
    "href": "des_references.html",
    "title": "Literature",
    "section": "",
    "text": "Literature for discrete-event systems is vast, but within the control systems community the classical (and award-winning) reference is Cassandras and Lafortune (2021). Note that an electronic version of the previous edition (perfectly acceptable for us) is accessible through the NTK library (possibly upon CTU login). This book is rather thick too and covering its content can easily need a full semestr. However, in our course we will only need the very basics of the theory of (finite state) automata and such basics are presented in Chapters 1 and 2. The extension to timed automata is then presented in Chapter 5.2.\n\nThe basics are also presented in the tutorial paper by the same author(s) Lafortune (2019).\nA very short (but sufficient for us) intro to discrete-event systems that adheres to Cassandras’s style is given in the first chapter of the recent hybrid systems textbook Lin and Antsaklis (2022).\nAlternatively, there are some other recent textbooks that contain decent introductions to the theory of (finite state) automata. These are often surfing on the wave of popularity of the recently fashionable buzzword of cyberphysical or embedded systems, but in essence these deal with the same hybrid systems as we do in our course. The fact is, however, that the modeling formalism can be a bit different from the one in Cassandras (certainly when it comes to notation but also some concepts). One such textbook is Alur (2015), for which an electronic version accessible through the NTK library (upon CTU login). Another one is Mitra (2007). In particular, Chapter 2 serves as an intro to the automata theory. Last but not least, Lee and Seshia (2017), for which an electronic version is freely downloadable.\n\n\n\n\n Back to topReferences\n\nAlur, Rajeev. 2015. Principles of Cyber-Physical Systems. Cambridge, MA, USA: MIT Press. https://mitpress.mit.edu/9780262029117/principles-of-cyber-physical-systems/.\n\n\nCassandras, Christos G., and Stéphane Lafortune. 2021. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer. https://doi.org/10.1007/978-3-030-72274-6.\n\n\nLafortune, Stéphane. 2019. “Discrete Event Systems: Modeling, Observation, and Control.” Annual Review of Control, Robotics, and Autonomous Systems 2 (1): 141–59. https://doi.org/10.1146/annurev-control-053018-023659.\n\n\nLee, Edward Ashford, and Sanjit Arunkumar Seshia. 2017. Introduction to Embedded Systems: A Cyber-Physical Systems Approach. 2nd ed. Cambridge, MA, USA: MIT Press. https://ptolemy.berkeley.edu/books/leeseshia//.\n\n\nLin, Hai, and Panos J. Antsaklis. 2022. Hybrid Dynamical Systems: Fundamentals and Methods. Advanced Textbooks in Control and Signal Processing. Cham: Springer. https://doi.org/10.1007/978-3-030-78731-8.\n\n\nMitra, Sayan. 2007. “A Verification Framework for Hybrid Systems.” PhD thesis, Massachusetts Institute of Technology. https://dspace.mit.edu/handle/1721.1/42238.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Literature"
    ]
  },
  {
    "objectID": "hybrid_equations.html",
    "href": "hybrid_equations.html",
    "title": "Hybrid equations",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "5. Hybrid systems: Hybrid equations",
      "Hybrid equations"
    ]
  },
  {
    "objectID": "stability_via_common_lyapunov_function.html",
    "href": "stability_via_common_lyapunov_function.html",
    "title": "Common Lyapunov function",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Common Lyapunov function"
    ]
  },
  {
    "objectID": "des.html",
    "href": "des.html",
    "title": "Discrete-event systems",
    "section": "",
    "text": "Instantaneous occurence, that is, an event takes no time.\nAssociated with a change of state (transition to another).\n\nBetween events the systems stays fixed, it doesn’t evolve.\n\nIn addition, the state space is discrete (even if infinite).\n\n\nDo we need to define the state here?",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#discrete-event",
    "href": "des.html#discrete-event",
    "title": "Discrete-event systems",
    "section": "",
    "text": "Instantaneous occurence, that is, an event takes no time.\nAssociated with a change of state (transition to another).\n\nBetween events the systems stays fixed, it doesn’t evolve.\n\nIn addition, the state space is discrete (even if infinite).\n\n\nDo we need to define the state here?",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#example-of-a-des-trajectory",
    "href": "des.html#example-of-a-des-trajectory",
    "title": "Discrete-event systems",
    "section": "Example of a DES trajectory",
    "text": "Example of a DES trajectory\n\n\n\nThe state space not necessarily equidistantly discretized.\nFor some events no transitions occur (\\(e_3\\) at \\(t_3\\)).\nBeware the annoying notational conflict when interpreting the lower index: either related to time or to a particular element of a set. In other words: name of the variable vs. value of the variable.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#contrast-with-continuous-time-dynamical-systems",
    "href": "des.html#contrast-with-continuous-time-dynamical-systems",
    "title": "Discrete-event systems",
    "section": "Contrast with continuous-time dynamical systems",
    "text": "Contrast with continuous-time dynamical systems\nin which everything takes time, however short.\n\nThe set of space is \\(\\mathbb{R}\\) (or a subset).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#discrete-time-or-discretized-systems",
    "href": "des.html#discrete-time-or-discretized-systems",
    "title": "Discrete-event systems",
    "section": "Discrete-time (or discretized) systems",
    "text": "Discrete-time (or discretized) systems\nsuch as \\(x[k+1] = A x[k]\\) also not event-driven but time-driven, hence the moments of transitions are predictable.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#events-occur",
    "href": "des.html#events-occur",
    "title": "Discrete-event systems",
    "section": "Events occur",
    "text": "Events occur\n\nwhen action is taken (button press, clutch released, …),\nspontaneously, when the reason is difficult to trace down (computer failure, …),\nwhen some condition is met (water level is reached, …).\n\n\nThe third case needs an introduction of a concept of a hybrid systems, wait for it.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#sequence-of-time-stamped-events",
    "href": "des.html#sequence-of-time-stamped-events",
    "title": "Discrete-event systems",
    "section": "Sequence of “time-stamped” events",
    "text": "Sequence of “time-stamped” events\nAka timed trace \\[(e_1,t_1), (e_2,t_2), (e_3,t_3), \\ldots\\]\n\nIt is enough to characterize an execution of a deterministic automaton (a unique initial state and a unique transitions at a given state and an event).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#possibly-stochastic-but-what-exactly",
    "href": "des.html#possibly-stochastic-but-what-exactly",
    "title": "Discrete-event systems",
    "section": "Possibly stochastic, but what exactly?",
    "text": "Possibly stochastic, but what exactly?\n\nStochasticity can be introduced in the event times (e.g. Poisson process),\nbut also in the transitions (e.g. probabilistic automata, more on this later).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#sometimes-time-stamps-not-needed-the-ordering-of-events-is-enough",
    "href": "des.html#sometimes-time-stamps-not-needed-the-ordering-of-events-is-enough",
    "title": "Discrete-event systems",
    "section": "Sometimes time stamps not needed – the ordering of events is enough",
    "text": "Sometimes time stamps not needed – the ordering of events is enough\nTrace \\[e_1,e_2,e_3, \\ldots\\]\n\nExample\ncredit_card_swiped, pin_entered, amount_entered, money_withdrawn\n\n\nOnly the order of the events is important.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#discrete-event-systems-studied-through-their-languages",
    "href": "des.html#discrete-event-systems-studied-through-their-languages",
    "title": "Discrete-event systems",
    "section": "Discrete-event systems studied through their languages",
    "text": "Discrete-event systems studied through their languages\nInspired by formal language theory.\n\nAlphabet\n\na set of symbols (events).\n\nWord (or string)\n\na sequence of symbols from a finite alphabet (a particular execution or run of an automaton).\n\nLanguage\n\na set of words from the given alphabet (a set of all possible executions of an automaton).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "des.html#modelling-frameworks-for-des",
    "href": "des.html#modelling-frameworks-for-des",
    "title": "Discrete-event systems",
    "section": "Modelling frameworks for DES",
    "text": "Modelling frameworks for DES\n(in our course:)\n\n(State) automaton (pl. automata)\nPetri net\n\n(max,plus) algebra, MPL systems",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "Discrete-event systems"
    ]
  },
  {
    "objectID": "max_plus_algebra.html",
    "href": "max_plus_algebra.html",
    "title": "Max-plus algebra",
    "section": "",
    "text": "Tropical algebra/geometry\nDioid algebra",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#also-known-as",
    "href": "max_plus_algebra.html#also-known-as",
    "title": "Max-plus algebra",
    "section": "",
    "text": "Tropical algebra/geometry\nDioid algebra",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#standard-algebra",
    "href": "max_plus_algebra.html#standard-algebra",
    "title": "Max-plus algebra",
    "section": "Standard algebra",
    "text": "Standard algebra\n\nTwo operations:\n\naddition (+)\nmultiplication (×)\n\nNeutral (identity) element wrt addition: zero, 0\n\na+0=a\n\nNeutral (identity) element wrt multiplication: one, 1\n\na\\times 1 = a\n\n\n\n\nInverse element wrt addition: -a\n\na+(-a) = 0\n\nInverse element wrt multiplication (except for 0): a^{-1}\n\na \\times a^{-1} = 1\n\nRing or field depending on whether the inverse wrt multiplication exists for every (nonzero) element or not.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#max-algebra",
    "href": "max_plus_algebra.html#max-algebra",
    "title": "Max-plus algebra",
    "section": "(max,+) algebra",
    "text": "(max,+) algebra\n\nPossibly (min,+) too.\nTwo operations taking over the role of addition and multiplication: \\oplus and \\otimes\nDefine the new operations as \\boxed{\nx\\oplus y \\equiv \\max(x,y)\n}\n\n\\boxed{\nx\\otimes y \\equiv x+y}\n\n\n\n\nIndeed, there is no typo here, the addition is replaced by \\otimes and not \\oplus.\nAnd why the other name “tropical”? Reportedly just to honor a matematician who contributed to the field and lived in Brazil.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#neutral-elements",
    "href": "max_plus_algebra.html#neutral-elements",
    "title": "Max-plus algebra",
    "section": "Neutral elements",
    "text": "Neutral elements\n. . .\n\\boxed{\n  x,y\\in \\mathbb R_\\varepsilon \\equiv \\mathbb R \\cup \\{-\\infty\\}}.\n\n\nThe neutral element for \\oplus, the zero, is\n\n-\\infty =: \\varepsilon,\nx\\oplus \\varepsilon = \\varepsilon \\oplus x = x for all x\\in \\mathbb R_\\varepsilon.\n\nThe neutral element for \\otimes, the one, is:\n\n0.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#inverse-elements-wrt-oplus",
    "href": "max_plus_algebra.html#inverse-elements-wrt-oplus",
    "title": "Max-plus algebra",
    "section": "Inverse elements wrt \\oplus",
    "text": "Inverse elements wrt \\oplus\n\nIn general it does not exist.\nFor which element(s) does it exist?\n\nOnly for \\varepsilon.\n\nConsequently, for example, x\\oplus x=x.\nThis is the key difference with respect to a conventional algebra (the inverse element of a wrt conventional addition is -a).\n(max,+) algebra is thus only semi-ring.\n\n\nBut not all elements have an inverse element with respect to \\otimes. The \\varepsilon element does not have an inverse element with respect to \\otimes.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#powers-and-the-inverse-wrt-otimes",
    "href": "max_plus_algebra.html#powers-and-the-inverse-wrt-otimes",
    "title": "Max-plus algebra",
    "section": "Powers and the inverse wrt \\otimes",
    "text": "Powers and the inverse wrt \\otimes\n\nDenote the integer r-th power of x as x^{\\otimes^r}\n\n. . .\nx^{\\otimes^r} = x\\otimes x \\otimes \\ldots \\otimes x\n\nIt corresponds to rx in the conventional algebra: x^{\\otimes^r} = rx\nThe inverse element with respect to \\otimes can (also) be determined using the (-1)-th power as x^{\\otimes^{-1}} = -x.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#then",
    "href": "max_plus_algebra.html#then",
    "title": "Max-plus algebra",
    "section": "Then",
    "text": "Then\n. . .\nx^{\\otimes^0} = 0\n\nThere is no inverse element with respect to \\otimes for \\varepsilon,\n\nbut it is fine since \\varepsilon is a zero wrt \\oplus.\n\nIf r&gt;0 , then \\varepsilon^{\\otimes^r} = \\varepsilon .\nIf r&lt;0 , then \\varepsilon^{\\otimes^r} is undefined.\n\\varepsilon^{\\otimes^0} = 0 by convention.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#order-of-evaluation-of-max-formulas",
    "href": "max_plus_algebra.html#order-of-evaluation-of-max-formulas",
    "title": "Max-plus algebra",
    "section": "Order of evaluation of (max,+) formulas",
    "text": "Order of evaluation of (max,+) formulas\n\nIt is the same as that for the conventional algebra:\n\npower,\nmultiplication,\naddition.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#max-polynomials-aka-tropical-polynomials",
    "href": "max_plus_algebra.html#max-polynomials-aka-tropical-polynomials",
    "title": "Max-plus algebra",
    "section": "(max,+) polynomials (aka tropical polynomials)",
    "text": "(max,+) polynomials (aka tropical polynomials)\nFirst, just univariate polynomials\np(x) = a_{n}\\otimes x^{\\otimes^{n}} \\oplus a_{n-1}\\otimes x^{\\otimes^{n-1}} \\oplus \\ldots \\oplus a_{1}\\otimes x \\oplus a_{0},\n where a_i\\in \\mathbb R_\\varepsilon and n\\in \\mathbb N.\n. . .\nThis translates to the conventional polynomial as \np(x) = \\max\\{nx + a_n, (n-1)x + a_{n-1}, \\ldots, x+a_1, a_0\\}",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#example-of-a-1d-polynomial",
    "href": "max_plus_algebra.html#example-of-a-1d-polynomial",
    "title": "Max-plus algebra",
    "section": "Example of a 1D polynomial",
    "text": "Example of a 1D polynomial\n\np(x) = 2\\otimes x^{\\otimes^{2}} \\oplus 3\\otimes x \\oplus 1.\n\n\np(x) = \\max\\{2x+2,x+3,1\\}.\n\n\n\nCode\nusing Plots\nx = -5:3\nf(x) = max(2*x+2,x+3,1)\nplot(x,f.(x),label=\"\",thickness_scaling = 2)\nxc = [-2,1]\nyc = f.(xc)\nscatter!(xc,yc,markercolor=[:red,:red],label=\"\",thickness_scaling = 2)",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#example-of-a-2d-polynomial",
    "href": "max_plus_algebra.html#example-of-a-2d-polynomial",
    "title": "Max-plus algebra",
    "section": "Example of a 2D polynomial",
    "text": "Example of a 2D polynomial\n\np(x,y) = 0 \\otimes x \\otimes y\n\n\n\nCode\nusing Plots\nx = -2:0.1:2;\ny = -2:0.1:2;\nf(x,y) = max(0,x,y)\nz = f.(x',y);\nwireframe(x,y,z,legend=false,camera=(5,30))\nxlabel!(\"x\")\nylabel!(\"y\")\nzlabel!(\"f(x,y)\")",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#another-example",
    "href": "max_plus_algebra.html#another-example",
    "title": "Max-plus algebra",
    "section": "Another example",
    "text": "Another example\n\np(x,y) = 0 \\otimes x \\otimes y \\oplus (-1)\\otimes x^{\\otimes^2} \\oplus 1\\otimes x\\otimes y \\oplus (-1)\\otimes y^{\\otimes^2}\n\n\n\nCode\nusing Plots\nx = -2:0.1:2;\ny = -2:0.1:2;\nf(x,y) = max(0,x,y,2*x-1,x+y+1,2*y-1)\nz = f.(x',y);\nwireframe(x,y,z,legend=false,camera=(15,30))\nxlabel!(\"x\")\nylabel!(\"y\")\nzlabel!(\"p(x,y)\")",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#solution-set-zero-set",
    "href": "max_plus_algebra.html#solution-set-zero-set",
    "title": "Max-plus algebra",
    "section": "Solution set (zero set)",
    "text": "Solution set (zero set)",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#matrix-computations",
    "href": "max_plus_algebra.html#matrix-computations",
    "title": "Max-plus algebra",
    "section": "Matrix computations",
    "text": "Matrix computations\nFor matrix elements in \\mathbb R_\\varepsilon\n. . .\n(A\\oplus B)_{ij} = a_{ij}\\oplus b_{ij} = \\max(a_{ij},b_{ij})\n. . .\n\n\\begin{aligned}\n(A\\otimes B)_{ij} &= \\bigoplus_{k=1}^n a_{ik}\\otimes b_{kj}\\\\\n&= \\max_{k=1,\\ldots, n}(a_{ik}+b_{kj})\n\\end{aligned}\n\n. . .\n(Max-plus) zero matrix \\mathcal{E}_{m\\times n} has \\varepsilon as all the elements.\n. . .\n(Max-plus) identity matrix: I_n has 0 on the diagonal and \\varepsilon elsewhere.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#matrix-powers",
    "href": "max_plus_algebra.html#matrix-powers",
    "title": "Max-plus algebra",
    "section": "Matrix powers",
    "text": "Matrix powers\nA^{\\otimes^0} = I_n\n. . .\nA^{\\otimes^k} = A\\otimes A^{\\otimes^{k-1}} for k\\in \\mathbb N\\setminus\\{0\\}.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#connection-with-graph-theory-precedence-graph",
    "href": "max_plus_algebra.html#connection-with-graph-theory-precedence-graph",
    "title": "Max-plus algebra",
    "section": "Connection with graph theory – precedence graph",
    "text": "Connection with graph theory – precedence graph\n. . .\nA\\in \\mathbb R_\\varepsilon^{n\\times n}\n\nPrecedence graph: \\mathcal{G}(A)\n\nweighted directed graph with vertices 1, 2, …, n\nwith arcs (j,i) with weight a_{ij} for all a_{ij}\\neq \\varepsilon.\n\n\n. . .\n\n(A)^{\\otimes^k}_{ij} = \\max_{i_1,\\ldots,i_{k-1}\\in \\{1,2,\\ldots,n\\}} \\{a_{ii_1} + a_{i_1i_2} + \\ldots + a_{i_{k-1}j}\\}\n for all i,j and k\\in \\mathbb N\\setminus 0.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#example",
    "href": "max_plus_algebra.html#example",
    "title": "Max-plus algebra",
    "section": "Example",
    "text": "Example\n\nA =\n\\begin{bmatrix}\n2 & 3 & \\varepsilon\\\\\n1 & \\varepsilon & 0\\\\\n2 & -1 & 3\n\\end{bmatrix}\n\\qquad\nA^{\\otimes^2} =\n\\begin{bmatrix}\n4 & 5 & 3\\\\\n3 & 4 & 3\\\\\n5 & 5 & 6\n\\end{bmatrix}\n\n\n\n\n\n\n\n\nG\n\n\n1\n\n1\n\n\n\n1-&gt;1\n\n\n2\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n1\n\n\n\n3\n\n3\n\n\n\n1-&gt;3\n\n\n2\n\n\n\n2-&gt;1\n\n\n3\n\n\n\n2-&gt;3\n\n\n-1\n\n\n\n3-&gt;2\n\n\n0\n\n\n\n3-&gt;3\n\n\n3",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#irreducibility-of-a-matrix",
    "href": "max_plus_algebra.html#irreducibility-of-a-matrix",
    "title": "Max-plus algebra",
    "section": "Irreducibility of a matrix",
    "text": "Irreducibility of a matrix\n\nMatrix in \\mathbb R_\\varepsilon^{n\\times n} is irreducible if its precedence graph is strongly connected.\nMatrix is irreducible iff \n(A \\oplus A^{\\otimes^2} \\oplus \\ldots A^{\\otimes^{n-1}})_{ij} \\neq \\varepsilon \\quad \\forall i,j, i\\neq j.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#eigenvalues",
    "href": "max_plus_algebra.html#eigenvalues",
    "title": "Max-plus algebra",
    "section": "Eigenvalues",
    "text": "Eigenvalues\n\nA\\otimes v = \\lambda \\otimes v\n\n\nIn general, total number of (max,+) eigenvalues &lt;n.\nAn irreducible matrix has only one (max,+) eigenvalue.\nGraph-theoretic interpretation: maximum average weight over all elementary circuits…",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#eigenvalue-related-property-of-irreducible-matrices",
    "href": "max_plus_algebra.html#eigenvalue-related-property-of-irreducible-matrices",
    "title": "Max-plus algebra",
    "section": "Eigenvalue-related property of irreducible matrices",
    "text": "Eigenvalue-related property of irreducible matrices\nFor large enough k and c \nA^{\\otimes^{k+c}} = \\lambda^{\\otimes^c}\\otimes A^{\\otimes^k}",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#solving-max-linear-equations",
    "href": "max_plus_algebra.html#solving-max-linear-equations",
    "title": "Max-plus algebra",
    "section": "Solving (max,+)-linear equations",
    "text": "Solving (max,+)-linear equations\n\nA\\otimes x = b, \\quad A\\in \\mathbb R_\\varepsilon^{n\\times n}, \\quad b\\in \\mathbb R_\\varepsilon^n\n\n\nIn general no solution even if A is square.\nSubsolution \nA\\otimes x \\leq b\n\nSearch for the maximal subsolution instead,\nor solutions optimal in some other sense.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "max_plus_algebra.html#example-greatest-subsolution",
    "href": "max_plus_algebra.html#example-greatest-subsolution",
    "title": "Max-plus algebra",
    "section": "Example: greatest subsolution",
    "text": "Example: greatest subsolution\n\nA =\n\\begin{bmatrix}\n2 & 3 & \\varepsilon\\\\\n1 & \\varepsilon & 0\\\\\n2 & -1 & 3\n\\end{bmatrix},\n\\qquad\nb =  \n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\n. . .\n\nx =\n\\begin{bmatrix}\n1\\\\ -2 \\\\ 0\n\\end{bmatrix}\n\n. . .\n\nA \\otimes x =\n\\begin{bmatrix}\n1\\\\ 0 \\\\ 1\n\\end{bmatrix}\n\\leq b",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus algebra"
    ]
  },
  {
    "objectID": "stability_references.html",
    "href": "stability_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "8. Stability",
      "Literature"
    ]
  },
  {
    "objectID": "petri_nets.html",
    "href": "petri_nets.html",
    "title": "Petri nets",
    "section": "",
    "text": "Richer expressivity than finite state automata (a finite Petri net even for an infinite state automaton).\nTheory and tools available, e.g. (max,+) algebra.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#why-yet-another-modelling-framework-for-des",
    "href": "petri_nets.html#why-yet-another-modelling-framework-for-des",
    "title": "Petri nets",
    "section": "",
    "text": "Richer expressivity than finite state automata (a finite Petri net even for an infinite state automaton).\nTheory and tools available, e.g. (max,+) algebra.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#international-standards-available",
    "href": "petri_nets.html#international-standards-available",
    "title": "Petri nets",
    "section": "International standards available",
    "text": "International standards available\n\n‘ISO/IEC 15909-1:2019 Systems and Software Engineering — High-Level Petri Nets — Part 1: Concepts, Definitions and Graphical Notation’. ISO/IEC, August 2019. https://www.iso.org/standard/67235.html.\n‘ISO/IEC 15909-2:2011 Systems and Software Engineering — High-Level Petri Nets — Part 2: Transfer Format’. ISO/IEC, February 2011. https://www.iso.org/standard/43538.html.\n‘ISO/IEC 15909-3:2021: Systems and Software Engineering — High-Level Petri Nets — Part 3: Extensions and Structuring Mechanisms’. ISO/IEC, 2021. https://www.iso.org/standard/81504.html.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#petri-net-weighted-bipartite-graph",
    "href": "petri_nets.html#petri-net-weighted-bipartite-graph",
    "title": "Petri nets",
    "section": "Petri net = weighted bipartite graph",
    "text": "Petri net = weighted bipartite graph\n. . .\n\\boxed{PN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w\\}}\n\n\\mathcal{P} = \\{p_1, \\dots, p_n\\} … a finite set of places\n\\mathcal{T} = \\{t_1, \\dots, t_m\\} … a finite set of transitions\n\\mathcal{A} \\subseteq (\\mathcal{P} \\times \\mathcal{T}) \\cup (\\mathcal{T} \\times \\mathcal{P}) … a finite set of arcs\n\n(p_i, t_j) \\in \\mathcal{A} … from place p_i to transition t_j\n(t_j, p_i) \\in \\mathcal{A} … from transition t_j to place p_i\n\nw : \\mathcal{A} \\to \\mathbb{N} … a weight function",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#visualization",
    "href": "petri_nets.html#visualization",
    "title": "Petri nets",
    "section": "Visualization",
    "text": "Visualization\n\nPlaces = circles\nTransitions = bars\nArcs = arrowed curves\nWeights = numbers on the arcs\n\nalternatively, for a lower weight (2, 3, 4) by multiple arcs",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-of-a-simple-petri-net",
    "href": "petri_nets.html#example-of-a-simple-petri-net",
    "title": "Petri nets",
    "section": "Example of a simple Petri net",
    "text": "Example of a simple Petri net\n\n\n\\mathcal{P} = \\{p_1, p_2\\}\n\\mathcal{T} = \\{t_1\\}\n\\mathcal{A} = \\{\\underbrace{(p_1, t_1)}_{a_1}, \\underbrace{(t_1, p_2)}_{a_2}\\}\nw(a_1) = w((p_1, t_1)) = 2\nw(a_2) = w((t_1, p_2)) = 1",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#additional-definitions",
    "href": "petri_nets.html#additional-definitions",
    "title": "Petri nets",
    "section": "Additional definitions",
    "text": "Additional definitions\n\n\\mathcal{I}(t_j) … a set of input places of the transition t_j\n\\mathcal{O}(t_j) … a set of output places of the transition t_j",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-of-a-more-complex-petri-net",
    "href": "petri_nets.html#example-of-a-more-complex-petri-net",
    "title": "Petri nets",
    "section": "Example of a more complex Petri net",
    "text": "Example of a more complex Petri net\n\n\\mathcal{P} = \\{p_1, p_2, p_3, p_4\\}, \\quad \\mathcal{T} = \\{t_1, t_2, t_3, t_4, t_5\\}\n\\mathcal{A} = \\{(p_1, t_1), (t_1, p_1), (p_1, t_2),\\ldots\\}\nw((p_1, t_1)) = 2, \\; w((t_1, p_1)) = 1, \\; \\ldots\n\n. . .",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#marking",
    "href": "petri_nets.html#marking",
    "title": "Petri nets",
    "section": "Marking",
    "text": "Marking\n. . .\n  x: \\mathcal{P} \\rightarrow \\mathbb{N}\n. . .\n\\bm x = \\begin{bmatrix}x(p_1)\\\\ x(p_2)\\\\ \\vdots \\\\ x(p_n) \\end{bmatrix}\n\nwe prefer calling it… state.\nmarked Petri net: MPN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w,x\\}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#visualization-of-marked-petri-net-using-tokens",
    "href": "petri_nets.html#visualization-of-marked-petri-net-using-tokens",
    "title": "Petri nets",
    "section": "Visualization of marked Petri net using tokens",
    "text": "Visualization of marked Petri net using tokens\n\n\n\n\n\\bm x = \\begin{bmatrix}1\\\\ 0 \\end{bmatrix}\n\n\n. . .\n\n\n\n\n\\bm x = \\begin{bmatrix}2\\\\ 1 \\end{bmatrix}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#enabled-transition",
    "href": "petri_nets.html#enabled-transition",
    "title": "Petri nets",
    "section": "Enabled transition",
    "text": "Enabled transition\n\nx(p_i) \\geq w(p_i,t_j)\\quad \\forall p_i \\in \\mathcal{I}(t_j)\n\n\nEnabled transition can fire (can occur),\nbut it doesn’t have to (we will exploit this in timed PN).\n\n\nFor an example, see the previous slide: in the first marked PN the transitions cannot fire, in the second it can.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#state-transition-function",
    "href": "petri_nets.html#state-transition-function",
    "title": "Petri nets",
    "section": "State transition function",
    "text": "State transition function\n\nf: \\mathbb N^n \\times \\mathcal{T} \\rightarrow \\mathbb N^n,\n\n\nis defined for a transition t_j iff the transition is enabled.\nIf the transition t_j is enabled and fired, the state evolves as \n\\bm x^+ = f(\\bm x, t_j),\n\nwhere \\boxed{\n  x^+(p_i) = x(p_i) - w(p_i,t_j) + w(t_j,p_i), \\; i = 1,\\ldots,n.}\n\nFired transition moves tokens from the input to the output places.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-moving-tokens-around",
    "href": "petri_nets.html#example-moving-tokens-around",
    "title": "Petri nets",
    "section": "Example: moving tokens around",
    "text": "Example: moving tokens around\n. . .\n\n\n\\bm x_0 = [2, 0, 0, 1]^\\top (at the discrete time 0)\nenabled t_1",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-continued-fired-t_1",
    "href": "petri_nets.html#example-continued-fired-t_1",
    "title": "Petri nets",
    "section": "Example continued: fired t_1",
    "text": "Example continued: fired t_1\n. . .\n\n\n\\bm x_1 = [1, 1, 1, 1]^\\top (at the discrete time 1)\nenabled t_1, t_2, t_3",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-continued-fired-t_2",
    "href": "petri_nets.html#example-continued-fired-t_2",
    "title": "Petri nets",
    "section": "Example continued: fired t_2",
    "text": "Example continued: fired t_2\n. . .\n\n\n\\bm x_2 = [1, 1, 0, 2]^\\top (at the discrete time 2)\nbut now back to time 1…",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-continued-back-to-time-1",
    "href": "petri_nets.html#example-continued-back-to-time-1",
    "title": "Petri nets",
    "section": "Example continued: back to time 1",
    "text": "Example continued: back to time 1\n. . .\n\n\n\\bm x_1 = [1, 1, 1, 1]^\\top (at the discrete time 1)\nenabled t_1, t_2, t_3, now fire t_3",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-continued-fired-t_3-instead",
    "href": "petri_nets.html#example-continued-fired-t_3-instead",
    "title": "Petri nets",
    "section": "Example continued: fired t_3 instead",
    "text": "Example continued: fired t_3 instead\n. . .\n\n\n\\bm x_2 = [0, 1, 0, 0]^\\top (at the discrete time 2)\nthe order of firing of enabled transitions matters.\n\n\nBut this dependence of the state evolution upon the order of firing the transitions is not surprising – we have already encountered it in automata when the active event set for a given state contains more then a single element.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#not-all-states-are-reachable",
    "href": "petri_nets.html#not-all-states-are-reachable",
    "title": "Petri nets",
    "section": "Not all states are reachable",
    "text": "Not all states are reachable\n. . .\n\n\nFrom the initial state [2,1], the only reachable state is [0,2].\n\n\nIndeed, the reachable final state is [0,2]. Note that the weight of the arc from the place p_1 to the transition t is 2, so both tokens are removed from the place p_1 when the transition t fires. But then the arc to the place p_2 has weight 1, so only one token is added to the place p_2. The other token is “lost”.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#reachability-tree-and-graph",
    "href": "petri_nets.html#reachability-tree-and-graph",
    "title": "Petri nets",
    "section": "Reachability tree and graph",
    "text": "Reachability tree and graph",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#number-of-tokens-need-not-be-preserved",
    "href": "petri_nets.html#number-of-tokens-need-not-be-preserved",
    "title": "Petri nets",
    "section": "Number of tokens need not be preserved",
    "text": "Number of tokens need not be preserved\nIt can be that \n\\sum_{p_i\\in\\mathcal{O}(t_j)}w(t_j,p_i) &lt; \\sum_{p_i\\in\\mathcal{I}(t_j)} w(p_i,t_j)\n\nor\n\n\\sum_{p_i\\in\\mathcal{O}(t_j)}w(t_j,p_i) &gt; \\sum_{p_i\\in\\mathcal{I}(t_j)} w(p_i,t_j)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#and-convergence-and-divergence",
    "href": "petri_nets.html#and-convergence-and-divergence",
    "title": "Petri nets",
    "section": "AND-convergence, AND-divergence",
    "text": "AND-convergence, AND-divergence",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#or-convergence-and-or-divergence",
    "href": "petri_nets.html#or-convergence-and-or-divergence",
    "title": "Petri nets",
    "section": "OR-convergence and OR-divergence",
    "text": "OR-convergence and OR-divergence",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#nondeterminism-conflict-in-a-pn",
    "href": "petri_nets.html#nondeterminism-conflict-in-a-pn",
    "title": "Petri nets",
    "section": "Nondeterminism (conflict) in a PN",
    "text": "Nondeterminism (conflict) in a PN\n. . .\n\n\nSimilarly as in automata, if the active event set for a given state contains more than one element (event,transition).",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#subclass-of-pn-event-graph",
    "href": "petri_nets.html#subclass-of-pn-event-graph",
    "title": "Petri nets",
    "section": "Subclass of PN: Event graph",
    "text": "Subclass of PN: Event graph\n\n\n\n\n\nEach place one input and one output transition (all ws equal to 1).\nNo OR-convergence, no OR-divergence.\nAlso known as Decision-free PN.\nIt can model synchronization.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#another-subclass-state-machine",
    "href": "petri_nets.html#another-subclass-state-machine",
    "title": "Petri nets",
    "section": "Another subclass: State machine",
    "text": "Another subclass: State machine\n\n\n\n\n\nEach transition has one input and one output place.\nNo AND-convergence, no AND-divergence.\nDoes not model synchronization.\nIt can model race conditions.\nWith no source (input) and sink (output) transitions, the No. of tokens is preserved.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#incidence-matrix",
    "href": "petri_nets.html#incidence-matrix",
    "title": "Petri nets",
    "section": "Incidence matrix",
    "text": "Incidence matrix\n. . .\n\n\\bm A \\in \\mathbb{Z}^{n\\times m},\n where n is the number of places and m is the number of transitions, and\n. . .\n\na_{ij} = w(t_j,p_i) - w(p_i,t_j).\n\n\nSome define it as the transpose.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#state-equation-for-a-petri-net",
    "href": "petri_nets.html#state-equation-for-a-petri-net",
    "title": "Petri nets",
    "section": "State equation for a Petri net",
    "text": "State equation for a Petri net\n\n\\bm x^+ = \\bm x + \\bm A \\bm u,\n where \\bm u is a firing vector for the enabled j-th transition \n\\bm u = \\bm e_j = \\begin{bmatrix}0 \\\\ \\vdots \\\\ 1\\\\ \\vdots\\end{bmatrix}\n with the 1 at the j-th position.\n\nNote that Cassandras in his book defines everything in terms of the transposed quantities, but I prefer sticking to the notion of a state vector as a column.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example",
    "href": "petri_nets.html#example",
    "title": "Petri nets",
    "section": "Example",
    "text": "Example\n\n\n\n\n\n\\bm x_0\n=\n\\begin{bmatrix}\n2\\\\ 0\\\\ 0\\\\ 1\n\\end{bmatrix}\n\n\n\n. . .\n\n\n\n\\bm A = \\begin{bmatrix}\n-1 & 0 & -1\\\\\n1 & 0 & 0\\\\\n1 & -1 & -1\\\\\n0 & 1 & -1\n\\end{bmatrix}\n\n\n\n\\begin{aligned}\n\\bm x_1 &= \\bm x_0 + \\bm A \\bm u_1\\\\\n\\bm x_2 &= \\bm x_1 + \\bm A \\bm u_2\\\\\n\\vdots &\n\\end{aligned}\n\n\n\n\nBeware the notation here: the lower index corresponds to the discrete time.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#queueing-systems-modelled-by-pn",
    "href": "petri_nets.html#queueing-systems-modelled-by-pn",
    "title": "Petri nets",
    "section": "Queueing systems modelled by PN",
    "text": "Queueing systems modelled by PN\n. . .\n\n\na is a spontaneous transition (no input places).\ns needs a customer in the queue and the server being idle.\nc needs the server being busy.\n\n. . .\n\\quad \\mathcal{P} = \\{Q, I, B\\}\n\nThe transition a is an input transition – the tokens are added to the system.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#section",
    "href": "petri_nets.html#section",
    "title": "Petri nets",
    "section": "",
    "text": "Initial state: (0,1,0)\nTrace (of transitions/events): \\{a,s,a,a,c,s,a\\}\nFinal state: (2,0,1)",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#some-more",
    "href": "petri_nets.html#some-more",
    "title": "Petri nets",
    "section": "Some more",
    "text": "Some more\n\n\nThe arrival transition always enabled.\nThe server can break down, and then be repaired.\nCompleting the service \\neq customer departure.\n\n\nd is an output transition – the tokens are removed from the system.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-beverage-vending-machine",
    "href": "petri_nets.html#example-beverage-vending-machine",
    "title": "Petri nets",
    "section": "Example: beverage vending machine",
    "text": "Example: beverage vending machine",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#timed-petri-nets-tpn",
    "href": "petri_nets.html#timed-petri-nets-tpn",
    "title": "Petri nets",
    "section": "Timed Petri nets (TPN)",
    "text": "Timed Petri nets (TPN)\n\nEnabled transitions do not have to fire immediately.\nIndeed, in general \\boxed{\\mathrm{ENABLING} \\neq \\text{FIRING}.}\nThere can be a delay between enabling and firing.\nFor the j-th transition, the delay of the k-th firing is v_{j,k}, v_j = \\{v_{j,1}, v_{j,2}, \\ldots \\}.\nBut not all transitions have to be timed.\nTimed transitions \\mathcal{T}_\\mathrm{D}\\subseteq \\mathcal{T},\nClock structure for a PN: \\mathcal{V} = \\{v_j\\mid t_j\\in\\mathcal{T}_\\mathrm{D}\\}\n\n. . .\n\\boxed{TPN = \\{\\mathcal{P}, \\mathcal{T}, \\mathcal{A}, w, x, \\mathcal{V}\\}}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-of-a-timed-petri-net",
    "href": "petri_nets.html#example-of-a-timed-petri-net",
    "title": "Petri nets",
    "section": "Example of a timed Petri net",
    "text": "Example of a timed Petri net\n\n\n\nModel of processing multiple tasks: task 1 and task 2 are processed sequentially, and task 3 is processed in parallel with them; task 4 can only be process after both tasks 2 and 3 are finished. Finishing individual tasks corresponds to the individual transitions. The transition 4 is untimed, it only expresses the logical requirement.\nSometimes instead of a bar, the untimed transitions are modelled using similarly thing rectangles as the timed transitions, but filled.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#places-can-also-be-delayed",
    "href": "petri_nets.html#places-can-also-be-delayed",
    "title": "Petri nets",
    "section": "Places can also be delayed",
    "text": "Places can also be delayed\n\nCalled holding time for a place.\nBut not adopted by all authors.\nMinimum time the token must rest in the place.\n\nIt can stay longer if the output transition is waiting for other places.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#timed-petri-net-dynamics",
    "href": "petri_nets.html#timed-petri-net-dynamics",
    "title": "Petri nets",
    "section": "Timed Petri net dynamics",
    "text": "Timed Petri net dynamics\n\nFor general Petri nets too complex, here we only consider event graphs.\nDefine:\n\n. . .\n\\{\\tau_{j,1}, \\tau_{j,2}, \\ldots\\} are firing times of the j-th transition.\n. . .\n\\{\\pi_{i,1},\\pi_{i,2},\\ldots\\} are times when the i-th place receives a token.\n. . .\nx_i = x(p_i) is the number of tokens at the i-th place,\n. . .\nx_{i,k} = \\left.x(p_i)\\right|_k, that is, after the k-th firing.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#section-1",
    "href": "petri_nets.html#section-1",
    "title": "Petri nets",
    "section": "",
    "text": "Assume first that x_{i,0} = 0: \\pi_{i,k} = \\tau_{j,k},\\quad p_i\\in \\mathcal{O}(t_j).\nBut generally x_{i,0} \\neq 0: \\pi_{i,k+x_{i,0}} = \\tau_{j,k},\\quad p_i\\in \\mathcal{O}(t_j),\nequivalently \\boxed{\\pi_{i,k} = \\tau_{j,k-x_{i,0}},\\quad p_i\\in \\mathcal{O}(t_j).}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#section-2",
    "href": "petri_nets.html#section-2",
    "title": "Petri nets",
    "section": "",
    "text": "For an untimed transition with a single input place \n\\tau_{j,k} = \\pi_{i,k}.\n\nFor a timed transition with a single input place \n\\tau_{j,k} = \\pi_{i,k} + v_{j,k}.\n\nFor a timed transition with multiple input places \\boxed{\n\\tau_{j,k} = \\max_{p_i\\in\\mathcal{I}(t_j)}\\{\\pi_{i,k}\\} + v_{j,k}.}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-1",
    "href": "petri_nets.html#example-1",
    "title": "Petri nets",
    "section": "Example",
    "text": "Example",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#section-3",
    "href": "petri_nets.html#section-3",
    "title": "Petri nets",
    "section": "",
    "text": "\\begin{aligned}\n\\tau_{1,k} &= \\max\\{\\pi_{1,k},\\pi_{3,k}\\}\\\\\n\\tau_{2,k} &= \\pi_{2,k}+v_{2,k}\n\\end{aligned}\n\n. . .\n\n\\begin{aligned}\n\\pi_{1,k} &= \\tau_{1,k-1}, \\qquad k=2,\\ldots, \\qquad \\pi_{1,0} = 0\\\\\n\\pi_{2,k} &= \\tau_{1,k-1}, \\qquad k=2,\\ldots, \\qquad \\pi_{2,0} = 0\\\\\n\\pi_{3,k} &= \\tau_{2,k}, \\qquad k=1,\\ldots\n\\end{aligned}\n\n. . .\n\n\\begin{aligned}\n\\tau_{1,k} &= \\max\\{\\tau_{1,k-1},\\tau_{1,k-1}+v_{2,k}\\}\\\\\n&= \\tau_{1,k-1}+v_{2,k}, \\quad \\tau_{1,k} = 0\\\\\n\\tau_{2,k} &= \\tau_{1,k-1}+v_{2,k}\n\\end{aligned}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#queueing-system-using-tpn",
    "href": "petri_nets.html#queueing-system-using-tpn",
    "title": "Petri nets",
    "section": "Queueing system using TPN",
    "text": "Queueing system using TPN\n. . .\n\n\nTransitions: \\mathcal{T} = \\{a,s,c\\}\nTimed/delayed transitions: \\mathcal{T}_\\mathrm{D} = \\{a,c\\}\nFiring delays: \\bm v = \\begin{bmatrix}v_a \\\\ v_c\\end{bmatrix}",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#relabel-the-transitions",
    "href": "petri_nets.html#relabel-the-transitions",
    "title": "Petri nets",
    "section": "Relabel the transitions",
    "text": "Relabel the transitions\n\n\\begin{aligned}\na_k &= a_{k-1} + v_{a,k},\\quad k=1,2,\\ldots,\\quad a_0 = 0\\\\\ns_k &= \\max\\{\\pi_{Q,k},\\pi_{I,k}\\}\\\\\nc_k &= \\pi_{B,k} + v_{c,k}\\\\\n\\pi_{Q,k} &= a_{k},\\quad k=1,2,\\ldots\\\\\n\\pi_{I,k} &= c_{k-1},\\quad k= 2, \\ldots, \\quad \\pi_{I,0}=1\\\\\n\\pi_{B,k} &= s_{k},\\quad k=1,2,\\ldots\\\\\n\\end{aligned}\n\n\n\n\\begin{aligned}\na_k &= a_{k-1} + v_{a,k},\\quad k=1,2,\\ldots,\\quad a_0 = 0\\\\\ns_k &= \\max\\{a_{k},c_{k-1}\\}\\\\\nc_k &= s_{k} + v_{c,k}\\\\\n&= \\max\\{a_{k},c_{k-1}\\} + v_{c,k},\\quad k=1,\\ldots, \\quad c_0=0\n\\end{aligned}\n\n\nThe time of completing the k-th task is given by the time at which the previous task was completed and the time needed to complete the k-th task itself,\nunless there is a gap in the queue after finishing the previous task, in which case the server must wait for the next task to arrive.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-trains",
    "href": "petri_nets.html#example-trains",
    "title": "Petri nets",
    "section": "Example: trains",
    "text": "Example: trains\n\n\nSynchronization of departures at a given station so that passenges can change trains.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-trains-continued",
    "href": "petri_nets.html#example-trains-continued",
    "title": "Petri nets",
    "section": "Example: trains continued",
    "text": "Example: trains continued",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#example-manufacturing",
    "href": "petri_nets.html#example-manufacturing",
    "title": "Petri nets",
    "section": "Example: manufacturing",
    "text": "Example: manufacturing",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#extensions",
    "href": "petri_nets.html#extensions",
    "title": "Petri nets",
    "section": "Extensions",
    "text": "Extensions\n\nColoured Petri nets (CPN): tokens can by of several types (colours), and the transitions can be enabled only if the tokens have the right colours.\nStochastic Petri nets (SPN): the delays are random variables.\n…",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#petri-nets-out-there",
    "href": "petri_nets.html#petri-nets-out-there",
    "title": "Petri nets",
    "section": "Petri nets out there",
    "text": "Petri nets out there\n\nGrafcet (GRAphe Fonctionnel de Commande Etapes): specification language for the functional description of the behaviour of the sequential part of a control system. Standardized by ‘IEC 60848:2013 GRAFCET Specification Language for Sequential Function Charts’. International standard. IEC, 27 February 2013. https://webstore.iec.ch/publication/3684 (also DIN EN 60848).\nSequential Function Chart (SFC) for PLC: ‘IEC 61131-3 Programmable Controllers - Part 3: Programming Languages’. International Standard. IEC, 20 February 2013. https://webstore.iec.ch/publication/4552.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "petri_nets.html#literature",
    "href": "petri_nets.html#literature",
    "title": "Petri nets",
    "section": "Literature",
    "text": "Literature\n\nChapters 4 and 5.3 in Cassandras, Christos G., and Stéphane Lafortune. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer, 2021. https://doi.org/10.1007/978-3-030-72274-6.\nChapter 2 in Baccelli, François, Guy Cohen, Geert Jan Olsder, and Jean-Pierre Quadrat. Synchronization and Linearity: An Algebra for Discrete Event Systems. Web ed. Chichester: Wiley, 2001. https://www.rocq.inria.fr/metalau/cohen/documents/BCOQ-book.pdf.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Petri nets"
    ]
  },
  {
    "objectID": "max_plus_software.html",
    "href": "max_plus_software.html",
    "title": "Software",
    "section": "",
    "text": "MaxPlus.jl package for Julia by Quentin Quadrat.\nMax-Plus Algebra Toolbox for Matlab by Jarosław Stańczyk.\n\n\n\n\n Back to top",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Software"
    ]
  },
  {
    "objectID": "complementarity_simulations.html",
    "href": "complementarity_simulations.html",
    "title": "Simulations using complementarity",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Simulations using complementarity"
    ]
  },
  {
    "objectID": "classes_PWA.html",
    "href": "classes_PWA.html",
    "title": "Piecewise affine systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Piecewise affine systems"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html",
    "href": "verification_temporal_logics.html",
    "title": "Temporal logics",
    "section": "",
    "text": "It is natural to invoke the standard (propositional) logic when defining whatever requirements – we require that “if this and that conditions are satisfied, then yet another condition must not hold”, and so on.\nIt turns out, however, that the spectrum of requirements expressed with propositional logic is not rich enough when specifying requirements for discrete-event and hybrid systems whose states evolve causally in time. Temporal logics add some more expressiveness.\nIndeed, the plural is correct – there are several temporal logics. Before listing the most common ones, we introduce the key temporal operators that are going to be used together with logical operators.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#temporal-operators",
    "href": "verification_temporal_logics.html#temporal-operators",
    "title": "Temporal logics",
    "section": "Temporal operators",
    "text": "Temporal operators\nThe name might be misleading here – the adjective temporal has nothing to do with time as measured by the wall clock. Instead, as (discrete) state trajectories form sequencies, temporal operators help express when certain properties must (or must not) be satisfied along the state trajectories.\n\nExample 1 Consider the state automaton for a controller for two traffic lights. The state trajectory for each light is a sequence of color states \\{\\text{green}, \\text{yellow}, \\text{red}, \\text{red-yellow}\\} of the traffic light. We may want to impose a requirement such that \\text{green} is never on at both lights at the same time. This we can easily express just with the standard logical operators, namely, \\neg(\\text{green}_1 \\land \\text{green}_2). But now consider that we require that sooner or later, \\text{green} must be on for each light (to guarantee fairness). And that this must be true all the time, that is, \\text{green} must come infinitely often. And, furthermore, that \\text{red} cannot come imediately after its respective \\text{green}.\n\nRequirements like these cannot be expressed with standard logical operators such as \\lnot, \\land, \\lor, \\implies and \\iff, and temporal operators must be introduced. Here they are.\n\nTemporal operators\n\n\nSymbol\nAlternative symbol\nMeaning\n\n\n\n\n\\mathbf{F}\n\\Diamond\nEventually (Finally)\n\n\n\\mathbf{G}\n\\Box\nGlobally (Always)\n\n\n\\mathbf{X}\n\\bigcirc\nNeXt\n\n\n\\mathbf{U}\n\\sqcup\nUntill\n\n\n\nWe are explaining their use while we introduce our first temporal logic.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#linear-temporal-logic-ltl",
    "href": "verification_temporal_logics.html#linear-temporal-logic-ltl",
    "title": "Temporal logics",
    "section": "Linear temporal logic (LTL)",
    "text": "Linear temporal logic (LTL)\n“Linear” refers to linearity in time (one after another, as opposed to branching). Consider a sequence of discrete states (aka state trajectory or path) of a given discrete-event or hybrid system that is iniated at some state x.\nWe now consider some property \\phi(x) of a sequence of states emanating from the state x. \\phi(x) evaluates to true or false. And indeed, while the argument of \\phi is a particular state, when evaluating \\phi, the full sequence is taken into consideration when evaluating \\phi(x).\nIn order to be able to express requirements on future states, \\phi() cannot be just a logical formula, it must by a LTL formula. Here comes a formal definition \n\\begin{aligned}\n\\phi &= \\text{true} \\, | \\, p \\, | \\, \\neg \\phi_1 \\, | \\, \\phi_1 \\land \\phi_2 \\, | \\, \\phi_1 \\lor \\phi_2 \\\\\n&\\quad | \\, \\mathbf{X} \\phi_1 \\, | \\, \\mathbf{F} \\phi_1 \\, | \\, \\mathbf{G} \\phi_1 | \\, \\phi_1 \\mathbf{U} \\phi_2\n\\end{aligned}\n\nHaving an LTL formula, we write that a state sequence emanating from a given discrete state x satisfies the formula as x \\models \\phi if \\phi is true for all possible state trajectories starting at this state.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#examples-of-ltl-formulas",
    "href": "verification_temporal_logics.html#examples-of-ltl-formulas",
    "title": "Temporal logics",
    "section": "Examples of LTL formulas",
    "text": "Examples of LTL formulas\n\n\\mathbf{G}\\neg \\phi\n\n\n\\mathbf{G}\\mathbf{F} \\phi\n\n\n\\mathbf{F}\\mathbf{G} \\phi\n\n\n\\mathbf{F}(\\phi_1 \\land \\mathbf{X}\\mathbf{F}\\phi_2)",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#ctl-ctl-mixed-with-ltl-supports-branching",
    "href": "verification_temporal_logics.html#ctl-ctl-mixed-with-ltl-supports-branching",
    "title": "Temporal logics",
    "section": "CTL* (CTL mixed with LTL) supports branching",
    "text": "CTL* (CTL mixed with LTL) supports branching\n\nExistential quantifiers needed\n\n\\mathbf{A}: For all\n\\mathbf{E}: There exists",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "verification_temporal_logics.html#literature",
    "href": "verification_temporal_logics.html#literature",
    "title": "Temporal logics",
    "section": "Literature",
    "text": "Literature\n\nLin, Hai, and Panos J. Antsaklis. Hybrid Dynamical Systems: Fundamentals and Methods. Advanced Textbooks in Control and Signal Processing. Cham: Springher, 2022. Chapter 3.\nMitra, Sayan. Verifying Cyber-Physical Systems: A Path to Safe Autonomy. Cyber Physical Systems Series. Cambridge, MA, USA: MIT Press, 2021. https://sayanmitracode.github.io/cpsbooksite/about.html.\nBaier, Christel, and Joost-Pieter Katoen. Principles of Model Checking. Cambridge, MA, USA: MIT Press, 2008.\nClarke, Edmund M., Jr, Orna Grumberg, Daniel Kroening, Doron Peled, and Helmut Veith. Model Checking. 2nd ed. Cyber Physical Systems Series. Cambridge, MA, USA: MIT Press, 2018.\nMurray, Richard M, Ufuk Topcu, and Nok Wongpiromsarn. ‘Lecture 3 Linear Temporal Logic (LTL)’. Lecture presented at the EECI-IGSC, Belgrade (Serbia), 9 March 2020. http://www.cds.caltech.edu/~murray/courses/eeci-sp2020/L3_ltl-09Mar2020.pdf.\nWongpiromsarn, Nok, Richard M. Murray, and Ufuk Topcu. ‘Lecture 4 Model Checking and Logic Synthesis’. Lecture presented at the EECI-IGSC, Belgrade (Serbia), 9 March 2020. http://www.cds.caltech.edu/~murray/courses/eeci-sp2020//L4_model_checking-09Mar2020.pdf.",
    "crumbs": [
      "12. Formal verification",
      "Temporal logics"
    ]
  },
  {
    "objectID": "max_plus_references.html",
    "href": "max_plus_references.html",
    "title": "Literature",
    "section": "",
    "text": "One last time in this course we refer to Cassandras and Lafortune (2021), a comprehensive and popular introduction do discrete event systems. A short introduction to the framework (max,+) algebra can be found (under the somewhat less known name “Dioid algebras”) in Chapter 5.4.\nBut as a recommendable alternative, (any one of) the a series of papers by Bart de Schutter (TU Delft) and his colleagues can be read instead. For example De Schutter et al. (2020) and De Schutter and van den Boom (2000).\nFor anyone interested in learning yet more, a beautiful (and freely online) book is Baccelli et al. (2001), which we have also mentioned in the context of Petri nets.\nMax-plus algebra is relevant outside the domain of discrete-event systems – it is also investigated in optimization for its connection with piecewise linear/affine functions. Note that the community prefers using the name tropical geometry (to emphasise that they view it as a branch of algebraic geometry). A lovely tutorial is Rau (2017).\n\n\n\n\n Back to topReferences\n\nBaccelli, François, Guy Cohen, Geert Jan Olsder, and Jean-Pierre Quadrat. 2001. Synchronization and Linearity: An Algebra for Discrete Event Systems. Web edition. Chichester: Wiley. https://www.rocq.inria.fr/metalau/cohen/documents/BCOQ-book.pdf.\n\n\nCassandras, Christos G., and Stéphane Lafortune. 2021. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer. https://doi.org/10.1007/978-3-030-72274-6.\n\n\nDe Schutter, Bart, and Ton van den Boom. 2000. “Model Predictive Control for Max-Plus-Linear Discrete-Event Systems: Extended Report & Addendum.” Technical Report bds:99-10a. Delft, The Netherlands: Delft University of Technology. https://pub.deschutter.info/abs/99_10a.html.\n\n\nDe Schutter, Bart, Ton van den Boom, Jia Xu, and Samira S. Farahani. 2020. “Analysis and Control of Max-Plus Linear Discrete-Event Systems: An Introduction.” Discrete Event Dynamic Systems 30 (1): 25–54. https://doi.org/10.1007/s10626-019-00294-w.\n\n\nRau, Johannes. 2017. “A First Expedition to Tropical Geometry.” https://www.math.uni-tuebingen.de/user/jora/downloads/FirstExpedition.pdf.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Literature"
    ]
  },
  {
    "objectID": "solution_references.html",
    "href": "solution_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "7. Solution",
      "Literature"
    ]
  },
  {
    "objectID": "classes_switched.html",
    "href": "classes_switched.html",
    "title": "Switched systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Switched systems"
    ]
  },
  {
    "objectID": "verification_reachability.html",
    "href": "verification_reachability.html",
    "title": "Reachability",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "12. Formal verification",
      "Reachability"
    ]
  },
  {
    "objectID": "classes_reset.html",
    "href": "classes_reset.html",
    "title": "Reset systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "6. Some classes of hybrid systems",
      "Reset systems"
    ]
  },
  {
    "objectID": "complementarity_systems.html",
    "href": "complementarity_systems.html",
    "title": "Complementarity systems",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity systems"
    ]
  },
  {
    "objectID": "intro_references.html",
    "href": "intro_references.html",
    "title": "Literature",
    "section": "",
    "text": "The discipline of hybrid system is huge and spans several areas of science and engineering. As a result, finding a single comprehensive reference is difficult if not impossible. The more so that our selection of topics is inevitably biased. Admittedly, our selections of both topics and references will mostly be biased towards control engineering, and yet even within that discipline we have our own preferences. Therefore, we will always provide a list of references when studying particular topics.",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "intro_references.html#overview-texts-freely-available-online",
    "href": "intro_references.html#overview-texts-freely-available-online",
    "title": "Literature",
    "section": "Overview texts freely available online",
    "text": "Overview texts freely available online\nAmong the texts that provide motivation for studying hybrid systems as well as some introduction into theoretical and computational frameworks, we recommend Heemels et al. (2009), which is also available on the author’s webpage. Yet another overview, which is also available online, is Johansson (2004). And yet another is De Schutter et al. (2009), which is available on the author’s web page. The quartet of recommended online resources is concluded by Lygeros (2004).",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "intro_references.html#books-not-available-freely-online-at-least-we-are-not-aware-of-such-versions",
    "href": "intro_references.html#books-not-available-freely-online-at-least-we-are-not-aware-of-such-versions",
    "title": "Literature",
    "section": "Books not available freely online (at least we are not aware of such versions)",
    "text": "Books not available freely online (at least we are not aware of such versions)\nAmong the printed books, for which we are not aware of legally available online versions, the slim book van der Schaft and Schumacher (2000) can be regarded as the classic.\n\nThe handbook Lunze and Lamnabhi-Lagarrigue (2009) contains a wealth of contributions from several authors (in fact two of the online resources linked above are chapters from this book).\n\nThe latest textbook on the topic of hybrid systems is Lin and Antsaklis (2022). It comes closes as as a candidate for THE book for our course.\n\nSanfelice (2021)\n\ndd Goebel, Sanfelice, and Teel (2012). Although not available online, a shortened version appears as an article in a magazine Goebel, Sanfelice, and Teel (2009).\n\nLast but not least, Borrelli, Bemporad, and Morari (2017).",
    "crumbs": [
      "0. Introduction",
      "Literature"
    ]
  },
  {
    "objectID": "max_plus_systems.html#example-production-system",
    "href": "max_plus_systems.html#example-production-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Example: production system",
    "text": "Example: production system\n\n3 production units \\(P_1, P_2, P_3\\),\n\\(P_3\\) waits for the outputs from \\(P_1\\) and \\(P_2\\),\nprocessing delays \\(v_1 = 12, v_2 = 11, v_3 = 7\\),\ntransportation delays: \\(d_2 = 2\\) from the entry to \\(P_2\\), \\(d_4 = 1\\) from \\(P_2\\) to \\(P_3\\), the rest is negligible.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#timed-petri-net-event-graph-for-the-example",
    "href": "max_plus_systems.html#timed-petri-net-event-graph-for-the-example",
    "title": "Max-plus linear (MPL) systems",
    "section": "Timed Petri net (event graph) for the example",
    "text": "Timed Petri net (event graph) for the example",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#simplified-petri-net-delayed-places",
    "href": "max_plus_systems.html#simplified-petri-net-delayed-places",
    "title": "Max-plus linear (MPL) systems",
    "section": "Simplified Petri net (delayed places)",
    "text": "Simplified Petri net (delayed places)",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#state-equations-for-the-example",
    "href": "max_plus_systems.html#state-equations-for-the-example",
    "title": "Max-plus linear (MPL) systems",
    "section": "State equations for the example",
    "text": "State equations for the example\n\\[\n\\begin{aligned}\nx_{1,k} &= \\max\\{x_{1,k-1} + 12, u_k + 0\\}\\\\\nx_{2,k} &= \\max\\{x_{2,k-1} + 11, u_k + 2\\}\\\\\nx_{3,k} &= \\max\\{x_{3,k-1} + 7, x_{1,k} +12 + 0, x_{2,k} + 11 + 1\\}\\\\\n&= \\max\\{x_{3,k-1} + 7, \\max\\{x_{1,k-1} + 12, u_k\\} +12, \\\\\n&\\qquad \\max\\{x_{2,k-1} + 11, u_k+2\\} + 12\\}\\\\\n&= \\max\\{x_{3,k-1} + 7, x_{1,k-1} + 24, x_{2,k-1} + 23, \\\\\n&\\qquad\\qquad u_k+14\\}\\\\\ny_k &= x_{3,k} + 7\n\\end{aligned}\n\\]",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#state-equations-in-max-algebra",
    "href": "max_plus_systems.html#state-equations-in-max-algebra",
    "title": "Max-plus linear (MPL) systems",
    "section": "State equations in (max,+) algebra",
    "text": "State equations in (max,+) algebra\n\\[\n\\begin{aligned}\n\\begin{bmatrix}\nx_{1,k} \\\\ x_{2,k} \\\\ x_{3,k}\n\\end{bmatrix}\n&=\n\\begin{bmatrix}\n12 & \\varepsilon & \\varepsilon\\\\\n\\varepsilon & 11 & \\varepsilon\\\\\n24 & 23 & 7\n\\end{bmatrix}\n\\otimes\n\\begin{bmatrix}\nx_{1,k-1} \\\\ x_{2,k-1} \\\\ x_{3,k-1}\n\\end{bmatrix}\n\\oplus\n\\begin{bmatrix}\n0 \\\\ 2 \\\\ 14\n\\end{bmatrix}\n\\otimes\nu_k\\\\\ny_k &=\n\\begin{bmatrix}\n\\varepsilon & \\varepsilon & 7\n\\end{bmatrix}\n\\otimes\nx_k\n\\end{aligned}\n\\]",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#model-or-an-event-graph-as-a-max-plus-linear-mpl-state-space-system",
    "href": "max_plus_systems.html#model-or-an-event-graph-as-a-max-plus-linear-mpl-state-space-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Model or an event graph as a Max-plus linear (MPL) state-space system",
    "text": "Model or an event graph as a Max-plus linear (MPL) state-space system\n\\[\n  \\begin{aligned}\n  x(k) &= A\\otimes x(k-1) \\oplus B\\otimes u(k),\\\\\n  y(k) &= C\\otimes x(k)\n  \\end{aligned}\n\\]\n\nor, equivalently (after relabelling) \\[\n\\begin{aligned}\nx(k+1) &= A\\otimes x(k) \\oplus B\\otimes u(k),\\\\\ny(k) &= C\\otimes x(k)\n\\end{aligned}\n\\]\n\n\nwhich mimics the conventional state-space system \\[\n  \\begin{aligned}\n  x(k+1) &= A x(k) + Bu(k),\\\\\n  y(k) &= Cx(k)\n  \\end{aligned}\n\\]\n\nBut the role of the variables \\(u(k), x(k), y(k)\\) is that they are event times, namely times of\n\narrivals of inputs,\nbeginning of processing\nfinishing of processing, respectively.\n\nThe independent variable \\(k\\) is now a counter of the events.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#simulation-of-an-mpl-system",
    "href": "max_plus_systems.html#simulation-of-an-mpl-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Simulation of an MPL system",
    "text": "Simulation of an MPL system\n\\[\n\\begin{aligned}\nx_1 &= A\\otimes x_0 \\oplus B\\otimes u_1\\\\\nx_2 &= A\\otimes x_1 \\oplus B\\otimes u_2\\\\\n    &= A\\otimes (A\\otimes x_0 \\oplus B\\otimes u_1) \\oplus B\\otimes u_2\\\\\n    &= A^{\\otimes^2}\\otimes x_0 \\oplus A\\otimes B\\otimes u_1 \\oplus B\\otimes u_2\\\\\n    &\\vdots    \n\\end{aligned}\n\\]\n. . .\n\\[\\boxed{\nx_k = A^{\\otimes^k}\\otimes x_0 \\oplus \\bigoplus_{i=1}^k A^{\\otimes^{k-i}} \\otimes B\\otimes u_i}\n\\]\n\nNote how the lower and upper bounds for the summation are shifted by 1 compared to the traditional convolution.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#linear-indeed-but-in-max-sense",
    "href": "max_plus_systems.html#linear-indeed-but-in-max-sense",
    "title": "Max-plus linear (MPL) systems",
    "section": "Linear, indeed, but in (max,+) sense",
    "text": "Linear, indeed, but in (max,+) sense\n\ntwo input sequences \\(u_1= \\{u_{1,1},u_{1,2},\\ldots\\}\\) and \\(u_2= \\{u_{2,1},u_{2,2},\\ldots\\}\\),\n(max,+)-linear combination \\(\\alpha \\otimes u_1 \\oplus \\beta \\otimes u_2\\) of the two inputs\ngives the same (max,+)-linear combination of the outputs \\(y_1\\) and \\(y_2\\).",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#input-output-response-eliminating-the-state-variables",
    "href": "max_plus_systems.html#input-output-response-eliminating-the-state-variables",
    "title": "Max-plus linear (MPL) systems",
    "section": "Input-output response – eliminating the state variables",
    "text": "Input-output response – eliminating the state variables\n\\[\nY = G\\otimes x_0 \\oplus H\\otimes U\n\\]\n. . .\n\\[\nH =\n\\begin{bmatrix}\nC\\otimes B & \\varepsilon & \\varepsilon & \\ldots & \\varepsilon\\\\\nC\\otimes A\\otimes B & C\\otimes B & \\varepsilon & \\ldots & \\varepsilon\\\\\nC\\otimes A^{\\otimes^2}\\otimes B & C\\otimes A\\otimes B & C\\otimes B & \\ldots & \\varepsilon\\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\nC\\otimes A^{\\otimes^{p-1}}\\otimes B & C\\otimes A^{\\otimes^{p-2}}\\otimes B & C\\otimes A^{\\otimes^{p-3}}\\otimes B & \\ldots & C\\otimes B\n\\end{bmatrix}\n\\]\n. . .\n\\[\nG =\n\\begin{bmatrix}\nC \\\\ C\\otimes A \\\\ C\\otimes A^{\\otimes^2} \\\\ \\vdots \\\\ C\\otimes A^{\\otimes^{p-1}}\n\\end{bmatrix}\n\\]\n\nThe capital U and Y are sequences composed of the “samples” of u and y.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#example-the-production-system",
    "href": "max_plus_systems.html#example-the-production-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Example (the production system)",
    "text": "Example (the production system)\n\\[\nY = \\begin{bmatrix}y_1 & y_2 & y_3 & y_4\\end{bmatrix}^\\top, \\quad U = \\begin{bmatrix}u_1 & u_2 & u_3 & u_4\\end{bmatrix}^\\top\n\\]\n. . .\n\\[\nx_0 = \\begin{bmatrix}\\varepsilon & \\varepsilon & \\varepsilon\\end{bmatrix}^\\top\n\\]\n. . .\n\\[\nH =\n\\begin{bmatrix}\n21 & \\varepsilon & \\varepsilon & \\varepsilon\\\\\n32 & 21 & \\varepsilon & \\varepsilon\\\\\n43 & 32 & 21 & \\varepsilon\\\\\n55 & 43 & 32 & 21\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#analysis-of-an-irreducible-mpl-system",
    "href": "max_plus_systems.html#analysis-of-an-irreducible-mpl-system",
    "title": "Max-plus linear (MPL) systems",
    "section": "Analysis of an irreducible MPL system",
    "text": "Analysis of an irreducible MPL system\nAutonomous MPL system \\[\nx_{k+c} = A^{\\otimes^{k+c}}\\otimes x_0\n\\]\n. . .\nFor large enough \\(k\\) and \\(c\\) \\[\nx_{k+c} = \\lambda^{\\otimes^c}\\otimes A^{\\otimes^{k}}\\otimes x_0 = \\lambda^{\\otimes^c}\\otimes x_k\n\\]\n. . .\n\\[\nx_{k+c}-x_k = c\\lambda\n\\]\n\nWhen the production system reaches a cyclic behaviour, the average cycle is \\(\\lambda\\). The average production rate is \\(1/\\lambda\\).",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#cosf-function-fo-mpc",
    "href": "max_plus_systems.html#cosf-function-fo-mpc",
    "title": "Max-plus linear (MPL) systems",
    "section": "Cosf function fo MPC",
    "text": "Cosf function fo MPC\n\\[\nJ = J_\\mathrm{output} + \\lambda J_\\mathrm{input}\n\\]\n. . .\nAt “time” \\(k\\), with the prediction horizon \\(N_\\mathrm{p}\\), with \\(n_\\mathrm{y}\\): \\[\nJ_\\mathrm{output} = \\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\max \\{y_{i,k+j} - r_{i,k+j},0\\}\n\\]\n\npenalizes tardiness (late delivery)\n\n\nIs the lower value for j correct?",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#alternative-output-costs",
    "href": "max_plus_systems.html#alternative-output-costs",
    "title": "Max-plus linear (MPL) systems",
    "section": "Alternative output costs",
    "text": "Alternative output costs\n. . .\n\\[\nJ_\\mathrm{output} = \\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\left|y_{i,k+j} - r_{i,k+j} \\right |\n\\]\n\npenalizes difference between the due and actual dates.\n\n. . .\n\\[\nJ_\\mathrm{output} = \\sum_{j=1}^{N_\\mathrm{p}-1}\\sum_{i=1}^{n_\\mathrm{y}} \\left |\\Delta^2 y_{i,k+j}\\right |\n\\]\n\nbalances the output rates.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#input-costs",
    "href": "max_plus_systems.html#input-costs",
    "title": "Max-plus linear (MPL) systems",
    "section": "Input costs",
    "text": "Input costs\n\\[\nJ_\\mathrm{input} = -\\sum_{j=0}^{N_\\mathrm{p}-1}\\sum_{l=1}^{n_\\mathrm{u}} u_{l,k+j}\n\\]\n\npenalizes early feeding (favours just-in-time feeding).\nNote the minus sign.",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#control-horizon-vs.-prediction-horizon",
    "href": "max_plus_systems.html#control-horizon-vs.-prediction-horizon",
    "title": "Max-plus linear (MPL) systems",
    "section": "Control horizon vs. prediction horizon",
    "text": "Control horizon vs. prediction horizon\n\nAssume constant feeding rate after the control horizon \\(N_\\mathrm{c}\\)\n\n. . .\n\\[\n\\Delta u_{k+j} = \\Delta u_{k+N_\\mathrm{c}-1},\\qquad j=N_\\mathrm{c},\\ldots, N_\\mathrm{p}-1\n\\] where \\(\\Delta u_k = u_k - u_{k-1}\\).\n\nor \\[\n\\Delta^2 u_{k+j} = 0,\\qquad j=N_\\mathrm{c},\\ldots, N_\\mathrm{p}-1\n\\] where \\(\\Delta^2 u_k = \\Delta u_k - \\Delta u_{k-1} = u_k - 2u_{k-1} + u_{k-2}\\)",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#inequality-constraints-for-mpc",
    "href": "max_plus_systems.html#inequality-constraints-for-mpc",
    "title": "Max-plus linear (MPL) systems",
    "section": "Inequality constraints for MPC",
    "text": "Inequality constraints for MPC\nMinimum and maximum separation of input and output events\n. . .\n\\[\na_{k+j} \\leq \\Delta u_{k+j} \\leq b_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{c}-1\n\\]\n. . .\n\\[\nc_{k+j} \\leq \\Delta y_{k+j} \\leq d_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{p}-1\n\\]\n. . .\nMaximum due dates for the output events \\[\ny_{k+j} \\leq r_{k+j},\\qquad j=0,1,\\ldots,N_\\mathrm{p}-1\n\\]\n. . .\nInput and output events are consecutive \\[\n\\Delta u_{k+j} \\geq 0, \\qquad j=0,1,\\ldots,N_\\mathrm{c}-1.\n\\]",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "max_plus_systems.html#the-mpl-mpc-optimization-problem-is-nonlinear",
    "href": "max_plus_systems.html#the-mpl-mpc-optimization-problem-is-nonlinear",
    "title": "Max-plus linear (MPL) systems",
    "section": "The MPL MPC optimization problem is nonlinear",
    "text": "The MPL MPC optimization problem is nonlinear\n\ngeneral nonlinear solvers (fmincon, ipopt, …)\nExtended Linear Complementarity Problem (ELCP) by De Schutter\nMixed Integer (Linear) Programming",
    "crumbs": [
      "3. Discrete-event systems: Max-plus systems",
      "Max-plus linear (MPL) systems"
    ]
  },
  {
    "objectID": "complementarity_constraints.html",
    "href": "complementarity_constraints.html",
    "title": "Complementarity constraints",
    "section": "",
    "text": "Yet another framework for modelling hybrid systems, which comes with a rich theory and efficient algorithms, is based on complementaristy constraints. Before we introduce that modelling framework in the next section, we first explain the very concept of complementarity constraints.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#why-complementarity-constraints",
    "href": "complementarity_constraints.html#why-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "",
    "text": "Yet another framework for modelling hybrid systems, which comes with a rich theory and efficient algorithms, is based on complementaristy constraints. Before we introduce that modelling framework in the next section, we first explain the very concept of complementarity constraints.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#definition-of-complementarity-constraints",
    "href": "complementarity_constraints.html#definition-of-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "Definition of complementarity constraints",
    "text": "Definition of complementarity constraints\nTwo variables x\\in\\mathbb R and y\\in\\mathbb R satisfy the complementarity constraint if x or y is equal to zero and both are nonnegative\nxy=0, \\; x\\geq 0,\\; y\\geq 0,\nor, using a dedicated compact notation:\n\\boxed{0\\leq x \\perp y \\geq 0.}\n\n\n\n\n\n\nBoth variables can be zero\n\n\n\nThe or in the above definition is not exclusive, therefore it is possible that both x and y are zero.\n\n\nThe concept and notation extends to vectors x\\in\\mathbb R^n and y\\in\\mathbb R^n, in which case the constraint is interpreted componentwise \\boxed{\\bm 0\\leq \\bm x \\perp \\bm y \\geq \\bm 0.}",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "complementarity_constraints.html#geometric-interpretation-of-complementarity-constraints",
    "href": "complementarity_constraints.html#geometric-interpretation-of-complementarity-constraints",
    "title": "Complementarity constraints",
    "section": "Geometric interpretation of complementarity constraints",
    "text": "Geometric interpretation of complementarity constraints\nThe set of admissible pairs (x,y) in the \\mathbb R^2 plane is constrained to the L-shaped subset given by the nonnegative x and y semi-axes (including the origin). The set is obviously nonconvex.",
    "crumbs": [
      "9. Complementarity systems",
      "Complementarity constraints"
    ]
  },
  {
    "objectID": "verification_intro.html",
    "href": "verification_intro.html",
    "title": "What is verification?",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "12. Formal verification",
      "What is verification?"
    ]
  },
  {
    "objectID": "des_automata.html",
    "href": "des_automata.html",
    "title": "(State) automata",
    "section": "",
    "text": "Having just discussed the concept of a discrete-event system, we now the most popular modeling framework for such systems: a state automaton, or just an automaton (plural automata). It is also known as a state machine or a (discrete) transition system.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#definition-of-an-automaton-can-include-marked-states",
    "href": "des_automata.html#definition-of-an-automaton-can-include-marked-states",
    "title": "(State) automata",
    "section": "Definition of an automaton can include marked states",
    "text": "Definition of an automaton can include marked states\n\\[\\boxed{\nG = \\{\\mathcal X,\\mathcal X_0,\\mathcal E,\\mathcal F, \\mathcal X_\\mathrm{m}\\},}\n\\] \\(\\mathcal X_\\mathrm{m} \\subseteq \\mathcal X\\) is the set of marked or accepting states.\n\n\nI do not particularly like this idea of mixing the model of the system with the requirements, but this is how it is.\nNote that within this definition we have three sets (subsets) of states: \\(\\mathcal X\\), \\(\\mathcal X_0\\) and \\(\\mathcal X_\\mathrm{m}\\).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#comment-on-an-alternative-notation",
    "href": "des_automata.html#comment-on-an-alternative-notation",
    "title": "(State) automata",
    "section": "Comment on an alternative notation",
    "text": "Comment on an alternative notation\n\nNote that later (when introducing hybrid automata), we will replace the letter \\(\\mathcal X\\) with \\(\\mathcal Q\\) in favour of continuous-valued dynamical (sub)systems described by differential equations \\(\\dot x = f(x,u)\\).\nSimilarly for other letters.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automaton-as-digraph-also-state-transition-diagram",
    "href": "des_automata.html#automaton-as-digraph-also-state-transition-diagram",
    "title": "(State) automata",
    "section": "Automaton as (di)graph (also state transition diagram)",
    "text": "Automaton as (di)graph (also state transition diagram)\n\nStates as nodes.\nTransitions as edges.\nEvents (actions) as labels for the edges\n\n(not necessarily unique).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example",
    "href": "des_automata.html#example",
    "title": "(State) automata",
    "section": "Example",
    "text": "Example\n\n\\(\\mathcal X = \\{x_1,x_2,x_3\\},\\quad \\mathcal X_0 = \\{x_1\\}\\)\n\\(\\mathcal E = \\{e_1,e_2,e_3\\}\\)\n\\(\\begin{aligned}\\mathcal F = \\{(x_1,e_1,x_2),(x_2,e_2,x_1),(x_1,e_3,x_3),(x_2,e_2,x_3)\\}\\end{aligned}\\)\n\n. . .\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nx₁\n\nx₁\n\n\n\ninit-&gt;x₁\n\n\n\n\n\nx₂\n\nx₂\n\n\n\nx₁-&gt;x₂\n\n\ne₁\n\n\n\nx₃\n\nx₃\n\n\n\nx₁-&gt;x₃\n\n\ne₂\n\n\n\nx₂-&gt;x₁\n\n\ne₂\n\n\n\nx₂-&gt;x₃\n\n\ne₃",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#active-event-function-and-set",
    "href": "des_automata.html#active-event-function-and-set",
    "title": "(State) automata",
    "section": "Active event function and set",
    "text": "Active event function and set\n\nActive event function \\(\\Gamma: \\mathcal X \\rightarrow 2^\\mathcal{E}\\) assigns to each state a set of active events.\nActive event set \\(\\Gamma(x)\\) is the set of active events in particular state \\(x\\).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#finite-state-automaton-fsa",
    "href": "des_automata.html#finite-state-automaton-fsa",
    "title": "(State) automata",
    "section": "Finite state automaton (FSA)",
    "text": "Finite state automaton (FSA)\n\nFinite set \\(\\mathcal X\\) of states.\nAlso: Finite state machine (FSM).\n\n\nRather superfluous definition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#execution-of-an-automaton",
    "href": "des_automata.html#execution-of-an-automaton",
    "title": "(State) automata",
    "section": "Execution of an automaton",
    "text": "Execution of an automaton\n\n\\(x_1\\xrightarrow{e_1} x_2\\xrightarrow{e_2} x_1 \\xrightarrow{e_1} x_2 \\xrightarrow{e_4} x_3\\ldots\\)\nSometimes also written as \\(x_1,e_1,x_2,e_2,\\ldots\\)\n\n\n\n\n\n\n\n\nNotational confusion\n\n\n\n\\(x_k\\) for some \\(k\\) is the name of a particular state. It is not the name of a (yet to be introduced) state variable; In fact, it can be viewed of its value (also valuation).\n\n\n\nSome authors strictly distinguish between the state variable and the state (variable valuation),\n\nsimilarly as in probability theory random variable \\(X\\) vs its value \\(x\\), as in \\(F(x) = P(X\\leq x)\\);\n\nsome do not, but then it may lead to confusion;\nyet some others avoid the problem by not introducing state variables and only working with enumerated states.\n\n\n\n\n\n\n\n\nNotational confusion 2\n\n\n\nEven worse, it is also tempting to interpret the lower index k as (discrete) time, but nope, in the previous k is not the time index.\nAgain, some authors do not distinguish…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#path-of-an-automaton",
    "href": "des_automata.html#path-of-an-automaton",
    "title": "(State) automata",
    "section": "Path of an automaton",
    "text": "Path of an automaton\nCorresponding to the execution\n\\[x_1\\xrightarrow{e_1} x_2\\xrightarrow{e_2} x_1 \\xrightarrow{e_1} x_2 \\xrightarrow{e_4} x_3\\ldots\\]\nthe path is just the sequence of visited states:\n\\[x_1,x_2,x_1,x_2,x_3,\\ldots\\]\n\nIn continuous-valued dynamical systems, we have a state trajectory, but then time stamps are attached to each visited state.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-beverage-vending-machine",
    "href": "des_automata.html#example-beverage-vending-machine",
    "title": "(State) automata",
    "section": "Example: Beverage vending machine",
    "text": "Example: Beverage vending machine\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nwaiting\n\nwaiting\n\n\n\ninit-&gt;waiting\n\n\n\n\n\nswiped\n\nswiped\n\n\n\nwaiting-&gt;swiped\n\n\nswipe card\n\n\n\nswiped-&gt;waiting\n\n\nreject payment\n\n\n\npaid\n\npaid\n\n\n\nswiped-&gt;paid\n\n\naccept payment\n\n\n\ncoke_dispensed\n\ncoke_dispensed\n\n\n\npaid-&gt;coke_dispensed\n\n\nchoose coke\n\n\n\nfanta_dispensed\n\nfanta_dispensed\n\n\n\npaid-&gt;fanta_dispensed\n\n\nchoose fanta\n\n\n\ncoke_dispensed-&gt;waiting\n\n\ntake coke\n\n\n\nfanta_dispensed-&gt;waiting\n\n\ntake fanta\n\n\n\n\n\n\n\n\n\nState sequence (path): waiting, swiped, paid, coke_dispensed, waiting\nEvents sequence: swipe card, accept payment, choose coke, take coke\n\n\n\nIndeed, the two states coke_dispensed and fanta_dispensed can be merged into just beverage_dispensed.\nHow about other paths? Longer? Shorter?",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-beverage-vending-machine-1",
    "href": "des_automata.html#example-beverage-vending-machine-1",
    "title": "(State) automata",
    "section": "Example: Beverage vending machine",
    "text": "Example: Beverage vending machine\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nwaiting\n\n\nwaiting\n\n\n\ninit-&gt;waiting\n\n\n\n\n\nswiped\n\nswiped\n\n\n\nwaiting-&gt;swiped\n\n\nswipe card\n\n\n\nswiped-&gt;waiting\n\n\nreject payment\n\n\n\npaid\n\npaid\n\n\n\nswiped-&gt;paid\n\n\naccept payment\n\n\n\ncoke_dispensed\n\ncoke_dispensed\n\n\n\npaid-&gt;coke_dispensed\n\n\nchoose coke\n\n\n\nfanta_dispensed\n\nfanta_dispensed\n\n\n\npaid-&gt;fanta_dispensed\n\n\nchoose fanta\n\n\n\ncoke_dispensed-&gt;waiting\n\n\ntake coke\n\n\n\nfanta_dispensed-&gt;waiting\n\n\ntake fanta\n\n\n\n\n\n\n\n\nThe waiting state can be marked (is accepting).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-longitudinal-control-of-a-ground-vehicle",
    "href": "des_automata.html#example-longitudinal-control-of-a-ground-vehicle",
    "title": "(State) automata",
    "section": "Example: Longitudinal control of a ground vehicle",
    "text": "Example: Longitudinal control of a ground vehicle\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nstill\n\nstill\n\n\n\ninit-&gt;still\n\n\n\n\n\naccelerating\n\naccelerating\n\n\n\nstill-&gt;accelerating\n\n\npush acc\n\n\n\ncruising\n\ncruising\n\n\n\naccelerating-&gt;cruising\n\n\ncruise ON\n\n\n\ncoasting\n\ncoasting\n\n\n\naccelerating-&gt;coasting\n\n\nrel acc\n\n\n\ncruising-&gt;accelerating\n\n\npush acc\n\n\n\ncruising-&gt;coasting\n\n\nrel acc\n\n\n\nbraking\n\nbraking\n\n\n\ncruising-&gt;braking\n\n\npush brake\n\n\n\ncoasting-&gt;braking\n\n\npush brake\n\n\n\nbraking-&gt;still\n\n\nzero vel\n\n\n\nbraking-&gt;cruising\n\n\ncruise ON\n\n\n\nbraking-&gt;coasting\n\n\nrel brake\n\n\n\n\n\n\n\n\n\n\nBy cruise on I mean switching on some kind of a cruise control system, which keeps the velocity constant.\nIt turns out the optimal control strategy for trains (under some circumstances).\nNote that some of the events are indeed actions started by the driver, but some are just coming from the physics of the vehicle (transition from braking to zero velocity).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-corridor-switch",
    "href": "des_automata.html#example-corridor-switch",
    "title": "(State) automata",
    "section": "Example: Corridor switch",
    "text": "Example: Corridor switch\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\nswitch₁,switch₂\n\n\n\nON-&gt;OFF\n\n\nswitch₁,switch₂\n\n\n\n\n\n\n\n\n\nTwo events associated with one transitions can be seen as two transitions, each with a single event, both sharing the starting and ending states.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-double-intensity-switching",
    "href": "des_automata.html#example-double-intensity-switching",
    "title": "(State) automata",
    "section": "Example: Double intensity switching",
    "text": "Example: Double intensity switching\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\npush\n\n\n\nON-&gt;OFF\n\n\npush\n\n\n\nON2\n\nON2\n\n\n\nON-&gt;ON2\n\n\npush\n\n\n\nON2-&gt;OFF\n\n\npush\n\n\n\n\n\n\n\n\n\nObviously we need to introduce time into the automaton…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-as-the-value-of-a-state-variable",
    "href": "des_automata.html#state-as-the-value-of-a-state-variable",
    "title": "(State) automata",
    "section": "State as the value of a state variable",
    "text": "State as the value of a state variable\n\nDefinition of the state space by enumeration doesn’t scale well.\nState can be characterized as the value (sometimes also valuation) of a state variable.\nState variable \\(x\\) is given by\n\nthe name,\nthe “type” (boolean, integer, vector, …).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#examples-of-state-variables",
    "href": "des_automata.html#examples-of-state-variables",
    "title": "(State) automata",
    "section": "Examples of state variables",
    "text": "Examples of state variables\n\nCorridor switch: \\(x \\in \\{\\mathrm{false},\\mathrm{true}\\}\\) (also \\(\\{0,1\\}\\)).\nDouble intensity switching:\n\n\\(x \\in \\{0,1,2\\} \\subset \\mathbb Z\\),\nor \\(\\bm x = \\begin{bmatrix}x_1\\\\ x_2 \\end{bmatrix}\\), where \\(x_1,x_2 \\in \\{0,1\\}\\).\n\n\n\n\nValuation is the value of a variable in a particular state.\nIt is not necessarily only numeric.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-transition-equation",
    "href": "des_automata.html#state-transition-equation",
    "title": "(State) automata",
    "section": "State (transition) equation",
    "text": "State (transition) equation\n\\[\\boxed{x^+ = f(x,e)}\\]\n\nUpon introduction of discrete-time (index) \\(k\\) \\[x_{k+1} = f(x_k,e_k)\\]\nor \\[x[k+1] = f(x[k],e[k]).\\]\n\n\n\nThe function f can be defined by a computer code rather than a clean mathematical formula.\nThe discrete-time index of the event is sometimes considered shifted, that is $\\(x_{k+1} = f(x_k,e_{k+1})\\).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extension-moore-machine",
    "href": "des_automata.html#extension-moore-machine",
    "title": "(State) automata",
    "section": "Extension: Moore machine",
    "text": "Extension: Moore machine\n\nAutomaton with state outputs.\nOutput function assigns outputs to the states \\[y = g(x).\\]\nThe output is produced (emitted) when the (new) state is entered.\nThe output does not depend on the input. When plugged into feedback, no algebraic loops.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-of-a-moore-machine",
    "href": "des_automata.html#example-of-a-moore-machine",
    "title": "(State) automata",
    "section": "Example of a Moore machine",
    "text": "Example of a Moore machine\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nclosed\n\nNO FLOW\nValve\nclosed\n\n\n\ninit-&gt;closed\n\n\n\n\n\npartial\n\nFLOW\nValve\npartially\nopen\n\n\n\nclosed-&gt;partial\n\n\nopen valve one turn\n\n\n\npartial-&gt;closed\n\n\nclose valve one turn\n\n\n\nfull\n\nFLOW\nValve\nfully open\n\n\n\npartial-&gt;full\n\n\nopen valve one turn\n\n\n\nfull-&gt;closed\n\n\nemergency shut off\n\n\n\nfull-&gt;partial\n\n\nclose valve one turn\n\n\n\n\n\n\n\n\nThe outputs are the labels of the states.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extension-mealy-machine",
    "href": "des_automata.html#extension-mealy-machine",
    "title": "(State) automata",
    "section": "Extension: Mealy machine",
    "text": "Extension: Mealy machine\n\nAutomaton with input/output transition labels.\nThe transition label \\(e_\\mathrm{i}/e_\\mathrm{o}\\) on the transion from \\(x_1\\) to \\(x_2\\) reads as “the input event \\(e_\\mathrm{i}\\) at state \\(x_1\\) activates the transition to \\(x_2\\), which outputs the event \\(e_\\mathrm{o}\\)”. \\[x_1\\xrightarrow{e_\\mathrm{i}/e_\\mathrm{o}} x_2\\]\nIt can be viewed as if the output function also considers the input and not only the state \\(y = e_\\mathrm{o} = g(x,e_\\mathrm{i})\\).\nThe output is produced (emitted) during the transition (before the new state is entered).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-of-a-mealy-machine",
    "href": "des_automata.html#example-of-a-mealy-machine",
    "title": "(State) automata",
    "section": "Example of a Mealy machine",
    "text": "Example of a Mealy machine\nCoffee machine: coffee for 30 CZK, machine accepting 10 and 20 CZK coins, no change.\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\nNo coin\n\n\n\ninit-&gt;0\n\n\n\n\n\n10\n\n10 CZK\n\n\n\n0-&gt;10\n\n\ninsert 10 CZK / no coffee\n\n\n\n20\n\n20 CZK\n\n\n\n0-&gt;20\n\n\ninsert 20 CZK / no coffee\n\n\n\n10-&gt;0\n\n\ninsert 20 CZK / coffee\n\n\n\n10-&gt;20\n\n\ninsert 10 CZK / no coffee\n\n\n\n20-&gt;0\n\n\ninsert 10 CZK / coffee\n\n\n\n20-&gt;10\n\n\ninsert 20 CZK / coffee",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-reformulate-the-previous-example-as-a-moore-machine",
    "href": "des_automata.html#example-reformulate-the-previous-example-as-a-moore-machine",
    "title": "(State) automata",
    "section": "Example: reformulate the previous example as a Moore machine",
    "text": "Example: reformulate the previous example as a Moore machine\n. . .\nTwo more states wrt Mealy\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\nNO COFFEE\nNo\ncoin\n\n\n\ninit-&gt;0\n\n\n\n\n\n10\n\nNO COFFEE\n10\nCZK\n\n\n\n0-&gt;10\n\n\ninsert 10 CZK\n\n\n\n20\n\nNO COFFEE\n20\nCZK\n\n\n\n0-&gt;20\n\n\ninsert 20 CZK\n\n\n\n10-&gt;20\n\n\ninsert 10 CZK\n\n\n\n30\n\nCOFFEE\n10+20\nCZK\n\n\n\n10-&gt;30\n\n\ninsert 20 CZK\n\n\n\n20-&gt;30\n\n\ninsert 10 CZK\n\n\n\n40\n\nCOFFEE\n20+20\nCZK\n\n\n\n20-&gt;40\n\n\ninsert 20 CZK\n\n\n\n30-&gt;0\n\n\n\n\n\n30-&gt;10\n\n\ninsert 10 CZK\n\n\n\n30-&gt;20\n\n\ninsert 20 CZK\n\n\n\n40-&gt;10\n\n\n\n\n\n40-&gt;20\n\n\ninsert 10 CZK\n\n\n\n40-&gt;30\n\n\ninsert 20 CZK\n\n\n\n\n\n\n\n\n\nThere are transitions from 30 and 40 back to 0 that are not labelled by any event. This does not seem to follow the general rule that transitions are always triggered by events. Not what? It can be resolved upon introducing time as the timeout transitions.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-dijkstra-token-passing",
    "href": "des_automata.html#example-dijkstra-token-passing",
    "title": "(State) automata",
    "section": "Example: Dijkstra token passing",
    "text": "Example: Dijkstra token passing\n\n\n\n\n\n\n\nG\n\n\n0\n\n0\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\n\n\n\n3-&gt;0",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#data-type-for-the-state-vector",
    "href": "des_automata.html#data-type-for-the-state-vector",
    "title": "(State) automata",
    "section": "Data type for the state vector",
    "text": "Data type for the state vector\n```{julia}\nstruct DijkstraTokenRing\n    number_of_nodes::Int64\n    max_value_of_state_variable::Int64\n    state_vector::Vector{Int64}\nend\n```",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#state-update-transition-function",
    "href": "des_automata.html#state-update-transition-function",
    "title": "(State) automata",
    "section": "State update (transition) function",
    "text": "State update (transition) function\n```{julia}\nfunction update!(dtr::DijkstraTokenRing)                        \n    n = dtr.number_of_nodes\n    k = dtr.max_value_of_state_variable\n    x = dtr.state_vector\n    xnext = copy(x)\n1    for i in eachindex(x)\n        if i == 1                                              \n2            xnext[i] = (x[i] == x[n]) ? mod(x[i] + 1,k) : x[i]\n        else                                                    \n3            xnext[i] = (x[i] != x[i-1]) ? x[i-1] : x[i]\n        end\n    end\n    dtr.x .= xnext                                              \nend\n```\n\n1\n\nMind the +1 shift. x[2] corresponds to x₁ in the literature.\n\n2\n\nIncrement if the left neighbour is identical.\n\n3\n\nUpdate by the differing left neighbour.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#output-function",
    "href": "des_automata.html#output-function",
    "title": "(State) automata",
    "section": "Output function",
    "text": "Output function\nIt gives the position of the token.\n```{julia}\nfunction output(dtr::DijkstraTokenRing)\n    x = dtr.state_vector\n    y = similar(x)\n    y[1] = iszero(x[1]-x[end])\n    y[2:end] .= .!iszero.(diff(x))\n    return y\nend\n```",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#section",
    "href": "des_automata.html#section",
    "title": "(State) automata",
    "section": "",
    "text": "n = 4                           # Concrete number of nodes.\nk = n                           # Concrete max value of a state variable (must be &gt;= n).\nx_initial = rand(0:k,n)         # Initial state vector that does not necessarily guarantee acceptability (more than 1 token in the ring).\ndtr = DijkstraTokenRing(n,k,x_initial)\noutput(dtr)                     # Show where the token is (are).\n\nupdate!(dtr), output(dtr)       # Perform the update, show the state vector and show where the token is.\nupdate!(dtr), output(dtr)       # Repeat a few times to see the stabilization.    \nupdate!(dtr), output(dtr)",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#extended-state-automaton",
    "href": "des_automata.html#extended-state-automaton",
    "title": "(State) automata",
    "section": "Extended-state automaton",
    "text": "Extended-state automaton\n\nIndeed, the hyphen is there on purpose – we are extending the state space by additional state variables.\nAugmenting the state variable(s) that define the states/modes/locations (in the graph) by additional (typed) state variables: Int, Enum, Bool,…\n\nTransitions are then guarded by conditions on theses extra state variables.\nBesides the guard condition, the transitions is labelled also by a reset function that resets the extended state variables.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-counting-up-to-10",
    "href": "des_automata.html#example-counting-up-to-10",
    "title": "(State) automata",
    "section": "Example: counting up to 10",
    "text": "Example: counting up to 10\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\nOFF\n\nOFF\n\n\n\ninit-&gt;OFF\n\n\nint k=0\n\n\n\nON\n\nON\n\n\n\nOFF-&gt;ON\n\n\npress\n\n\n\nON-&gt;OFF\n\n\n(press ⋁ k ≥ 10); k=0\n\n\n\nON-&gt;ON\n\n\n(press ∧ k &lt; 10); k=k+1",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-state-machines-in-umlsysml",
    "href": "des_automata.html#automata-state-machines-in-umlsysml",
    "title": "(State) automata",
    "section": "Automata (state machines) in UML/SysML",
    "text": "Automata (state machines) in UML/SysML\n\n\nThey can do hierarchies and more.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-state-machines-in-openmodelica",
    "href": "des_automata.html#automata-state-machines-in-openmodelica",
    "title": "(State) automata",
    "section": "Automata (state machines) in (Open)Modelica",
    "text": "Automata (state machines) in (Open)Modelica",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#automata-in-simulink---stateflow-chart",
    "href": "des_automata.html#automata-in-simulink---stateflow-chart",
    "title": "(State) automata",
    "section": "Automata in Simulink -> Stateflow Chart",
    "text": "Automata in Simulink -&gt; Stateflow Chart",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#composing-automata",
    "href": "des_automata.html#composing-automata",
    "title": "(State) automata",
    "section": "Composing automata",
    "text": "Composing automata\nSynchronization through events: !,?\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n1\n\n1\n\n\n\ninit-&gt;1\n\n\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\npress?\n\n\n\n3\n\n3\n\n\n\n3-&gt;3\n\n\npress!",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#languages-and-automata",
    "href": "des_automata.html#languages-and-automata",
    "title": "(State) automata",
    "section": "Languages and automata",
    "text": "Languages and automata\n\nExtend the transition function: \\(f: \\mathcal X \\times \\mathcal E^\\ast \\rightarrow \\mathcal X\\), where \\(\\mathcal E^\\ast\\) stands for “all possible sequences of events”.\nLanguage generated by the automaton is \\[\n  \\mathcal L(\\mathcal G) = \\{s\\in\\mathcal E^\\ast \\mid f(x_0,s) \\;\\text{is defined}\\}\n  \\]\nLanguage marked by the automaton (the automaton is accepting or recognizing that language) \\[\n  \\mathcal L_\\mathrm{m}(\\mathcal G) = \\{s\\in\\mathcal L(\\mathcal G) \\mid f(x_0,s) \\in \\mathcal{X}_\\mathrm{m}\\}\n  \\]",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-languaged-accepted-by-automaton",
    "href": "des_automata.html#ex.-languaged-accepted-by-automaton",
    "title": "(State) automata",
    "section": "Ex.: languaged accepted by automaton",
    "text": "Ex.: languaged accepted by automaton\n\\[\n\\mathcal{E} = \\{a,b\\}, \\mathcal{L} = \\{a,aa,ba,aaa,aba,baa,bba,\\ldots\\}\n\\]\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n1\n\n\n1\n\n\n\n1-&gt;1\n\n\na\n\n\n\n1-&gt;0\n\n\nb\n\n\n\n0-&gt;1\n\n\na\n\n\n\n0-&gt;0\n\n\nb\n\n\n\n\n\n\n\n\n\nWhat if we remove the self loop at state 1? The automaton then accepts languages starting with a and endis with a.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#what-is-the-language-view-of-automata-good-for",
    "href": "des_automata.html#what-is-the-language-view-of-automata-good-for",
    "title": "(State) automata",
    "section": "What is the “language view of automata” good for?",
    "text": "What is the “language view of automata” good for?\n\nDefinitions, analysis, synthesis.\nWe then need language concepts such as\n\nconcatenation of strings: \\(\\quad c = ab\\)\nempty string \\(\\varepsilon\\): \\(\\quad\\varepsilon a = a \\varepsilon = a\\)\nprefix, suffix\nprefix closure \\(\\bar{\\mathcal{L}}\\) (of the language \\(\\mathcal L\\))\n…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#blocking",
    "href": "des_automata.html#blocking",
    "title": "(State) automata",
    "section": "Blocking",
    "text": "Blocking\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n2\n\n\n2\n\n\n\n2-&gt;0\n\n\ng\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\na\n\n\n\n1-&gt;2\n\n\nb\n\n\n\n5\n\n5\n\n\n\n1-&gt;5\n\n\ng\n\n\n\n3\n\n3\n\n\n\n1-&gt;3\n\n\na\n\n\n\n4\n\n4\n\n\n\n3-&gt;4\n\n\nb\n\n\n\n4-&gt;3\n\n\na\n\n\n\n4-&gt;4\n\n\ng\n\n\n\n\n\n\n\n\n\nDeadlock at state 2. Livelock at states 3 and 4.\n\\(\\bar{\\mathcal{L}}_\\mathrm{m}(\\mathcal G) \\sub \\mathcal L(\\mathcal G)\\).",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-systems",
    "href": "des_automata.html#queueing-systems",
    "title": "(State) automata",
    "section": "Queueing systems",
    "text": "Queueing systems\n\nentities (also customers, jobs, tasks, requests, etc.)\nresources (also servers, processors, etc.): customers are waiting for them\nqueues (also buffers): where waiting is done\n\n. . .",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#examples-of-queueing-systems",
    "href": "des_automata.html#examples-of-queueing-systems",
    "title": "(State) automata",
    "section": "Examples of queueing systems",
    "text": "Examples of queueing systems\n\nentities: people waiting for service in a bank or at a bust stop\nresources: people (again) in a bank at the counter\nqueues: bank lobbies, bus stops, warehouses, …\n\n\nWhat are other examples? - entities: packets, … - resources: processor, computer periphery, router, … - queues: …",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#why-study",
    "href": "des_automata.html#why-study",
    "title": "(State) automata",
    "section": "Why study?",
    "text": "Why study?\n\nResources are not unlimited\nTradeoff needed between customer satisfaction and fair resources allocation",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#networks-of-queueing-systems",
    "href": "des_automata.html#networks-of-queueing-systems",
    "title": "(State) automata",
    "section": "Networks of queueing systems",
    "text": "Networks of queueing systems",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-systems-as-automata",
    "href": "des_automata.html#queueing-systems-as-automata",
    "title": "(State) automata",
    "section": "Queueing systems as automata",
    "text": "Queueing systems as automata\n\nevents: \\(\\mathcal E = \\{\\text{arrival},\\text{departure}\\}\\)\nstates: number of customers in the queue \\[\n\\mathcal X = \\{0,1,2,3,\\ldots\\}, \\quad \\mathcal X_0 = \\{0\\}\n\\]\n\nnot a finite state automation, unless the queue is bounded.\n\nstate transition: \\[\nf(x,e) =\n\\begin{cases}\nx+1, & \\text{if}\\; x\\leq 0 \\land e = \\mathrm{arrival}\\\\\nx-1, & \\text{if}\\; x &gt; 0 \\land e = \\mathrm{departure}\n\\end{cases}\n\\]\n\n\nWhether the queue’s length is bounded is a modelling assumption.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#queueing-system-as-an-automaton",
    "href": "des_automata.html#queueing-system-as-an-automaton",
    "title": "(State) automata",
    "section": "Queueing system as an automaton",
    "text": "Queueing system as an automaton\n\n\nOnce again, note how the states correspond to the value of the state variable.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-of-a-queueing-system-jobs-processing-by-a-cpu",
    "href": "des_automata.html#example-of-a-queueing-system-jobs-processing-by-a-cpu",
    "title": "(State) automata",
    "section": "Example of a queueing system: jobs processing by a CPU",
    "text": "Example of a queueing system: jobs processing by a CPU",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#stochastic-queueing-systems",
    "href": "des_automata.html#stochastic-queueing-systems",
    "title": "(State) automata",
    "section": "Stochastic queueing systems",
    "text": "Stochastic queueing systems\n\nArrivals can be modelled using random processes.\nSimilarly the departures – delays (processing time) of the server can be modelled as random.\nBut then time needs to be included in the automaton, and so far we do not have it there.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#timed-automaton",
    "href": "des_automata.html#timed-automaton",
    "title": "(State) automata",
    "section": "Timed automaton",
    "text": "Timed automaton\n\nMotivation\n\nHow many events of a certain type in a given interval?\nIs the time interval between two events above a given threshold?\nHow long does the system spend in a given state?\n…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#timed-automaton-with-guards-alur-dill",
    "href": "des_automata.html#timed-automaton-with-guards-alur-dill",
    "title": "(State) automata",
    "section": "Timed automaton with guards (Alur & Dill)",
    "text": "Timed automaton with guards (Alur & Dill)\n\none or several resettable clocks: \\(c_i,\\, i=1,\\ldots, k\\), driven by the ODE \\[\n  \\frac{\\mathrm{d} c_i(t)}{\\mathrm d t} = 1, \\quad c_i(0) = 0.\n  \\]\neach transition labelled by the tripple {guard; event; reset}\n\n\nBoth satisfaction of the guard and arrival of the event constitute enabling conditions for the transition. They could be wrapped into a single compound condition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-ta-with-guards",
    "href": "des_automata.html#ex.-ta-with-guards",
    "title": "(State) automata",
    "section": "Ex.: TA with guards",
    "text": "Ex.: TA with guards\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n-; msg; c₁\n\n\n\n1-&gt;1\n\n\nc₁≥1; msg; c₁\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n0&lt;c₁&lt;1; msg; c₁\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\nc₁&lt;1; alarm; -",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#ex.-ta-with-guards-and-invariant",
    "href": "des_automata.html#ex.-ta-with-guards-and-invariant",
    "title": "(State) automata",
    "section": "Ex.: TA with guards and invariant",
    "text": "Ex.: TA with guards and invariant\n\n\n\n\n\n\n\nG\n\n\ninit\ninit\n\n\n\n0\n\n0\n\n\n\ninit-&gt;0\n\n\n\n\n\n2\n\n2\nc₁&lt;1\n\n\n\n3\n\n3\n\n\n\n2-&gt;3\n\n\n-; alarm; -\n\n\n\n1\n\n1\n\n\n\n0-&gt;1\n\n\n-; msg; c₁\n\n\n\n1-&gt;2\n\n\n0&lt;c₁&lt;1; msg; c₁\n\n\n\n1-&gt;1\n\n\nc₁≥1; msg; c₁",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#invariant-vs-guard",
    "href": "des_automata.html#invariant-vs-guard",
    "title": "(State) automata",
    "section": "Invariant vs guard",
    "text": "Invariant vs guard\n\nInvariant ((of a location)) gives an upper bound on the time the system can stay at the given location. It can leave earlier but not later.\nGuard (of a given transition) gives an enabling condition on leaving the location through the given transition.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#example-several-trains-approaching-a-bridge",
    "href": "des_automata.html#example-several-trains-approaching-a-bridge",
    "title": "(State) automata",
    "section": "Example: several trains approaching a bridge",
    "text": "Example: several trains approaching a bridge\n\nBehrmann, Gerd, Alexandre David, and Kim G. Larsen. ‘A Tutorial on Uppaal’. In Formal Methods for the Design of Real-Time Systems, edited by Marco Bernardo and Flavio Corradini, 200–236. Lecture Notes in Computer Science 3185. Berlin, Heidelberg: Springer, 2004. https://doi.org/10.1007/978-3-540-30080-9_7.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#software",
    "href": "des_automata.html#software",
    "title": "(State) automata",
    "section": "Software",
    "text": "Software\n\nUPPAAL (for timed automata)\nStateflow\nSimEvents\n(Open)Modelica – SimPy\nDiscreteEvents.jl, ConcurrentSim.jl\n…",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#literature",
    "href": "des_automata.html#literature",
    "title": "(State) automata",
    "section": "Literature",
    "text": "Literature\n\n\nCassandras, Christos G., and Stéphane Lafortune. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer, 2021.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "des_automata.html#literature-1",
    "href": "des_automata.html#literature-1",
    "title": "(State) automata",
    "section": "Literature",
    "text": "Literature\n\nLafortune, Stéphane. „Discrete Event Systems: Modeling, Observation, and Control”. Annual Review of Control, Robotics, and Autonomous Systems 2, č. 1 (2019): 141–59. https://doi.org/10.1146/annurev-control-053018-023659.",
    "crumbs": [
      "1. Discrete-event systems: Automata",
      "(State) automata"
    ]
  },
  {
    "objectID": "mld_DHA.html",
    "href": "mld_DHA.html",
    "title": "Discrete hybrid automata",
    "section": "",
    "text": "Since the new modelling framework is expected to be useful for prediction of a system response within model predictive control, it must model a hybrid system in discrete time. This is a major difference from what we did in our course so far.\nIn particular, we are going to model a hybrid system as a discrete(-time) hybrid automaton (DHA), which means that",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#four-components-of-a-discrete-time-hybrid-automaton",
    "href": "mld_DHA.html#four-components-of-a-discrete-time-hybrid-automaton",
    "title": "Discrete hybrid automata",
    "section": "Four components of a discrete(-time) hybrid automaton",
    "text": "Four components of a discrete(-time) hybrid automaton\nWe are already well familiar with the concept of a hybrid automaton, and the restriction to discrete time does not seem to warrant reopening the definition (modes/locations, guards, invariants/domains, reset maps, …). However, it turns out that reformulating/restructuring the hybrid automaton will be useful for our ultimate goal of developing an MPC-friendly modelling framework. In particular, we consider four components of a DHA:\n\nswitched affine system (SAS),\nmode selector (MS),\nevent generator (EG),\nfinite state machine (FSM).\n\nTheir interconnection is shown in the following figure.\n\nDraw the block diagram from Bemporad’s materials (book, toolbox documentation).\n\nLet’s discuss the individual components (and while doing that, you can think about the equivalent concept in the classical definition of a hybrid automaton such as mode, invariant, guard, …).\n\nSwitched affine systems (SAS)\nThis is a model of the continuous-value dynamics parameterized by the index i that evolves in (discrete) time \n\\begin{aligned}\nx_c(k+1) &= A_{i(k)} x_c(k) + B_{i(k)} u_c(k) + f_{i(k)}\\\\\ny_c(k) &= C_{i(k)} x_c(k) + D_{i(k)} u_c(k) + g_{i(k)}\n\\end{aligned}\n\nIn principle there is no need to restrict the right hand sides to affine functions as we did, but the fact is that the methods and tools are currently only available for this restricted class of systems.\n\n\nEvent generator (EG)\nWe consider partitioning of the state space or possibly state-control space into polyhedral regions. The system is then in the ith region of the state-input space, if the continuous-value state x_c(k) and the continuous-value control input u_c satisfy \nH_i x_c(k) + J_i u_c(k) + K_i \\leq 0\n\nThe event indicated by the (vector) binary variable \n\\delta_e(k) = h(x_c(k), u_c(k)) \\in \\{0,1\\}^m,\n\nwhere \nh_i(x_c(k), u_c(k)) = \\begin{cases}1 & H_i x_c(k) + J_i u_c(k) + K_i \\leq 0\\\\ 0 & \\text{otherwise}. \\end{cases}\n\n\n\nFinite state machine (FSM)\n\nx_d(k+1) = f_d(x_d(k),u_d(k),\\delta_e(k))\n\n\n\nMode selector (MS)\ni(k) \\in \\{1, 2, \\ldots, s\\}\n\ni(k) = \\mu(x_d(k), u_d(k), \\delta_e(k))",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#trajectory-of-a-dha",
    "href": "mld_DHA.html#trajectory-of-a-dha",
    "title": "Discrete hybrid automata",
    "section": "Trajectory of a DHA",
    "text": "Trajectory of a DHA\n\n\\begin{aligned}\n\\delta_e(k) &= h(x_c(k), u_c(k))\\\\\ni(k) &= \\mu(x_d(k), u_d(k), \\delta_e(k))\\\\\ny_c(k) &= C_{i(k)} x_c(k) + D_{i(k)} u_c(k) + g_{i(k)}\\\\\ny_d(k) &= g_d(x_d(k), u_d(k), \\delta_e(k))\\\\\nx_c(k+1) &= A_{i(k)} x_c(k) + B_{i(k)} u_c(k) + f_{i(k)}\\\\\nx_d(k+1) &= f_d(x_d(k),u_d(k),\\delta_e(k))\n\\end{aligned}",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#how-to-get-rid-of-the-if-then-conditions-in-the-model",
    "href": "mld_DHA.html#how-to-get-rid-of-the-if-then-conditions-in-the-model",
    "title": "Discrete hybrid automata",
    "section": "How to get rid of the IF-THEN conditions in the model?",
    "text": "How to get rid of the IF-THEN conditions in the model?",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mld_DHA.html#main-resources-for-the-lecture",
    "href": "mld_DHA.html#main-resources-for-the-lecture",
    "title": "Discrete hybrid automata",
    "section": "Main resource(s) for the lecture",
    "text": "Main resource(s) for the lecture\n\nBorrelli, Francesco, Alberto Bemporad, and Manfred Morari. Predictive Control for Linear and Hybrid Systems. Cambridge, New York: Cambridge University Press, 2017.\nBemporad, Alberto. Hybrid Toolbox for Matlab.",
    "crumbs": [
      "10. Mixed logical dynamical (MLD) systems",
      "Discrete hybrid automata"
    ]
  },
  {
    "objectID": "mpc_mld_references.html",
    "href": "mpc_mld_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "11. Model predictive control (MPC) for MLD systems",
      "Literature"
    ]
  },
  {
    "objectID": "stability_via_multiple_lyapunov_function.html",
    "href": "stability_via_multiple_lyapunov_function.html",
    "title": "Multiple Lyapunov function",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "8. Stability",
      "Multiple Lyapunov function"
    ]
  },
  {
    "objectID": "complementarity_references.html",
    "href": "complementarity_references.html",
    "title": "Literature",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "9. Complementarity systems",
      "Literature"
    ]
  },
  {
    "objectID": "petri_nets_references.html",
    "href": "petri_nets_references.html",
    "title": "Literature",
    "section": "",
    "text": "Literature for Petri nets is vast, but a decent (and perfectly satisfactory) introduction can be found in Chapter 4 and 5.3 (for the timed PN) of the classical (and award-winning) reference Cassandras and Lafortune (2021). Note that electronic version (in fact, PDF) is accessible through the NTK library (upon CTU login, for example to usermap first).\nA nice introduction is also in Chapter 2 of the freely online available book Baccelli et al. (2001). The book is available for free download.\nThe survey paper that is particularly focused on Petri nets from the control systems perspective is Giua and Silva (2018) and it gives a wealth of other references.\n\n\n\n\n Back to topReferences\n\nBaccelli, François, Guy Cohen, Geert Jan Olsder, and Jean-Pierre Quadrat. 2001. Synchronization and Linearity: An Algebra for Discrete Event Systems. Web edition. Chichester: Wiley. https://www.rocq.inria.fr/metalau/cohen/documents/BCOQ-book.pdf.\n\n\nCassandras, Christos G., and Stéphane Lafortune. 2021. Introduction to Discrete Event Systems. 3rd ed. Cham: Springer. https://doi.org/10.1007/978-3-030-72274-6.\n\n\nGiua, Alessandro, and Manuel Silva. 2018. “Petri Nets and Automatic Control: A Historical Perspective.” Annual Reviews in Control 45 (January): 223–39. https://doi.org/10.1016/j.arcontrol.2018.04.006.",
    "crumbs": [
      "2. Discrete-event systems: Petri nets",
      "Literature"
    ]
  },
  {
    "objectID": "solution_conditions.html",
    "href": "solution_conditions.html",
    "title": "Solution conditions",
    "section": "",
    "text": "About this site\n\n\n\n Back to top",
    "crumbs": [
      "7. Solution",
      "Solution conditions"
    ]
  }
]